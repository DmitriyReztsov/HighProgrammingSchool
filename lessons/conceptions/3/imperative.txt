 Явное состояние добавляет программной сущности долгосрочную память.

По поводу состояний часто упоминают термины stateless- и stateful-программирование. Под первым подразумевают обычно декларативное программирование, под вторым -- императивное программирование.

Декларативное программирование, буквально -- это набор деклараций, описывающих, какой результат требуется и, возможно, подсказывающих, как его получить.

Императивное программирование, буквально -- это набор команд, точно определяющих, как получить результат.

Декларативное программирование в некоторой степени императивно, так как нередко подразумевает последовательности команд. Декларативность -- это скорее относительная степень, так как многие языки развиваются именно в более выразительном декларативном направлении. 



1. Декларативный подход

Декларативный подход (что надо получить?) можно "применять" к любому программному коду. Например, код на функциональном языке может быть представлен как множество функций в математическом смысле (что надо вычислить?), или как множество команд для вычисления этих функций (как?), для которого добавляется характеристика порядка вычисления (наиболее популярны жадные и ленивые вычисления). Как только порядок вычислений определён, исходное декларативное представление функций можно исполнять на компьютере.

Аналогично и программы на логических языках можно воспринимать как набор логических аксиом (что?) или как набор команд (как?). Есть такое известное утверждение классика логического программирования Роберта Ковальски:

Программа = Логика + Управление

Логические аксиомы, дополненные информацией о потоке управления (либо явно заданной программистом, либо неявной, определяемой, например, движком логического вывода), и дают логической программе возможность исполнения на компьютере. 

 На практике декларативный подход (логическая или функциональная программа) обычно теряет большую часть своего аспекта "что", потому что приходится вдаваться в подробности "как". Например, декларативное определение поиска в дереве подразумевает почти столько же инструкций, сколько и императивное. Однако у декларативного программирования имеются три больших преимущества.

Во-первых, практически все абстракции легче формировать в декларативном сеттинге, так как декларативные операции по своей природе композиционны.

Во-вторых, декларативные программы легче тестировать, так как достаточно протестировать одиночные вызовы команд (подать аргументы и проверить результаты). Тестирование stateful-программ сложнее, так как приходится тестировать последовательности вызовов (из-за наличия внутренней истории).

В-третьих, рассуждения о программе с помощью декларативного программирования проще, чем при использовании императивного программировании. Например, при декларативном подходе возможно формальное алгебраическое рассуждение. 



2. Состояние (State)

Состояние -- это последовательность значений, растянутая во времени, которая содержит промежуточные результаты желаемого вычисления.

Скрытое (декларативное) состояние

Сама последовательность значений может существовать лишь в голове программиста, и никакой явной её поддержки со стороны вычислительной модели не существует. Например, рекурсивное вычисление факториала 5 подразумевает последовательное вычисление факториала 2, факториала 3, факториала 4 и факториала 5 -- это и есть состояние. Однако "физически", на уровне кода, такой последовательности не существует.

Явное состояние

Если требуется подсчитать количество вызовов функции вычисления факториала, придётся вводить состояние, которое существует внутри такой функции и в идеале скрыто от внешних функций, её вызывающих.

Явное состояние в функции -- это состояние, которое существует на протяжении более чем одного вызова этой функции без явного присутствия в её аргументах.

Явное состояние реализуется с помощью своего рода контейнера, который мы называем ячейка, и существует уже не только в сознании программиста.

Ячейка характеризуется
a) своим именем,
b) неограниченным сроком службы и
c) содержанием, которое может быть изменено.

Декларативная модель, расширенная ячейками, называется stateful-модель. 



3. Как продуктивно разрабатывать системы в stateful-модели и в императивном программировании?

Какое отношение концепция состояния имеет к построению сложных программных систем?

Самый успешный и продуктивный способ построения системы для людей, способности которых к логическому мышлению существенно ограничены -- это принцип абстракций. Любая система состоит из двух частей: спецификации и реализация.
Спецификация -- это формальный контракт, который определяет, как мир взаимодействует с системой, если смотреть на это взаимодействие со стороны.
Реализация -- это то, как система сконструирована, если смотреть на это изнутри неё.

Замечательное свойство спецификации в том, что спецификация, как правило, намного проще для понимания, нежели реализация. Не нужно знать, как устроены часы, чтобы понимать, какое время они показывают.

Это означает, что можно эффективно строить систему в виде серии слоев абстракций. В каждом слое формируется реализация, которая использует спецификацию более низкого уровня, и предоставляет свою спецификацию слою выше. Не обязательно пытаться понимать всю систему сразу.

Растущие системы

Принцип абстракции не очень хорошо поддерживается декларативным и функциональным программированием, потому что мы не можем вкладывать новые знания в компоненты или функции, инкапсулируя эти знания внутри. 



4. Принцип абстракции

Какой должна быть система, чтобы обеспечить наилучшую поддержку принципа абстракции?

У неё должны присутствовать три ключевые характеристики:
-- Инкапсуляция: возможность скрывать внутренние части системы;
-- Композиционность: возможность комбинировать части системы, чтобы получать новые части;
-- Instantiation/invocation: возможность создания множества экземпляров на основе единого их определения. После своего создания экземпляры самоподключаются к своему окружению, в котором будут существовать.

Даже поверхностным взглядом на эти характеристики программист, знакомый с ООП, выделит знакомые концепции: инкапсуляция уже присутствует; классы можно комбинировать путём наследования или композиции; на основе класса как типа данных можно создавать экземпляры, объекты, которые сразу же доступны для работы.

Но мы применяем научный подход и используем более универсальные, формальные и фундаментальные принципы программирования. Например, замыкания обеспечивают инкапсуляцию, и программирование высших порядков обеспечивает инстанцирование (создание экземпляров).

Важная особенность такого набора характеристик, что он не требует напрямую использования концепции состояния.

Инкапсуляция, формально говоря, вообще ортогональна состоянию, и её вполне можно применять в декларативном программировании, а состояния могут обходиться без инкапсуляции (например, через создание глобальных переменных). 

 Однако простое добавление состояния к декларативному программированию резко усложняет возможность рассуждения о программе, серьёзно затрудняет её понимание. Это прежде всего побочные эффекты, когда функция может менять состояния, которые видимы во всей остальной программе. Поэтому явное состояние правильно всегда применять в тесной связке с инкапсуляцией. Тогда появляется возможность проектировать stateful-системы корректно, для чего вводится понятие инварианта, который всегда правилен, если смотреть на него извне, "снаружи". Таким образом мы снова можем рассуждать о каждой подсистеме достаточно формально, считая, что её поведение не зависит от окружающей среды, что частично приближает нас к комфортному в этом плане декларативному программированию. Однако даже использование инвариантов не делает программировании с помощью состояний таким простым, как декларативное.

Инвариант сам по себе просто определяет, что некоторый компонент не ведет себя некорректно, но не гарантирует, что он помогает в продвижении к итоговой цели (решению). Хорошее правило для сложных систем -- создавать как можно больше компонентов в декларативной парадигме. Состояние не должно быть "размазано" по многим компонентам, его надо концентрировать буквально в единичных тщательно отобранных компонентах.



5. Компонентно-ориентированное программирование

Три вышеприведённые характеристики определяют так называемое компонентно-ориентированное программирование. Компонент специфицирует программный элемент и изнутри, и снаружи, то есть с чётко определенным интерфейсом. Внутренняя часть скрыта от внешнего наблюдения, за исключением того, что позволяет интерфейс. Компоненты могут комбинироваться для получения новых компонентов. Компоненты могут "инстанциироваться" -- создавать новые экземпляры с одинаковой структурой, которые сразу же включаются в рабочую среду.

Компоненты -- это вездесущая концепция. Программисты наверняка их постоянно встречают:

-- процедурная абстракция: компонент -- это определение некоторой функции с формальными параметрами, а его "экземпляр" -- это вызов данной функции с конкретными аргументами;

-- функтор (модуль компиляции): программный модуль, который компилируется в объектный код независимо от других компонентов. В таком случае функтор -- это исходный код модуля, который компилируется в модуль;

-- параллельные компоненты: система с независимыми и взаимодействующими сущностями может быть представлена как граф одновременно действующих компонентов, обменивающихся сообщениями.

Естественный путь расширения возможностей компонента -- это композиция. Создаём новый компонент, который содержит уже существующий. Новый компонент предлагает новую функциональность, а для её реализации в существенной степени применяется существующий компонент.

Множество современных систем самых разных архитектур выполнено в данной компонентной модели. 



6. Объектно-ориентированное программирование

Разработчики, знакомые с ООП, наверняка уже распознали в компонетно-ориентированном программировании ряд знакомых черт ООП, которое добавляет к компонентному подходу четвёртую характеристику.

Это наследование, которое важно даже не столько как техническая возможность расширения типов, сколько как возможность развивать систему очень плавно, постепенно, небольшими шагами, через небольшие расширения или модификации другой системы.

Постепенно развиваемые компоненты называются классы, и их экземпляры называются объекты.

Наследование -- это способ структурирования программ, при котором новая реализация основывается на уже существующей. Большой плюс наследования, что оно существенно снижает избыточность и дублирование кода за счёт повторного использования, и представляет собой весьма мощный и гибкий инструмент. Но это и большой минус: компоненты начинают сильно зависеть от компонентов, которые они наследуют, и в результате подобными зависимостями становится сложно управлять.

Подавляющая часть литературы по объектно-ориентированному проектированию, например, по шаблонам проектирования, фокусируется на обучении правильному использованию наследования. Хотя композиция -- подход менее гибкий, чем наследование, он гораздо проще в использовании, и рекомендуется использовать композицию везде, где это возможно, а наследование применять только тогда, когда композиции недостаточно, а наследование подходит к задаче естественно, а иерархии получаются неглубокие (2-3 уровня).

Я сторонник достаточно активного грамотного использования наследования (умеренной глубины), потому что с его помощью удаётся создавать очень аккуратные модульные системы с очень невысокой связностью между модулями. Как это делать, отдельно разбирается на курсах по ООАП. 




Декларативная модель с явным состоянием

Явное состояние -- это пара из двух сущностей языка программирования. Первая сущность -- это идентичность (identity) состояния, способ его именования в программе, а второе -- текущее содержание состояния (значение, с которым связано имя, идентичность состояния). И существует операция, которая позволяет через идентичность состояния получить текущее содержимое состояния.

7. Ячейка

Мы добавляем новый базовый тип в вычислительную модель -- явное состояние, и называем его ячейка.

Ячейка состоит из неизменяемого имени и связанной с ним ссылки на объект в хранилище однократных присваиваний. Так как имя ячейки менять не допускается, все ячейки получаются чистыми АТД. Множество всех ячеек располагается в мутабельном хранилище. 

 Итоговая вычислительная модель состоит из иммутабельного хранилища однократных присваиваний, которое хранит dataflow-переменные (которые могут быть связаны только с одним значением), и из мутабельного хранилища, которое хранит пары из имён и ссылок. В этой вычислительной модели существует простой язык программирования, который расширяет декларативную модель всего двумя операциями: NewCell и Exchange.

NewCell имеет два параметра C и X и создаёт новую ячейку с именем C и содержимым X.

Exchange имеет три параметра C, X и Y, связывает X с прежним (текущим) содержимым ячейки C, и задаёт этой ячейке новое содержимое Y.

Для большей выразительности в терминах этих операций в модель добавляются ещё две инструкции.

Операция @ организует доступ к содержимому ячейки C:

X = @C

Операция := присваивает ячейке C новое значение Y, и возвращает старое значение ячейки X:

C := Y

Удивительно, но добавления ячейки с двумя операциями (фактически, классические запись значения и считывание значения) достаточно, чтобы построить все замечательные концепции, которые может предоставить понятие состояния!

Все сложные концепции объектов, классов и других абстрактных типов данных могут быть построены с помощью декларативной модели, дополненной ячейками.

Это семантика, но и языки обычно имеют синтаксическую поддержку этих концепций, чтобы они стали простыми в использовании, а реализация обеспечивает их эффективность. 


Связь с декларативным программированием

Вообще говоря, stateful-программа не может считаться декларативной, так как её прогон несколько раз с одними и теми же входами может давать разные выходы в зависимости от её внутреннего состояния. Можно, однако, писать stateful-программы так, что они будут вести себя как если они декларативные -- т.е. писать их так, чтобы они удовлетворяли определению декларативной операции. Это сам по себе хороший принцип проектирования: писать stateful-компоненты так, чтобы они вели себя декларативно.

Можно взять любую функцию из предыдущего курса, например Filter(), и переписать её в императивном виде, без рекурсии: просто одним циклом перебрать все элементы списка, и если очередной элемент отвечает требованиям функции-предиката, добавляем его в список-результат. Этот список-результат -- локальная переменная внутри Filter, явное состояние, однако с точки зрения пользователя функция Filter осталась декларативной: она не меняет значения аргументов и не создаёт никаких других побочных эффектов. Мы просто сменили декларативную реализацию декларативной функции Filter на императивную, оставив её "интерфейс" (сигнатуру) неизменным.

Ещё одна полезная вещь, связанная с состоянием и декларативной моделью -- это мемоизация, когда функция запоминает результаты предыдущих вызовов (если они например требовали больших объёмов вычислений), и при повторных вызовах с теми же параметрами выдаёт результат молниеносно. Такая функция где-то внутри работает с состояниями (замыканием), однако формально остаётся декларативной.



Совместное использование (sharing)

При работе с состояниями возникает ряд тонких моментов, которые обязательно подлежат формализации. Это, прежде всего, понятие равенства ячеек. Можно ли считать, что две ячейки равны, если равно их содержание? А если два идентификатора X и Y ссылаются на одну и ту же ячейку? Такой случай называется совместное использование (sharing) или альясинг (aliasing), а подобные идентификаторы называют алиасы (термин, активно использующися в ИТ). Изменение содержимого X автоматически влечёт изменение содержимого Y, так как их содержимое на самом деле физически одно. Этот момент в ООП называется передача объекта по ссылке.

Когда алиасов ячейки много, понимание программы сразу существенно усложняется. Решается данная проблема инкапсуляцией состояния -- выделением всей логики работы с состоянием в небольшую и чётко определённую часть программы и определёнными гарантиями, что оно не сможет оттуда выбраться. Это одна из ключевых причин, по которой абстрактные типы данных -- особенно хорошая идея при использовании явных состояний, которые инкапсулируются в АТД и скрываются за набором корректных высокоуровневых операций. 


Как сравнивать значения ячеек?

Два значения в декларативной модели считаются равными, если они структурно эквивалентны, и значения всех полей в их структуре все равны друг другу:

X = person(age:25, name:"Petya")
Y = person(age:25, name:"Petya")

Значение X будет равно значению Y.

Однако в случае ячеек ситуация будет другая. Например, код

NewCell(X, 10)
NewCell(Y, 10)

создаёт две ячейки X и Y, каждая из которых хранит значение 10 (X и Y не алиасы), однако ячейки X и Y считаются не равны друг другу.

Схема проверки равенства ячеек называется эквивалентность токенов.

Равенство (эквивалентность) ячеек подразумевает, что при изменении содержимого одной ячейки изменится и содержимое другой ячейки -- фактически, "равные" ячейки просто должны быть алиасами.

Конечно, проверка равенства содержимого неэквивалентных ячеек вполне возможна:

@X == @Y

Но в целом, это просто совпадение; такое равенство очевидно не обязательно должно оставаться верным на протяжении работы всей программы, так как содержимое ячеек может меняться. 


Абстрактные типы данных (АТД)

Мы изучали абстрактный тип данных в декларативной модели -- это набор значений вместе с набором операций над этими значениями. Теперь мы добавим в АТД понятие состояния.

8. 8 способов организации АТД

АТД с одинаковой функциональностью "внутри" могут быть организованы (реализованы) по-разному. Например, ранее мы изучали, как сделать АТД защищённым. Теперь введём ещё две оси -- состояние и бандлинг (bundling; упаковка, связывание, комплектация), каждая из которых предлагает два варианта. Эти три оси ортогональны, и в общей сложности получается восемь способов для организации АТД. Одни из них используются редко, другие распространены, но у каждого свои преимущества и недостатки. 


1) Открытость и защищённость

Открытый АТД -- это такой АТД, внутреннее представление которого полностью видимо во всей программе. Реализация может быть распределена по всему коду, и различные её части могут расширять реализацию независимо друг от друга. Это полезно для небольших проектов, когда выразительность значительно важнее, нежели безопасность.

Защищенный (безопасный) АТД -- это такой АТД, реализация которого сосредоточена в одной части программы, и недоступна остальным частям. Обычно так желательно или требуется в больших проектах, потому что такой подход позволяет реализовать и тестировать АТД независимо. Возможно, вы удивитесь, но безопасный ADT может быть полностью определён в декларативной модели, используя принципы программирования высшего порядка. Никаких дополнительных концепций (например, имён и видимости) не требуется.

АТД может быть частично безопасным -- например, права на просмотр его внутренней реализации могут быть выданы контролируемым образом, как мы реализовывали функции Wrap и Unwrap для реализации стеков. 


2) Состояние

Stateless-АТД (или декларативный АТД) создаётся в декларативной модели. Декларативные экземпляры АТД модифицировать не разрешается: надо создавать новые сущности. Поэтому, когда процедуре передаётся экземпляр АТД, всегда можно быть уверенным, что это значение уникальное -- после своего создания экземпляр АТД никогда не изменяется. С другой стороны, такой подход приводит к увеличению количества экземпляров в программе, которыми со временем становится трудно управлять. Код также получается менее модульным, поскольку экземпляры должны явно передаваться по конвейеру даже через те части, которые могут и не нуждаться в экземпляре АТД.

Stateful-АТД внутри использует явное состояние. При таком подходе экземпляры АТД могут изменяться с течением времени. При этом нельзя быть уверенным, какое именно значение инкапсулировано внутри экземпляра, не зная истории всех вызовов процедур с момента его создания.

В отличие от декларативных АТД, в данном случае существует только один физический экземпляр. Более того, этот единственный экземпляр часто даже не нужно передавать в функции в качестве параметра; доступ к нему можно получить с помощью лексического замыкания. Такой подход делает программу более лаконичной. Программа также становится потенциально более модульной, поскольку части, которым не нужен экземпляр, можно не упоминать. 


3) Бандлинг

Наряду с безопасностью и состоянием, третий выбор, который необходимо сделать, заключается в том, будут ли данные храниться отдельно от операций (распаковка, unbundled), или же будут храниться вместе (bundled). Конечно, распакованный АТД всегда можно запаковать тривиальным способом, поместив данные и операции в одно целое. Но запакованный АТД практически не может быть распакован; семантика гарантирует, что он всегда остается запакованным. Конечно, всегда можно выполнить технический рефакторинг проекта, тут речь о формальном подходе к распаковке.

Распакованный АТД -- это АТД, для которого можно отделить данные от операций. Замечательный факт, что распакованный АТД может быть безопасным. Для этого каждый экземпляр создается вместе с "ключом". Ключ -- это разрешение на доступ к внутренним данным экземпляра (и обновление их, если экземпляр имеет состояние). Все операции АТД знают ключ, но остальная часть программы не имеет к ключу доступа. Обычно ключ - это имя (неизменяемая константа).

Распакованный АТД может быть более эффективным, чем запакованный. Например, в файле можно хранить наборы значений, каждое из которых будет соответствовать своему экземпляру АТД. Запакованный АТД подразумевает, что требуется хранить вместе и код и операции таким образом, что они не могут быть разделены программистом. Пример -- ООП, когда в памяти каждый объект хранится как набор данных и операций их обработки (методов). На практике, конечно, один и тот же код методов целиком в каждом объекте физически обычно не хранится, достаточно иметь лишь ссылку на код, и тем не менее сам подход создаёт ощутимые сложности. 



Практические способы организации АТД

На практике из восьми комбинаций способа организации АТД обычно используются следующие (по мере усложнения):

- Открытый, декларативный, распакованный. Этот подход реализован например в языках Scheme и Prolog.
- Защищённый, декларативный, распакованный. Добавляем "обёртки" для реализации безопасного декларативного стиля.
- Защищённый, декларативный, запакованный. Получаем объектно-ориентированное расширение декларативного стиля.
- Защищённый, stateful, запакованный. Классический ООП, как в Smalltalk или Java.
- Защищённый, stateful, распакованный. Распакованный вариант ООП.

Первые два пункта мы рассматривали на предыдущем курсе:
-- NewStack() – создать новый стек;
-- Push(Stack s, T elem) – втолкнуть элемент elem в стек s;
-- Pop(Stack s) – вытолкнуть элемент из стека s;
-- T Peek(Stack s) – получить верхний элемент стека s, не меняя сам стек;
-- IsEmpty(Stack s) – булева проверка, пустой ли стек s.

Первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов. 


Защищённая декларативная распакованная версия с обёртками

-- NewStack() возвращает Wrap( [ ] ).

-- Peek(Stack s) и IsEmpty(Stack s) делают предварительно внутри Unwrap(s).

-- Push(Stack s, T elem) и Pop(Stack s) после Unwrap(s) модифицируют результат и затем выполняют Wrap() для нового списка, который и возвращает. 


Защищённая декларативная запакованная версия

Идея -- спрятать стек внутри операций с помощью лексического замыкания, так что он не может быть от них отделён. Синтаксис становится похожим на ООП:

S1 = NewStack()
S1.IsEmpty()
S2 = S1.Push(23)
S3 = S2.Pop(X)
S4 = S3.Pop(Y).Push(256).Push(-1)

Мы придерживаемся декларативной модели, каждый "метод" по-прежнему возвращает новый стек, не меняя текущий. Так как эта версия запакована, обёртки Wrap/Unwrap вызывать не нужно: мы получаем в качестве результата не "физический" стек, а некий "объект", заглянуть внутрь которого невозможно. Для обеспечения безопасности такого АТД не требуется явного состояния, достаточно только программирование высшего порядка.

Поскольку эта версия является одновременно запакованной и безопасной, мы можем рассматривать ее как декларативную форму объектно-ориентированного программирования. По сути, мы получили декларативный объект. 


Защищённые stateful-версии

Защищённый, stateful, запакованный стек реализуется классическим подходом ООП + АТД. Есть объект, содержащий внутреннее поле (сам стек в некотором внутреннем представлении, например связный список), которое инкапсулировано, и есть методы доступа к нему и его модификации.

Защищённый, stateful, распакованный стек на практике применяется редко в ООП и ФП, хотя и незаслуженно. Он не требует программирования высшего порядка. Каждая операция требует один параметр (стек) и не создаёт новый объект, модифицируя аргумент. Только операция NewStack требует вызова Wrap, все остальные операции используют лишь Unwrap для доступа к внутреннему представлению стека.

S1 = NewStack()
IsEmpty(S1)
Push(S1, 23)
X = Pop(S1)



9. Передача параметров

Теперь, когда мы ввели явное состояние, вкратце посмотрим на способы передачи параметров. Вы наверняка знакомы с передачей по ссылке и передачей по значению, но было придумано множество других способов передачи информации в вызываемую процедуру и из нее. Это теоретическая и не самая важная тема, с которой всё же желательно ознакомиться.

Передача по ссылке Call by reference

Идентификатор некоторой языковой сущности передается процедуре. Процедура может свободно использовать эту языковую сущность в своём теле, обращаясь к ней по её идентификатору. Это примитивный механизм, используемый в различных вычислительных моделях на наших курсах, фактически для всех языковых сущностей, включая dataflow-переменные и ячейки.

Но императивные языки часто подразумевают под передачей по ссылке нечто иное. Они предполагают, что ссылка хранится в ячейке, локальной для процедуры -- то есть параметр функции сам по себе локальная переменная в этой функции. В формальной терминологии, это передача по значению, потому что сама ссылка рассматривается как значение. Поэтому рекомендую тщательно изучить, что именно в вашем языке программирования понимается под передачей по ссылке. 

 Передача через переменную Call by variable
Это особая версия передачи по ссылке. Идентификатор ячейки передаётся в процедуру, и фактически становится синонимом её имени-параметра внутри процедуры. Отличие от передачи по ссылке в том, что в данном случае в качестве параметра используется не оригинальный идентификатор, а его алиас, однако он -- не локальная переменная внутри функции (в которую копируется ссылка), а скорее синтаксический сахар.

Передача по значению Call by value
Значение передаётся в процедуру и помещается в ячейку-параметр, локальную в данной процедуре. Реализация может копировать значение целиком или передавать только ссылку, неважно: формально процедура не может изменять никакие внешние значения в вызывающей среде, за своими пределами, пусть даже они и передаются по ссылке. 

 Передача по значению-результату Call by value-result

Это версия передачи через переменную, используемая для возврата значения через параметр. Когда процедура вызывается, содержимое ячейки (мутабельная переменная) помещается в другую мутабельную переменную, которая локальна внутри процедуры, над ней выполняются различные внутренние вычисления. Когда процедура завершается, итоговое значение локальной переменной помещается обратно в оригинальную ячейку.

Передача по имени Call by name

Это наиболее общий случай. Для каждого аргумента создается отдельное процедурное значение -- так называемый переходник или преобразователь thunk. Он вычисляется каждый раз, когда запрашивается аргумент, и фактически возвращает ("вычисляет") имя ячейки -- адрес мутабельной переменной. thunk -- это по сути функция, и например в случае, когда аргументы -- это индексы автоматически выполняющегося цикла, возможны неоднозначные ситуации, связанные с их многократным перевычислением. 

 Передача по необходимости Call by need

Это модификация передачи по имени, когда процедурное значение вычисляется только один раз. Аргумент вычисляется, когда запрошен результат, и затем сохраняется в замыкании (в локальной переменной). В последующие обращения к процедуре в качестве аргумента используется уже вычисленное значение из этой локальной переменной. Передача по необходимости фактически работает как ленивое оценивание.

На практике программистам конечно вполне удаётся успешно обходиться без учёта нюансов разных видов передач. Например, передача параметра по ссылке -- это примитивный механизм, который лежит в основе других подходов. Он не зависит от дополнительных понятий -- ячейки или процедурного значения, имеет простую формальную семантику и эффективен в реализации. С другой стороны, передача по ссылке далеко не всегда будет правильным выбором, в различных языках например активно поддерживаются схема Call by value-result и иные формы лингвистических абстракций.

Тестов к этому теоретическому отступлению про параметры не будет. 



Stateful-коллекции

Коллекция -- важная разновидность АТД, которая группирует вместе набор значений в одну составную сущность (контейнер). Одна из двух ключевых характеристик коллекций -- это поддержка индексации (быстрый доступ к элементам). Другая ключевая характеристика -- хранение фиксированного или переменного количества значений.

10. Индексированные коллекции

В декларативной модели мы познакомились с двумя видами индексированных коллекций: кортежи и записи. Их stateful-версии, соответственно -- массивы и словари.

Массив -- это раскладка целых чисел в однозначно соответствующие им конкретные значения. Область определения (домен) массива -- это набор последовательных целых чисел от нижней границы массива до верхней. Область массива задаётся при объявлении массива и не может быть изменена после этого. Чаще всего область определения массива начинается с нуля (C++, C#, Java, Python...), реже с единицы (Julia, Pascal), иногда допускаются и отрицательные значения.
Доступ к элементу массива и его изменение выполняются за константное время O(1).

Если вы не хотите привязываться к конкретной области определения массива, используйте словари. 

 Словари

Словарь -- это раскладка простых констант (атомов, имён, целых чисел) в однозначно соответствующие им конкретные значения. Область определения словаря может свободно меняться в процессе его эксплуатации. Конкретный элемент словаря (item) представляет собой пару из одной простой константы (ключ) и связанно с ней значения. Все элементы могут считываться, добавляться, изменяться (изменить ключ в существующем элементе нельзя), удаляться в процессе работы. Доступ к значению по ключу и изменение значения по ключу выполняются за константное время O(1) (чаще всего используются хэш-таблицы), добавление/удаление -- за амортизованное константное время (теоретически может периодически выполняться внутренняя реорганизация словаря).

Между словарями и записями есть тесная связь: оба этих типа выполняют раскладку простых констант в значения. Основное различие в том, что записи -- stateless, а словари -- stateful. В записях допустим фиксированный неизменяемый набор полей/ключей и значений, а в словарях они могут произвольно меняться.

 Продуктивность индексированных коллекций

В плане продуктивности есть заметные отличия между четырьмя типами индексированных коллекций: кортежи, записи, массивы и словари. Все они обеспечивают доступ к своим элементам по индексу за константное время, однако в остальном заметно отличаются.

Кортежи -- наиболее ограничены, но работают быстро и требуют мало памяти. Их содержимое не может изменяться, значения хранятся последовательно и хорошо запакованно, поэтому доступ по индексу (который всегда лежит в диапазоне от 1 до N) очень прост.

Записи -- существенно гибче, нежели кортежи, потому что в качестве индексов могут использоваться любые литералы (атомы или имена) и числа. При этом числа не должны принадлежать какому-то конкретному диапазону. Значения так же хранятся последовательно, и при создании записи создаётся хэш-таблица, которая преобразует имя поля записи в его сдвиг в последовательности значений.

Массивы -- допускают большую гибкость и изменение своего содержимого. Эффективность остаётся высокой, потому что значения хранятся последовательно, индексный диапазон известен заранее и не изменяем, и позиция конкретного элемента в памяти вычисляется быстро.

Словари -- наиболее общий случай, комбинирующий возможности массивов и записей. Словари создаются пустыми, никакого явного диапазона индексов (любые литералы и числа) не задаётся, и в целом это наименее эффективная структура данных по времени доступа и обновления. Словари нередко реализуются как динамические хэш-таблицы. 



11. Неиндексируемые коллекции

Наиболее известны два вида неиндексируемых коллекций: списки и потоки (стримы, streams). Это декларативные типы данных, подразумевающие хранение линейной последовательности. Они могут быть последовательно перебраны от начала до конца, и таких переборов одновременно над одним списком или стримом может выполняться любое количество (однако не всегда они допускают повторный перебор с нуля; например, сетевой поток ввода/вывода, очевидно, такое не позволяет).

Списки имеют конечную фиксированную длину.

Потоки -- это незавершённые списки; их хвосты могут содержать несвязанную переменную, что потенциально позволяет их всегда расширять как списки. Поток -- одна из наиболее эффективных расширяемых коллекций, как по использованию памяти, так и по времени работы.

Расширяемые коллекции

Потоки -- эффективно расширяемые коллекции, однако доступ к их произвольному элементу имеет сложность O(N), если такая возможность вообще существует. Другой вид расширяемых коллекций -- словари, где уже само расширение требует неконстантного времени. Существует также третий вид расширяемых коллекций -- расширяемые (динамические) массивы, которые мы проходили на первом курсе по алгоритмама/структурам данных. Они по определённой схеме расширяются, когда полностью (или почти полностью) заполнены. В результате амортизационное время расширения оказывается весьма хорошим, значительно лучше словарей, а доступ по индексу обеспечивается за константное время. 



12. Мышление в парадигме состояний

Программы, в которых состояние используется бессистемно, очень трудно понять. Например, если состояние проходит по всей программе и везде в ней видимо/доступно, то оно может быть модифицировано в любом месте кода. Единственный способ рассуждать о такой программе -- это пытаться рассматривать всю программу целиком. Но если это возможно для небольших скриптов, то, очевидно, совершенно нереально уже для немного больших программ. Мы вкратце рассмотрим метод, называемый "инвариантные утверждения" (invariant assertions), который позволяет приручить состояние и взять stateful-сложность под линейный контроль. Этот метод может применяться для программ, которые имеют как императивную (использующую состояния), так и декларативную части.

Декларативная часть проявляется в виде логических выражений внутри assert-проверок, которые будем называть утверждения. Абстракции в этом контексте формируются через выведение новых правил доказательства для лингвистических абстракций.

Техника инвариантных утверждений известна в computer science как аксиоматическая семантика (применение исчисления предикатов к теории доказательств), когда семантика каждой конструкции языка определяется как некий набор правил или аксиом. Она была разработана великими математиками, логиками и кибернетиками -- Флойдом, Хоаром и Дейкстрой, в период 1960-1970-е годы. Правила корректности были названы аксиомами, и с тех пор прижилась подобная терминология.

Эта техника не применялась массово потому, что достаточно сложна, и лишь в последнее десятилетие, с мощным развитием темы формальной верификации и появлением прикладных пруф-ассистантов, становится постепенно всё более распространённой. 


Инвариантные утверждения

Метод инвариантных утверждений позволяет рассуждать о частях программы независимо от её других частей. Это даёт нам при работе с состояниями одно из самых сильных свойств декларативного программирования: понимание всей системы складывается из линейной суммы понимания её подсистем. Однако это свойство достигается ценой строгой формальной организации программы.

Базовая идея -- организовываем систему как иерархию АТД. Каждый АТД может использовать другие АТД для своей реализации. Этот подход более глубокий концептуально, нежели знакомая вам схема наследования из классического ООП.

Каждый АТД специфицируется набором инвариантных утверждений, или просто инвариантов.

Инвариант -- это логическое выражение, которое опеределяет связь между аргументами АТД и его внутренним состоянием. Каждая операция АТД предварительно предполагает, что некоторый инвариант истинен, и когда она завершается, гарантирует истинность другого инварианта (гарантируется это на уровне реализации операции). Таким образом, использование инвариантов отделяет реализацию АТД от его использования. Мы можем рассуждать о каждом таком аспекте программы отдельно. 


Понятие утверждения

Для реализации вышеупомянутого подхода вводится понятие утверждения (assertion).

Утверждение -- это логическое выражение, которое добавляется между двумя исполняемыми инструкциями кода. Утверждение само по себе может трактоваться как логическое выражение, вычисляющее булево значение, хотя тут имеются определённые отличия такого выражения от логических выражений в используемой вычислительной модели. Утверждения могут содержать переменные и идентификаторы ячеек, которые встречаются в коде, но также могут содержать переменные и кванторы, которые не встречаются в языке программирования, а используются только для выражения конкретного отношения. Кванторы обычно рассматриваются как отдельные символы.

Два классических квантора -- это квантор всеобщности ∀ (для всех...) и квантор существования ∃ (существует хотя бы один...). 


Понятие утверждения частичной корректности

Каждая i-я операция Oi в АТД специфицируется двумя утверждениями Ai и Bi. Спецификация утверждает, что если Ai истинно перед выполнением Oi, то когда Oi завершится, Bi будет истинным.

Это записывается так:

{ Ai } Oi { Bi }

и называется утверждение частичной корректности. Частичной потому, что утверждение будет корректным при условии, что Oi завершится "нормально" (не учитываем исключительные ситуации и прочие ненормальные ситуации).

Ai называется предусловие, и Bi называется постусловие.

Полная спецификация АТД состоит из утверждений частичной корректности для всех его операций.
Доказательство корректности АТД

Мы можем достаточно формально описать АТД, но как быть с доказательством корректности его реализации? Для этого надо доказать, что корректно в плане реализации каждое утверждение частичной корректности.

Существует немало формальных техник доказательства корректности непосредственно исходного кода, однако все они пока слишком трудоёмки для прикладного применения. С некоторыми из них мы познакомимся на отдельном мини-курсе -- быстром старте в пруф-чекеры (Coq, Agda...).

Тут мы немного коснулись обширной теоретической темы доказательства корректности программ. Одну из возможных прикладных её реализаций -- проектирование классов на основе пред- и постусловий -- мы подробно разбирали на первом курсе по ООАП.

Хороший прикладной материал по инвариантным утверждениям, обязательно изучите:
habr.com/ru/company/golovachcourses/blog/222679/ 



Нормальное завершение

Утверждения частичной корректности ничего не говорят о том, завершается ли программа нормально. Они просто фиксируют, что если программа завершается нормально, то такое-то и такое-то утверждение истинны. Но мы также должны доказать, что программа завершается в целом.

Есть три случая, когда программа может завершиться ненормально:
1) Вычисления заходят в бесконечный цикл. Это ошибка программиста, вызванная тем, что вычисления (трансформации) не продвигаются к своей цели.
2) Вычисления блокируются, потому что dataflow-переменная не связывается со значением. Это ошибка программиста, связанная с пропуском вычислений, или ситуация блокировки.
3) Вычисления завершаются ненормально вследствие возникновения исключительной ситуации.

Что делать в каждом случае?
1) Всегда, когда в вычислениях имеется цикл без явного ограничения (то есть цикл while или рекурсивный вызов), существует опасность, что он не завершится. Чтобы убедиться, что цикл завершается, достаточно доказать, что условие завершения -- это функция, которая неотрицательна и всегда убывает при последовательных итерациях. То есть убедитесь, что на каждой итерации цикла или при очередном вызове пространство будущего расчёта обязательно уменьшается.
2) Достаточно доказать, что все переменные становятся связанными со значениями до начала их использования. Для каждого использования переменной надо проследить назад все возможные пути обращения к ней, которые в самом начале должны всегда выходить на связывание со значением.
3) Частая причина исключительных ситуаций -- конфликты типов. Избегайте любых явных и неявных преобразований типов, включайте по максимуму режим проверки типов (type cheking) на уровне компилятора и среды выполнения. 


Programming in large

"Хорошее программное обеспечение хорошо и in large, и in small, и в своей высокоуровневой архитектуре, и в деталях низкого уровня"
Бертран Мейер

Под programming in large (программирование в большом) в программной инженерии (которую саму по себе тоже нередко называют programming in large) понимается прежде всего коллективная разработка, но к этому классическому определению имеется ряд важных уточнений и нюансов.

Programming in small -- это про то, как закодировать конкретную функцию или создать автономный класс с набором методов. Конечно, алгоритм, реализуемый функцией, может быть очень сложным, и методы класса могут реализовывать сложную логику, и сам код всегда должен быть выразительным, ясным и аккуратным. Но это остаётся уровень programming in small -- до тех пор, пока мы не попытаемся выполнить композицию нашей функции с другой функцией, или встроить наш класс в иерархию, в семейство активно взаимодействующих объектов. И вот тут сразу начинается programming in large. 

 Любое программирование -- это прежде всего про проектирование (и про декомпозицию).

Как нам строить системы всё большей и большей сложности, сохраняя итоговую сложность как линейную сумму сложностей отдельных подсистем? Большая система, понятно, будет создаваться коллективом разработчиков, однако в программной инженерии объёмы работ часто измеряются в человеко-годах, то есть срок в десять человеко-лет может подразумевать, что проект будет сделан одним разработчиком за 10 лет, или 10 разработчиками за один год. Хорошо известно также, что увеличение количества программистов даёт отнюдь не линейный рост продуктивности, а гораздо меньший, и это собственно и есть ключевая тема programming in large. Фактически нету разницы, делает ли проект один человек или десять человек: уже спустя пару месяцев собственный код обычно забывается и воспринимается как чужой.

Но, конечно, коллективная разработка включает в себя множество специфических аспектов, связанных с общением и координацией действий сотрудников. Управлять командой, чтобы она совместно эффективно работала, сложно вообще в любой области -- от инженерной до спортивной. В программировании ситуация особо усугубляется тем, что проекты весьма немилосердны даже к небольшим ошибкам. Программы требуют такой точности, которую человеку крайне трудно обеспечить.

На самом деле, внутри programming in large тоже существуют свои градации. Одно дело -- разработать систему на несколько десятков тысяч строк, другое дело -- на сотни тысяч строк, третье дело -- на миллионы, десятки и сотни миллионов строк... На каждом уровне обычно применяются свои методологии; мы рассмотрим базовую схему programming in large для небольших команд (до 7 человек). 



13. Методология проектирования in large

О правильной методологии проектирования programming in large написано очень много статей и книг -- к сожалению как правильных, так и весьма ложных. Большая часть нынешней литературы фактически представляет собой экстраполяцию ограниченных экспериментов, поскольку строгая проверка очень трудна. Чтобы проверить некоторую идею, необходимо, чтобы несколько практически одинаковых команд работали над схожими задачами в идентичных условиях. Это редко кому удавалось сделать, и такие попытки смотрятся весьма сомнительными.

В этом разделе обобщены уроки, которые команда Van Roy сотоварищи извлекла из собственного опыта создания крупных систем -- на основании своих же рекомендаций по применению парадигм программирования к разработке нескольких больших программных комплексов. Эти люди много думали в процессе работы о том, как же спроектировать хорошую программу, рефлексировали и наблюдали, как работают некоторые другие успешные команды разработчиков, и в итоге попытались выделить наиболее полезные принципы. 


Управление командой

Первая и самая важная задача заключается в том, чтобы убедиться, что команда работает действительно слаженно -- как Команда. Не будем вдаваться в специфику командной работы, это тема совсем не моей Школы, отмечу только ключевые моменты:

- Чёткое разграничение ответственности каждого разработчика. Границы должностных обязанностей не должны пересекаться, что позволит избежать бесконечных дискуссий о том, кто должен был устранить конкретную проблему, и вопросов "а почему я?".

- В отличие от ответственности, проектными знаниями следует обмениваться максимально свободно. Разработчики должны постоянно обмениваться информацией о различных подсистемах проекта. В идеале, в команде не должно быть ни одного незаменимого сотрудника. Все крупные изменения в системе должны обсуждаться коллективно, однако важно, чтобы непосредственно ответственный за модуль/компонент имел последнее слово, как он должен быть реализован. Младшие сотрудники должны проходить стажировку у более старших разработчиков, чтобы быстрее и полнее изучить систему. При этом сеньоры должны выдавать конкретные задания джуниорам так, чтобы те выполняли их настолько независимо, насколько это только возможно.

- Тщательное документирование всех интерфейсов всех компонентов, поскольку они также становятся интерфейсами между автором компонента и другими членами команды. Документация в programming in large особенно важна, гораздо более важна, чем при программировании в малом. 


Методология разработки

Существует множество способов организации разработки программного обеспечения. Стократно в статьях и книгах обсуждались методы разработки сверху вниз, снизу вверх и даже "посередине". Увы, мировая практика показывает, что ни одна из этих методик не является хотя бы удовлетворительной на практике, а попытки их механической интеграции только делают проекту хуже. Основная проблема заключается в том, что все они полагаются на то, что требования к системе и её спецификация (техническое задание, ТЗ) должны быть изначально уже достаточно полными, т.е. разработчики предвидят большинство функциональных и нефункциональных проектных требований. Однако если только система уже не была заранее очень хорошо изучена и формализована заказчиком, этого практически невозможно достичь.

Van Roy по своему опыту предлагает методологию, которая достаточно хорошо работает в ситуации нечётких требований -- так называемый подход "от тонкого к толстому" (thin-to-thick) -- своеобразная модификация agile-подходов, дополненная хорошей научной базой. 


thin-to-thick - 1

Начинаем с минимального количества проектных требований (подмножества потенциального множества всех требований), и создаём систему, полностью (это важно!) реализующую этот минимальный набор.

ТЗ, спецификация и архитектура системы -- пока "пустые оболочки". Они достаточно полны для того, чтобы можно было в перспективе построить работающую систему, но пока не решают почти никаких проблем пользователя, кроме самых базовых и элементарных.

Не надо путать данный шаг с созданием прототипа -- сразу создаётся именно полноценно работающая система, отвечающая всем первичным требованиям и готовая к дальнейшему развитию и расширению. 


thin-to-thick - 2

Постоянно и плавно расширяем и реализуем множество проектных требований, охватывая разные уровни логики и архитектуры. Тут можно сказать, что приложение "растёт" или "развивается". Иногда такой подход называют эволюционным.

Важно, что в любой момент времени всегда существует работающая система, которая удовлетворяет своей спецификации, и которая может быть оценена потенциальными пользователями.

В качестве конкретной методологии разработки (ведения и реализации проектных требований) можно применять какой-нибудь "спокойный" (не экстремальный) agile-подход вроде Канбана. 


thin-to-thick - 3

В процессе разработки не выполняется никакая оптимизация -- точнее, не делается то, что явно не задано в ТЗ. То есть не надо делать проект более сложным только для того, чтобы увеличить производительность.

Используйте простые алгоритмы с приемлемой сложностью, и поддерживайте простой проектный дизайн с правильными абстракциями. Не беспокойтесь о потенциальных накладных расходах этих абстракций.

Оптимизация может быть проведена в конце разработки, и только если возникнут реальные проблемы с производительностью. Части системы, которые потом потенциально потребуется переписать, обычно очень маленькие, и достаточно легко выявляются с помощью классических техник профилирования. 


thin-to-thick - 4

По ходу работ периодически реорганизуйте проектный дизайн, чтобы сохранить хорошую компоновку абстракций. Компоненты должны выразительно инкапсулировать проектные решения и реализовывать общие абстракции. Такая реорганизация иногда не совсем точно называется "рефакторинг".

Существуют две крайности: полностью планировать проектный дизайн заранее, и полностью полагаться на рефакторинг "в процессе". Лучший подход, как обычно, где-то посередине.
Мастерство такого баланса -- признак сеньорской квалификации. 



Плюсы методики "от тонкого к толстому"

- баги всех видов выявляются быстро и рано и легко устраняются;

- давление дедлайна значительно сокращается, так как всегда имеется действующее рабочее приложение;

- разработчики более мотивированы, поскольку получают быструю обратную связь по своим усилиям;

- пользователи с большей вероятностью получают то, что им действительно нужно, потому что у них есть возможность использовать продукт непосредственно в процессе его разработки;

- архитектура с большей вероятностью получится хорошей, так как её можно исправлять на ранних стадиях работ;

- пользовательский интерфейс с большей вероятностью будет хорошим, поскольку он постоянно улучшается в процессе разработки через обратную связь от пользователей работающей версии. 



14. Programming in large на практике

Но как же надо структурировать будущую большую систему, требования к которой пока слабо понятны? Какую абстракцию тут лучше выбрать, чтобы она хорошо поддерживала и продуктивную командную работу, и методику "от тонкого к толстому"? Один из способов, который проверенно работает на практике -- это структурировать проект как иерархический граф с чётко определенными интерфейсами на каждом уровне.

Проектируемая система состоит из набора узлов (подсистем), где каждый узел связан/взаимодействует с некоторыми другими узлами. Каждый узел -- это экземпляр компонента, но и на уровне системы типов проект организован таким же образом -- в виде иерархии компонентов (например, классов). Интерфейсы здесь -- например, формальнрые наборы операций АТД.

Принципиальный момент, что, как вы, вероятно, догадались, каждый узел в свою очередь декомпозируется в граф со своей внутренней структурой. Декомпозиция заканчивается, когда мы достигаем примитивных компонентов, предоставляемых базовым логическим уровнем.

В реальных проектах уровней декомпозиции немного, часто вполне достаточно двух-трёх уровней "вложенности". Декомпозицию в данном случае не надо путать с методикой проектирования "сверху вниз" (в чём различие, поясняется далее). Практическую методику - реализацию этого подхода с помощью ООП -- вы изучали на двух курсах по ООАП, когда создавали множество почти равноправных АТД. 


1) Связи между компонентами

Первый шаг в проектировании системы по имеющемуся множеству проектных требований -- это выбор схемы соединения компонентов. Тут возможны два варианта.

1. Статическая структура.

Граф компонентов хорошо понятен с самого начала разработки системы. В таком случае компоненты могут быть связаны друг с другом сразу же, когда приложение запускается.

Каждый экземпляр компонента примерно соответствует набору функциональных возможностей, который называют библиотека или модуль.

Важный момент: очень желательно, чтобы каждый экземпляр компонента существовал в системе не более чем в одном виде (паттерн Синглетон), поэтому не следует смешивать компонент и классический класс, подразумевающий порождение множества экземпляров. Тут речь идёт именно о библиотеках или модулях/пакетах. Как вариант, под компонентом можно понимать статический класс. Если библиотека требуется в нескольких разных подсистемах проекта, мы хотим, чтобы все они использовали одну и ту же физическую библиотеку (инстанс). 

 Статическая структура на практике может реализовываться компонентами как синтаксическими единицами компиляции, хранящимися в отдельных файлах. Такие компоненты называют функторы, которые могут компилироваться независимо от других функторов. Зависимости между функторами задаются через физические имена файлов. Чтобы быть доступным для других функторов, функтор должен быть "записан" в файл, что позволяет однозначно обращаться к нему по имени файла с помощью типовых инструкций любого языка программирования для подключения модулей.

Функтор представляется двумя форматами: файл с исходным текстом, и файл со скомпилированным кодом (например, байт-кодом виртуальной машины или нативным машинным кодом).

Приложение -- обычно один конкретный скомпилированный функтор. Для его запуска все остальные скомпилированные функторы, явно или косвенно связанные с главным, должны быть собраны вместе и "построены" в единое целое. При запуске главного функтора все связанные функторы автоматически линкуются с ним, и создаются их экземпляры. Такая связь может быть статической (на этапе компиляции) или динамической (функторы подгружаются во время работы программы). 



2. Динамическая структура

Часто приложение выполняет вычисления с компонентами, которые возникают и связываются друг с другом непосредственно во время выполнения. Или программа может создать новый компонент и сохранить его, и т. д. Экземпляры компонентов в данном варианте не обязательно должны быть общими (глобальными) синглетонами; возможно, потребуется несколько экземпляров одного компонента (модуля или типа данных). Например, компонент может реализовать интерфейс к базе данных (что часто требуется в задачах репликации). В зависимости от того, используется ли одна или несколько внешних баз данных, необходимо будет создать один или несколько экземпляров компонента. Это определяется во время выполнения, когда добавляется новая база данных (узел репликации) в горячем режиме.

Функтор в данном случае -- просто ещё одна языковая сущность. Это может быть, например, класс или процедура, возможно, с более строгим описанием их интерфейса. 


2) Взаимодействие между компонентами

Когда компоненты соединены вместе, они должны начать взаимодействовать друг с другом. Далее приведены шесть наиболее популярных протоколов для такого взаимодействия, в порядке возрастания независимости компонентов.

1. Процедура/функция.

Логика программы последовательна, и один компонент вызывает другой как функцию. Вызывающая сторона может быть не единственным инициатором такого вызова; допустимы вложенные вызовы, когда фокус управления переходит от одного компонента к другому. Но всегда существует только один глобальный фокус управления, который в каждый момент времени напрямую связывает два конкретных компонента.

2. Корутина.

Два компонента выполняются независимо, но последовательно передавая управление друг другу. Выполнилась часть кода одного компонента, затем управление передаётся другому компоненту, который выполняет часть своего кода, и передаёт управление обратно первому компоненту, который продолжает работу с последней промежуточной точки (с сохранением своих локальных состояний), и т. д.
Тут возникает уже несколько фокусов контроля, по одному на каждую корутину. Этот протокол более свободный, нежели предыдущий, но компоненты всё ещё зависимы, поскольку выполняются попеременно и связаны с друг с другом.

 3. Параллельность и синхронизм.

Третья схема -- когда каждый компонент развивается независимо от других, и может инициировать и завершать связь с другим компонентом в соответствии с некоторым протоколом, который согласован для обоих компонентов. Компоненты работают параллельно. Тут существует несколько фокусов контроля, которые называются "нити" (threads), мы их проходили на первом курсе по парадигмам. Каждый компонент однако обращается к другим компонентам синхронно: компонент, отправивший кому-то запрос, ожидает ответа, больше ничего не делая до получения ответа (или разрыва связи по ошибке -- таймауту например).

4. Параллельность и асинхронизм.

Множество параллельно работающих компонентов, которые взаимодействуют через асинхронные каналы. Каждый компонент может посылать сообщения другим, однако не обязан пассивно ожидать ответа, и может продолжать свою работу. Асинхронные каналы могут работать по разным схемам (например, обрабатывая сообщения в порядке их поступления, или случайно), и такие каналы называются потоки (streams).
В этой схеме компонент должен знать некоторый идентификатор компонента, с которым он обменивается сообщениями. 

 5. Параллельный почтовый ящик.

Это разновидность предыдущей схемы, когда асинхронные каналы работают как "почтовые ящики", накапливая поступающие сообщения, каждое из которых адресуется конкретному компоненту. В таком случае появляется возможность выполнять сопоставление с образцом, выделяя нужное подмножество сообщений в канале, и не затрагивая другие сообщения, что очень удобно в параллельных системах. Такая схема реализована, например, в языке Erlang.

6. Согласованная модель.

Это схема, когда отправитель и получатель сообщений не должны знать идентификационную информацию друг друга. Такая абстракция называется пространство кортежей (tuple space) -- парадигма ассоциативной памяти для параллельных/распределённых вычислений, применяемая к интерфейсам компонентов. Компоненты работают параллельно, и взаимодействуют исключительно через общее пространство кортежей.
Один компонент может асинхронно отправить сообщение, а другой -- "получить" его в том смысле, что его надо явно найти по шаблону, как в почтовом ящике. 


Принцип независимости модели

Каждый компонент в системе может разрабатываться в какой-то своей оригинальной вычислительной модели. В процессе разработки внутренняя структура компонента может кардинально изменяться: нередко меняется вычислительная модель, stateless-компонент может стать компонентом с состоянием (или параллельным, или распределённым, и т.д.), или наоборот.

Если такое изменение происходит на уровне реализации компонента, нет необходимости изменять его интерфейс. Интерфейс требуется менять только в том случае, если меняется функциональность компонента, видимая извне. Это важное свойство модульности вычислительных моделей. До тех пор, пока интерфейс остается неизменным, это свойство гарантирует, что нет необходимости изменять что-либо ещё в остальной части системы.

Это базовый принцип проектирования для всех вычислительных моделей:

Интерфейс компонента должен быть независим от вычислительной модели, используемой для реализации компонента. Интерфейс зависит исключительно от внешне видимой функциональности компонента.

Хороший пример этого принципа -- мемоизация. Функция вычисляет некоторый результат, который требует существенного объёма вычислений, и кэширует свои параметры так, что если вызов функции с конкретными значениями уже выполнялся, то сразу выдаётся уже готовый результат, вычисленный ранее. Но несмотря на то, что кэш мемоизации, очевидно, требует работы с состояниями (мы переходим от декларативной модели к stateful-модели), смена внутренней реализации компонента не требует абсолютно никаких изменений в остальном коде системы. 



15. Сопровождение

Когда система создана и хорошо работает, мы должны убедиться, что она будет долго продолжать работать хорошо. Процесс поддержания качественной работоспособности системы после ее развёртывания называется сопровождением.

Как лучше всего структурировать системы, чтобы они были пригодны для продуктивного обслуживания?

Проектирование компонентов.

Существуют хорошие и плохие способы проектирования компонентов. Плохой способ, например, создать визуальную диаграмму, и декомпозировать её на кусочки, где каждый кусочек -- компонент. Гораздо лучше думать о компоненте как об абстракции.

Например, предположим, что мы пишем программу, которая использует списки. Тогда почти всегда хорошей идеей будет собрать все операции со списками в компонент, который задаёт абстракцию списка. В такой конструкции списки можно реализовывать, отлаживать, изменять и расширять, не затрагивая остальную часть программы. Если потом мы будем делать прикладную программу для работы со списками, которые слишком велики и не умещаются в оперативной памяти, достаточно будет изменить лишь сам компонент-список, чтобы хранить данные в файлах, а не в оперативной памяти. 

 Инкапсуляция проектных решений.
В более общем смысле можно сказать, что компонент должен инкапсулировать некоторое проектное требование (фичу). Таким образом, при изменении соответствующего проектного требования изменится только этот компонент. Это очень мощная форма модульности.
Полезность компонента можно оценить, посмотрев, какие изменения он позволяет внести. Например, если программа выполняет обработку текста, то решение о том, какую кодировку символов использовать, надо выделить в отдельный компонент, что упростит переход от одного текстового формата к другому.

Избегайте изменения интерфейсов компонентов.
Изменение интерфейса компонента всегда проблематично, поскольку все компоненты, которые зависят от измененного интерфейса, должны быть переписаны или перекомпилированы. Поэтому изменения интерфейса всегда следует избегать, однако на практике это практически невозможно -- как минимум, на фазе проектирования компонента. Всё, что мы можем сделать -- это минимизировать частоту таких изменений. Точнее говоря, интерфейсы часто используемых компонентов должны быть разработаны как можно более тщательнее с самого начала. 



16. Принципы сопровождения

Минимизируйте количество внешних зависимостей.

Компонент, который зависит от другого компонента (требует его для своей работы) -- потенциальный источник проблем. Если изменить другой компонент, то придётся изменить и данный компонент. Это основной источник "гниения программного обеспечения", когда некогда работавшая система перестает работать из-за стремительного роста затрат ресурсов на модификацию и исправление ошибок.
Как с этим бороться продуктивно и технично, я рассказываю на курсе Ясное Легаси :)

Минимизируйте количество возможных уровней косвенной связи.

Это дополнение предыдущего принципа: когда компонент A связан с компонентом B, и обновление B требует обновления A. Любая косвенная связь -- это своего рода классический "указатель", источник огромного количества ошибок в языках наподобие Си и С++. Задача тут -- избежать ошибочного ("висячего") указателя, который "указывает" на то, что больше не имеет смысла для источника. Изменение B может привести к тому, что указатель A станет "висячим". Но B не знает о том, что на него есть указатель в A, и поэтому не может предотвратить такую ситуацию.

Предупредить подобное можно, не изменяя компонент B, а только создавая его модифицированные копии. Это может хорошо работать, если в исполнительной (runtime) системе есть автоматическая поддержка управления памятью. Классический пример данной проблемы -- URL-ы в интернете, которые часто устаревают и пропадают, а в самой Сети нету никаких соответствующих формальных протоколов, средств поддержки "качества обслуживания". 


 Зависимости в системе должны быть предсказуемыми.
Ещё один наглядный пример сложного и непредсказуемого поведения -- это пресловутое "кэширование страниц" веб-браузерами. Кэширование страниц -- это неправильное название, потому что настоящий кэш поддерживает когерентность между оригиналом и копией. Поведение всех подсистем в проекте, на которые завязаны другие подсистемы, должно быть чётко регламентировано.

Принимайте решения на правильном уровне абстракций.
Например, таймаут (отказ в обслуживании, в ответе на запрос, из-за долгого ожидания) -- это необратимое проектное решение, принимаемое на низком уровне системы (глубоко вложенный компонент), которое однако распространяется вплоть до самого верхнего уровня без какой-либо возможности для промежуточных компонентов вмешаться в этот процесс. Такое поведение может свести на нет всю работу, которую проделал проектировщик. 


 Детально документируйте всё.
Каждый раз, когда нарушается один из предыдущих принципов (возможно, по уважительной причине -- например, возникли физические ограничения наподобие нехватки памяти, или разделение по физическим серверам создало "висячий" указатель), это должно быть задокументировано! То есть все внешние зависимости, все уровни косвенных связей, все слабо предсказуемые зависимости и все "необратимые" решения наподобие таймаута должны документироваться, в идеале, в вики-подобной системе с тегированием.

Простая физическая иерархия вложенности.
Система не должна храниться физически разрозненно в файловой системе, она должна быть собрана в одном месте, насколько это только возможно. 


 Главное правило: проектный дизайн должен быть максимально простым для сопровождения.

Например, если ваш проект хранится в виде физических файлов (очевидно, частый случай), то:

1. Если возможно (например, проект небольшой), поместите весь код в один файл, внутри которого возможна своя структуризация по компонентам. Такую структуризацию обычно поддерживают редакторы кода в IDE с помощью специальных инструкций.

2. Если пункт 1 невозможен (например, файлы хранят код на разных языках, или над разными частями системы одновременно работают разные люди), все файлы располагаем в одном каталоге (без вложенных подкаталогов).

3. Если предыдущие пункты невозможны (например, проект по-разному собирается под разные платформы), помещаем файлы проекта в иерархию каталогов с единым корневым каталогом.

Кроме того, на курсе по ООАП рассматривается схема структуризации через синтаксические единицы и виртуальные каталоги. 




17. Стратегическое развитие: компоненты и будущее программирования

Расширенное использование компонентов постепенно меняет профессию программиста по двум основным путям.

Во-первых, компоненты делают программирование доступным для пользователей приложений, а не только для профессиональных разработчиков. Это так называемая парадигма lowcode/nocode.

Имея набор готовых компонентов c высоким уровнем абстракции и интуитивно понятный графический интерфейс, можно самостоятельно реализовывать множество простых задач программирования, не прибегая к написанию кода. Этот подход уже давно существует в ряде ниш: статистические пакеты и пакеты обработки сигналов, пакеты для управления научными экспериментами и конструкторы игр, и т. д.

Во-вторых, изменится и профессиональное программирование. По мере того, как разрабатывается и становится свободно доступными всё больше больше полезных компонентов, "укрупнённость" программирования будет расти. То есть базовыми элементами, используемыми программистами, чаще будут крупные компоненты и абстрактные сущности, а не "мелкие" низкоуровневые языковые операции. Например, в последнее десятилетие огромное распространение получил сервис github.com, где можно найти огромное количество более-менее законченных программ, библиотек, компонентов по самым разным темам.

Однако уже много лет основным узким местом, ограничивающим такую эволюцию, остаётся спецификация поведения компонентов. Доступные компоненты часто чрезмерно сложны и отличаются нечёткими спецификациями, что ограничивает возможности их использования. Решение заключается в упрощении компонентов, лучшей формализации их функциональных возможностей и способов их соединения через выработку соответствующих стандартов. 



Композиционное проектирование

Иерархическая композиция компонентов выглядит естественным способом структурирования системы. Но на самом деле, он вовсе не "естественный", а просто наивный! Природа использует совершенно другой подход, который правильнее назвать не-композиционным. Давайте сравним их графы.

Компонентный граф (не путать с компонентной связностью) -- это граф, в котором каждый компонент (в смысле компонента с данного курса) -- это узел, и между компонентами имеются ребро, если они знают друг о друге (как-то связаны или зависимы). В композиционной системе граф будет иерархическим. Каждый компонент связан только со своими соседями, дочерними компонентами и родителями. В результате подобная система может быть разложена на независимые части многими способами так, что интерфейсы между частями будут небольшими.

В не-композиционной системе граф не имеет такой структуры -- он кустистый (каждый компонент может быть связан со многими другими компонентами) и нелокальный (каждый компонент может быть связан с совершенно разными частями графа, а не только с соседями по вертикали и горизонтали). Декомпозиция такой системы на части будет более свободной, и интерфейсы между подсистемами, как правило, получаются большие, что усложняет понимание отдельных компонентов, если не учитывать их связи с остальной частью системы. Не-композиционный граф, например, может характеризоваться тем, что диаметр его мал: каждый компонент находится в пределах единичных рёбер от любого другого компонента.

Иерархическая композиция популярная потому, что хорошо подходит для проектирования систем человеком, основным ограничением которого считается ограниченный объём его кратковременной памяти. Проектировщик может держать в своей "оперативной" памяти для обработки лишь небольшое количество сущностей одновременно. Поэтому большой проект удобно разбивать на части, каждая из которых достаточно мала, чтобы её можно было удержать в голове одного разработчика. Эта незадача и заставляет человека без внешней помощи строить композиционные системы. 

 С другой стороны, в реальном мире "системы" не имеют таких выдумываемых человеком ограничений и работают по принципу естественного отбора. Новые системы создаются путем комбинирования и модификации существующих систем. Каждая система оценивается как единое целое прежде всего по тому, насколько хорошо она работает в естественной среде. Самые успешные системы -- это те, у которых больше всего потомков. Поэтому природные системы имеют тенденцию к не-композиционности.

Каждый подход в чистом виде -- своего рода крайность. "Человеческое" проектирование ориентировано на достижение цели и считается редукционистским. "Природное" проектирование -- исследовательское и целостное. И хотя сегодня, с развитием машинного обучения, можно представить создание инструментов, позволяющих человеку использовать более "естественный" с точки зрения природы, эволюционный подход к проектированию систем, пока практически весь ИТ-мир сосредоточен на композиционном подходе. 



18. Пример выбора между stateful-моделью с состояниями и декларативной stateless-моделью

Рассмотрим пример создания генератора случайных чисел. Этой теме посвящено огромное количество работ, в частности, глубокое погружение в тему имеется в "Искусстве программирования" Кнута.

На практике применяются три основных подхода к созданию таких генераторов.

1. Использование неких непредсказуемых событий на уровне ОС -- например, связанных с параллелизмом. Увы, такая непредсказуемость не подчиняется простым законам. Например, использование планировщика потоков в качестве источника случайности даёт некоторые случайные "колебания", однако они не характеризуются качественным распределением вероятности. Более того, они тесно связаны с вычислениями столь неочевидными способами, что даже если бы их распределение было подходящим, оно всё равно зависело бы от вычислений. Таким образом, это не лучший источник случайных чисел.

2. Использование готового источника истинной случайности. Например, электронные схемы генерируют шум, который представляет собой практически непредсказуемый сигнал, приблизительное распределение вероятности которого известно. Фактически, для всех практических целей он действительно случаен. Но есть две проблемы.

Во-первых, само по себе распределение вероятности точно не известно: оно может слегка меняться от одной схемы к другой, или в зависимости от температуры окружающей среды. Да, есть способы "нормализовать" случайные числа так, чтобы их распределение стало известным. Но существует вторая, более серьезная проблема: случайность нельзя воспроизвести иначе, нежели просто сохранив серию случайных чисел от источника, и воспроизведя их в коде.

Но требование повторной воспроизводимости некоторой случайной последовательности в программировании возникает постоянно -- например, при отладке некоторого симулятора или игры. Мы хотели бы варьировать некоторый параметр генератора так, чтобы каждый раз получать разные, но повторяемые для конкретного значения параметра последовательности. По этой причине в обычных компьютерах обычно не используются действительно случайные генераторы. 

 Может показаться, что мы старательно загоняем сами себя в угол. Мы хотим истинной случайности, и при этом хотим, чтобы она была воспроизводимой.

3. Решение простое: мы вычисляем случайные числа по некоторому алгоритму. Каким образом можно генерировать действительно случайные числа? Простой ответ -- никак. Но числа могут "казаться" случайными для подавляющего большинства практических задач. Они называются псевдослучайными числами. Что это значит? Это не так просто определить. Грубо говоря, программно сгенерированные числа должны давать такое же поведение, как и истинно случайные числа.

Однако алгоритмы генерации псевдослучайных чисел почти всегда имеют существенные недостатки. Мы не можем гарантировать, что случайные числа будут достаточно хорошими, но мы можем попытаться получить то, что возможно. Например, сгенерированные случайные числа должны удовлетворять определённым качественным статистическим характеристикам, иметь подходящее распределение, а их период должен быть достаточно длинным. Поскольку генератор случайных чисел производит вычисления с конечным объемом информации, в конечном итоге последовательность будет повторяться. Очевидно, что при этом период повторения должен быть очень длинным. 


Генератор равномерно распределённых случайных чисел

Генератор случайных чисел хранит внутреннее состояние, с помощью которого он вычисляет следующее случайное число и следующее внутреннее состояние. Состояние должно быть достаточно большим, чтобы обеспечить длительный период повторения. Генератор инициализируется значением, называемым "зёрнышко" (seed). Повторная инициализация с тем же самым зёрнышком должна дать ту же самую последовательность случайных чисел. Если нам не нужна одна и та же последовательность, мы можем инициализировать генератор информацией, которая никогда не будет одинаковой -- например, текущей датой/времем в секундах (или их долях), начиная с некоторой точки отсчёта. Во всех современных ОС есть операция для получения такой информацию о времени.

Определим абстрактный тип данных для генератора псевдослучайных чисел.

Конструктор с параметром Max создаёт экземпляр генератора с внутренним состоянием. Max задаёт максимальное значение случайных чисел, если явных требований к верхней границе нету, лучше выбирать его побольше.

Метод Init с параметром Seed инициализирует генератор заданным зёрнышком, которое располагается в диапазоне 0,1,...,Max. Отсюда понятно, что Max желательно выбирать достаточно большим, чтобы избегать повторяющихся последовательностей. Init может быть вызван в любой момент.

Метод Rand возвращает случайное число и обновляет внутреннее состояние. Число генерируется в диапазоне 0,1,...,Max-1. Все числа в этом диапазоне имеют равную вероятность генерации. 

 Как вычислить очередное случайное число? Например, популярный и простой -- так называемый линейный конгруэнтный метод, где

X(i) = (a * X(i-1) + c) % m.

Возможный набор констант: m = 10 (все числа получаются в диапазоне 0..9), X(0) = a = c = 7, последовательность формируется такая: 7,6,9,0,7,6,9,0,...

Период в такой последовательности не превышает m.

Внутреннее состояние -- это X(i).

Более реалистичные значения: a = 333667, c = 213453321, m = 1000000000.

В виде АТД данный алгоритм в stateful-модели реализуется просто и прозрачно. Однако если вы попытаетесь реализовать данный алгоритм в виде обычной функции, то сразу возникнет вопрос, где хранить её промежуточное состояние? В языках типа Си это решалось добавлением глобальной переменной внутри модуля стандартной библиотеки, где располагалась соответствующая функция, но этот подход нарушает сразу несколько принципов хорошего стиля разработки. Поэтому в современных языках в качестве генераторов случайных значений используется не функция, а объект (например, в C# это класс Random).

Однако линейный конгруэнтный алгоритм может быть реализован и без состояния, в декларативной модели -- как ленивая функция или итератор. Например, в Python такой генератор без внутреннего состояния легко программируется с помощью yield. 


 Общие выводы

И модель с состояниями, и декларативная модель в целом смотрятся одинаково разумными для прикладного использования.

Качественное проектирование АТД или выбор готовой структуры данных в реализации некоторого компонента существенно важнее, нежели выбор вычислительной модели (stateful, stateless, ...).

Декларативные программы обычно менее читабельны, нежели программы с состояниями, потому что они должны быть написаны, как правило, в конвейерном виде (данные передаются между функциями).

Программы с состояниями обычно получаются более монолитными, нежели декларативные, потому что явное состояние может модифицироваться достаточно свободно. Для борьбы с излишней монолитностью применяются например соответствующие подходы ОО-проектирования.

Существенно легче распараллеливать декларативный код, потому что между его частями существенно меньше зависимостей, нежели в случае stateful-модели. 



19. Управление ресурсами

Сборка мусора -- классическая техника автоматического управления памятью и освобождения её от неиспользуемых сущностей. Однако она может плохо работать, если эти сущности не входят в используемую вычислительную модель -- например, они просто взаимодействуют с нашей системой из внешнего мира, и при этом могут "ломаться" (например, становиться недоступными, отключаться по таймауту и т. д.).

Тут возможны два подхода:

1. Внутри вычислительной модели хранится ссылка на внешнюю сущность -- назовём её указатель на ресурс. Например, это:
- дескриптор файла ОС, через который мы закрываем файл, обработка которого завершена;
- сущность, связывающая приложение с СУБД, через которую мы закрываем соединение с базой данных;
- указатель на блок памяти, выделенный ОС -- когда работа с ним завершена, мы явно освобождаем память.

2. Внутри вычислительной модели хранится ссылка, полученная из внешнего мира -- она называется ярлык (ticket). Ярлыки применяются в распределённом программировании для связывания процессов вместе. В общем случае в этом подходе нету безопасного способа для освобождения памяти или другого ресурса по окончании его использования. Один из приёмов -- механизм временной аренды (time-lease mechanism) внутри применяемого языка программирования, который предполагает доступ к таким внешним сущностям на ограниченный период времени, после чего этот доступ надо обновлять (получать новый ярлык). В таком случае приложение сразу проектируется с учётом того, что время "аренды" внешнего ресурса может истечь.

Первый подход в языках программирования нередко поддерживается так называемой финализацией -- возможностью выполнить определённые инструкции, когда соответствующая сущность перестала быть доступной (например, файл был закрыт). Обычно это явно реализуется в коде дополнительной инструкцией (например, finalize), закрывающей блок, который начинается командой открытия файла. За finalize соответственно следует код, который обязательно вызовется, когда обработка файла полностью завершится.

С помощью однократного вызова финализации, например, можно реализовать ленивую обработку файла. Имеется компонент с внутренним состоянием (например, функция с замыканием), который представляет собой своеобразный итератор по содержимому файла. Он хранит внутри дескриптор файла, и при очередном обращении к такому итератору файл открывается, если ещё не был открыт, из него считывается очередной блок данных (текущая позиция в файле также сохраняется во внутреннем состоянии), и так продолжается, пока файл не будет считан полностью. А когда он закончится, однократно вызывается финализация, которая закрывает файл и выдаёт нужное сообщение о завершении работы. 



20. Некоторые важные моменты

Оператор break

Это известный во многих массовых императивных языках оператор немедленно прерывает некоторый блок кода (на концепции блока кода основаны Java, C#, C++...), передавая управление внешнему блоку. Проблема в контексте современных трендов движения в параллелизм в том, что break может выполняться внутри некоторой "нити", которая работает одновременно с другими. Например, break вызывается из тела цикла, которое в модели одновременного выполнения потенциально может выполняться "параллельно" с другими итерациями (пример на Julia мы разбирали в первом курсе "как понять в программировании всё"). В таком случае непонятно, что делать, если работа цикла в одной из нитей прерывается, однако другие итерации, другие "тела" цикла в других нитях ещё продолжают работу. Надо ли прерывать их работу?

Правильный ответ: нет, прерывать работу других нитей в таком случае нельзя, однако в целом такое неоднозначное выполнение цикла желательно завершать исключительной ситуацией. 

 Декларативные объекты и идентичность

Мы рассматривали, как строить декларативный объект, который объединяет состояние и операции безопасным способом. Однако упущен такой аспект декларативных объектов, как их идентичность. Так как декларативные объекты иммутабельны -- после выполнения операции модификации каждый раз создаётся новый экземпляр, часто требуется понимать, что этот новый экземпляр -- фактически "тот же самый" по смыслу объект, который был и до этой операции. В императивном программировании с состояниями это реализуется прозрачно -- хранением ссылки на однократно созданный объект в переменной на протяжении всей программы. В случае декларативного подхода оказывается полезным добавлять в декларативные АТД операции, которые выдают некоторый уникальный идентификатор (число или строку) этого объекта. 

 Эмуляция состояния в декларативной модели

Некоторые мутабельные структуры данных можно эмулировать в декларативной модели. Имеется обновляемый контейнер (например, список/массив ячеек, значения которых можно как считывать, так и менять). Считывание значения i-й ячейки декларативно реализуется прозрачно с помощью рекурсии. Обновление значения i-й ячейки декларативно реализуется также рекурсивно созданием новой копии списка, где вместо i-й ячейки создаётся и подставляется новая ячейка с новым значением. 


21. Ограничения программирования с состояниями

ООП как развитию stateful-парадигмы присущи также соответственно все эти ограничения.

Реальный мир параллелен

Основное ограничение stateful-модели заключается в том, что программы последовательны (императивны). В реальном мире сущности одновременно и имеют внутреннее состояние, и действуют параллельно. Последовательное программирование никак не моделирует параллельное исполнение. Иногда такое ограничение уместно, например, при написании систем, где все события скоординированы (переход из одного глобального состояния в другое происходит контролируемым образом). В других случаях, например, при взаимодействии с реальным миром (живыми пользователями), это ограничение становится серьёзным препятствием.

Чтобы его снять, модели надо поддерживать как состояние, так и параллелизм, что мы изучим на отдельном курсе. 


Заключительное

Учёные-когнитивисты из Центра интеграционных исследований в области обучения и запоминания при Вашингтонском университете рекомендуют для продуктивного обучения в заключение пройти все тесты ещё раз (уже без теории). 
