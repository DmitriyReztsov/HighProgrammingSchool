
Часть I. Введение
1. Декларативная вычислительная модель

Вычислительная модель -- это формальная система, которая точно определяет некоторый язык программирования, и задаёт, как инструкции на этом языке будут выполняться на абстрактной вычислительной машине.

Модель программирования -- это набор программистских техник и принципов проектирования для создания программ под конкретную вычислительную модель, а также для формального (или хотя бы достаточно логического) рассуждения о корректности программы и способах повышения её эффективности.

Данное определение вычислительной модели очень общее, далеко не все подобные модели будут полезны для программистов. Целесообразная вычислительная модель -- такая модель, которую можно использовать для решения многих проблем, которая предлагает простые и практически обоснованные техники, и которая может быть реализована эффективно.

Первая и простейшая целесообразная вычислительная модель такого рода -- это декларативное программирование.
Очень условно, мы считаем, что самое главное -- это вычисление функций без использования переменных, а не работа с конкретными структурами (типами) данных. Иногда этот подход не совсем правильно называют stateless-программированием (программирование без использования промежуточных состояний в виде переменных). Противоположный подход называется stateful-программирование (или общеизвестное императивное программирование, где все вычисления завязаны на состояния и значения переменных).

Декларативная модель -- это одна из наиболее фундаментальных вычислительных моделей. Она включает в себя ключевые идеи двух главных декларативных парадигм: функциональное программирование и логическое программирование. Вдобавок, она легко делается параллельной без потери своих лучших качеств. Более того, в декларативном программировании содержится большинство идей более выразительных вычислительных моделей, по крайней мере, в базовой форме. 


2. Синтаксис языка программирования

Синтаксис языка программирования определяет, что такое "законная" программа, которая может быть успешно скомпилирована.

Грамматика языка определяет, как правильно и допустимо строить "предложения" языка (обычно называемые инструкции или тоже предложения) из "слов" языка (обычно называемых токены).

Программа, которая получает на вход последовательность символов (обычный текстовый файл с кодом программы), и формирует из них последовательность токенов, называется лексический анализатор.

Программа, которая получает на вход последовательность токенов, и возвращает так называемое дерево разбора, отображающее структуру каждой инструкции, называется парсер. Подробнее эта тема разбирается на одном из моих дополнительных бесплатных курсов по алгоритмам.

Одна из наиболее распространённых нотаций для задания грамматик языков называется расширенная форма Бэкуса-Наура (EBNF).

Например, правило EBNF

‹digit› ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

задаёт одну цифру digit (любую из указанных девяти), а правило

‹int› ::= ‹digit› { ‹digit› } 

задаёт положительное целое int, которое состоит из одной цифры, за которой может следовать от нуля до любого количества цифр.

Грамматики подразделяются на зависящие (контекстно-зависимые) и не зависящие от контекста (контекстно-свободные). Например, во многих языках программирования требуется, чтобы тип переменной был явно объявлен до её первого использования, что подразумевает контекстную зависимость инструкций использования переменной от инструкций объявления переменной; однако на уровне синтаксиса нотация EBNF не умеет учитывать такую связь правил с контекстом. В то же время для описания синтаксиса языков применяются контекстно-свободные грамматики, подобные EBNF, потому что они проще и нагляднее, а на практике дополняются набором дополнительных условий.

Лингвистическая абстракция -- новая конструкция языка, расширяющая его синтаксис (например, новый оператор). Лингвистическая абстракция помогает не только повысить выразительность кода, но и улучшать корректность, безопасность и эффективность языка. Лингвистические абстракции активно применяются при создании новых языков.

Синтаксический сахар -- способ повышения читабельности кода и сокращения его размера через использование сокращённых нотаций (например, более компактная запись различных операторов). 


3. Семантика языка программирования

Семантика языка программирования объясняет, что программа делает во время своей работы (семантика задаёт смысл кода).

Обычно используются четыре подхода к языковым семантикам:

-- Операционная семантика показывает, как инструкция исполняется на абстрактной машине (самый распространённый подход);

-- Аксиоматическая семантика определяет семантику инструкции как связь между входным состоянием (ситуация до выполнения инструкции) и выходным состоянием (ситуация после выполнения инструкции). Эта связь задаётся в виде логического утверждения. Обычно выходное утверждение одной инструкции служит входным утверждением для следующей за ней инструкцией;

-- Денотационная семантика определяет инструкцию как функцию, отображающую эту инструкцию в некоторый математический объект (самый строгий подход);

-- Логическая семантика определяет инструкцию как модель логической теории. 



Часть II.
Внутреннее устройство декларативной модели
4. Хранилище однократных присваиваний
(single-assignment store)

Начнём изучение декларативной модели с её внутреннего устройства. В модели используется хранилище однократных присваиваний: множество переменных (уникальных идентификаторов), которые изначально не определены, и могут быть инициализированы некоторым значением, но только один раз (менять присвоенное значение нельзя).

Переменные (идентификаторы) в таком хранилище называются декларативные переменные. Например, имеется хранилище {x = 11, y = 22, z} -- две декларативные переменные x и y с вечно связанными с ними значениями, и ещё одна декларативная переменная z, пока ни с каким значением не связанная. Тогда операция x + y всегда будет означать то же, что и 11 + 22.

Хранилище, в котором все переменные связаны со значениями, называется хранилище значений.

Базовая операция над хранилищем -- это связывание декларативной переменной со значением.

Например:

x = 5

x -- это декларативная переменная (не переменная в классическом смысле переменной в коде программы, а идентификатор в хранилище однократных присваиваний), которая навсегда связывается со значением 5. Если такой идентификатор в хранилище уже существовал, и присвоенное ему значение отличается от нового, операция связывания сигнализирует об ошибке (как правило, генерацией исключительной ситуации).

Переменные в смысле обычных переменных в коде в декларативной модели называются идентификаторы переменных. Они существуют вне хранилища и некоторым образом связываются с парой "декларативная переменная в хранилище и её значение". Такая система внешних переменных, указывающих на сущности в хранилище, называется окружение. 


5. Dataflow-переменные

В декларативной модели операции создания переменной и связывания её со значением формально различаются. Если мы попробуем использовать переменную до того, как ей было присвоено значение, возникнет так называемая ошибка использования переменной (variable use error).

Во многих языках программирования создание и связывание выполняются за один шаг, поэтому подобных ошибок не возникает. В других языках возникает одна из четырёх ситуаций (от самой плохой к самой хорошей):

1) Исполнение продолжается, и ошибок не возникает. Такое возможно, например, в С++, когда переменная-указатель указывает на непроинициализированную область памяти. В таком случае из неё берётся текущее (случайное по сути) значение.

2) Исполнение продолжается, и ошибок не возникает - 2. Переменная получает значение по умолчанию (например, 0 или null). Такое возможно, например, в Java.

3) Исполнение завершается с ошибкой. Такое возможно, например, в языке Prolog.

4) Система ожидает, когда переменная официально получит значение, и исполнение продолжится.

Первый и второй случаи совсем плохи, потому что программист может получить совсем не тот результат, но извещения об ошибке не получит. Третий случай ограничен использованием лишь в последовательных системах.

Декларативные переменные, в отношении которых система ожидает, когда они получат своё значение, называются dataflow-переменные. Из этого мы автоматически получаем декларативный параллелизм, как рассматривалось на вводном цикле статей. 




Типы в декларативной модели

Тип (или тип данных) -- это множество допустимых значений с множеством операций над этими значениями. Например, тип Integer задаёт множество всех целых чисел и операции +, -, *, / (целочисленное деление). Попытка выполнения операции над значениями с несовместимыми типами приводит к ошибке.

Декларативная модель типизирована в том смысле, что содержит хорошо определённое множество типов, называемое базовые типы. Подразумевается, что в модели проверяется корректность всех операций над значениями с учётом их типов, поэтому программа не может вести себя как-то за пределами модели. Однако остаётся возможность возникновения исключительных ситуаций во время работы программы (например, деление на ноль).

В классической декларативной модели программа, сгенерировавшая ошибку, немедленно завершается -- то есть никаких обработчиков ошибок в ней нету, хотя её расширение поддерживает новую концепцию исключительных ситуаций.

В дополнение к базовым типам, программа может определять собственные типы данных, которые называются абстрактные типы данных (АТД). 


6. Базовые типы в декларативной модели

- Булевы величины (true и false).

- Атом -- вид символической константы, которая может использоваться в выражении. Это может быть строка или идентификатор.

- Запись -- составная структура данных. Состоят из названия и списка пар имя + значение.

- Кортеж -- это запись, в которой имя -- целое число, последовательно увеличивающееся, начиная с 1 (что потенциально позволяет обращаться к значениям по их именам как индексам).

- Список -- формально описывался во вводном цикле статей. Список обычно определяется рекурсивно: считаем, что это либо nil (отсутствие значения), либо некоторое значение, сцепленное со списком. Например, список из одного элемента 2 -- это значение 2, сцеплённое со списком nil.
Менее формально, это последовательность произвольных значений, внутренне "сцепленных" друг с другом.

- Процедура -- это значение процедурного типа, фактически определение функции в классическом программистском понимании, которое либо связано с идентификатором (именем функции), либо анонимно. 


Записи и процедуры

Записи и процедуры -- это две базовые концепции декларативной модели.

Запись -- это фундаментальный способ структурирования данных, используемый в списках, деревьях, очередях, графах, и т. д. Существенное значение играет поддержка в языке и его стандартных библиотеках этого типа данных (лёгкое создание, много операций для манипулирования записями и их полями, преобразования в списки и т. п.).

А почему используются процедуры? На эту роль вполне могут претендовать объекты из ООП или функции из функционального программирования.

Процедуры значительно проще, чем объекты, а что касается функций, то процедуры также проще, потому что не требуют достаточно формального определения (как математических функций). Процедура в отличие от функций не делает никаких ограничений на количество входов и выходов -- допускается любое количество, в том числе и ноль. А у функций, в частности, должен быть ровно один выход. Процедуры -- это второй очень мощный строительный блок, о котором более подробно будет рассказано далее.

С теоретических позиций, процедуры -- это скорее абстрактные "процессы", которые можно использовать в формальных исчислениях параллельных вычислений, например, в так называемых пи-калкулусах. Аргументы процессов -- это каналы (последовательности сообщений). Декларативному параллельному программированию и параллельной композиции процедур посвящён отдельный курс, пока же мы считаем, что процедуры компонуются только последовательно, а их аргументы (каналы) генерируют ровно одно сообщение (одно значение). 



7. Базовые операции в декларативной модели

Арифметические операции и булевы сравнения чисел и атомов.

Операции над записями: обратиться к полю записи по имени, получить тип записи (её собственное имя), и получить список всех полей записи (Arity), где сперва следуют целые значения в возрастающем порядке, а затем атомы в возрастающем лексикографическом порядке.

Операции над процедурами: определить процедуру, вызвать процедуру, и проверить, имеет ли некоторое значение процедурный тип. 



8. Базовая организация вычислений в декларативной модели

Декларативная вычислительная модель основана на простой операционной семантике (смысл программы определяется её выполнением на абстрактной вычислительной машине) и позволяет рассуждать о корректности и сложности программы простым путём. Это вид абстрактной машины с высоким уровнем абстракции, никак не связанный с регистрами, адресами памяти и т. п.

В общем случае команды декларативной программы выполняются последовательно одна за другой. Это напоминает императивный стиль, за исключением того, что допускаются лишь однократные присваивания.

Допускается явно определять локальные видимости переменных (идентификаторов), где каждое новое локальное определение создаёт новый образ переменной, физически отличающийся от предыдущих (но с тем же именем). Это так называемая статическая видимость (static scoping), когда достаточно лишь просмотреть текст программы, чтобы понять видимость идентификатора, не выполняя программу или не анализируя её сложными способами.

Параметры процедур передаются по ссылке: чтобы получить какой-то результат её работы, надо указать в качестве соответствующего аргумента неинициализированную (пока не связанную со значением) переменную, в которую внутри процедуры запишется результат (свяжется с этой переменной, и она станет определённой). 


Базовая организация вычислений в декларативной модели - 2

В теле процедуры могут использоваться переменные, не определённые внутри неё и не входящие в число параметров -- это так называемые свободные идентификаторы. Однако значения этих переменных (с учётом возможной вложенности видимости) будут такими, какими они были на момент определения процедуры, которое может располагаться в любой части кода, так как это обычная операция, выполняющаяся наравне с другими. Это важный нюанс: в популярных языках программирования определения функций полностью отделены от исполняемого кода в том смысле, что они отдельно выделяются компилятором, и никак не "выполняются".
Такая схема называется статическая видимость.

А в декларативной модели определение процедуры -- это тоже фактически инструкция, последовательно исполняемый код.

Если в языке программирования подразумевается, что значения свободных переменных используются в момент вызова процедуры, в её контексте видимости на тот момент, это называется динамическая видимость (dynamic scoping), которая на самом деле принята по умолчанию в большинстве популярных языков программирования.

Однако и формально корректнее, и так рекомендуется в программной инженерии, чтобы все "внешние" определения в теле процедуры формировались именно в момент определения самой процедуры, иначе она начинает зависеть от окружения, в котором вызывается. На практике так не делается потому, что определение функций -- это не исполняемая операция языка, а то, что делается на этапе компиляции. А чтобы избежать негативных эффектов динамической видимости, обычно доступ из функций к свободным переменным либо вообще запрещён, либо настоятельно не рекомендуется.

Любая инструкция программы может быть выделена в процедуру -- простым помещением её внутрь определения процедуры. Это называется процедурная абстракция.

Процедурная абстракция совместно со статической видимостью -- это один из наиболее мощных и чистых (не допускающих побочных эффектов) программистских инструментов, который вдобавок реализуется легко и просто. 


9. Dataflow поведение

Что делать, когда в коде встречается неопределённая, несвязанная переменная? Если задать ей случайное значение, работа программы будет некорректной. Если сгенерировать ошибочную ситуацию, это будет чрезмерно строго, так как явных ошибок в программе пока не возникло.

В декларативной модели мы принимаем, что в таком случае программа просто останавливается и ждёт, когда соответствующая переменная будет связана со значением, после чего работа продолжится. Такая форма работы программы называется dataflow поведение, которое даёт разработчику второй мощный инструмент -- одновременность/параллельность. Он, как и первый инструмент, также реализуется простым путём, который мы частично рассматривали на вводном цикле статей.

По этой причине dataflow-переменные считаются в декларативной модели второй ключевой парадигмой (наряду с процедурной абстракцией). 


10. Функция

Декларативная модель предоставляет лингвистическую абстракцию для программирования с функциями.

Функция -- это процедура с единственным выходом, которая завершается не инструкцией, а выражением (его значение считается результатом этой функции).

Сама по себе функция, в отличие от процедуры, не вызывается с помощью отдельной инструкции, а "вычисляется", поэтому её вызов с конкретными аргументами можно использовать в выражениях наравне с другими значениями и идентификаторами. 



11. Исключения

Декларативная модель не способна обеспечить выразительную обработку ошибок, поэтому она обычно дополняется механизмом работы с исключительными ситуациями. От такого механизма требуются две вещи:

1) Каждый компонент должен уметь ограничить, изолировать ошибку, чтобы она не распространялась далее за пределы явно обозначенного "карантина". Ошибки, возникающие внутри компонентов, либо никак не влияют на их работу, видимую извне, либо компонент сообщает о них в чётком формате.

2) Компоненты могут иерархически вкладываться друг в друга, и требуется некоторая универсальная инструкция, которая позволяет выйти из компонента за его пределы. Если ошибка возникла где-то в глубинах иерархии, такая инструкция должна позволять "перепрыгивать" за один раз сразу через несколько уровней вложенности.

Декларативная модель не предоставляет такой возможности. В каждом компоненте (контексте) с помощью логических переменных и условий можно явно организовать подобный выход, но только за пределы текущего контекста, что, понятно, ощутимо усложняет код. Было доказано математически, что единственный способ в данном случае сохранить простоту программы -- это расширить оригинальную декларативную модель. Решается это добавлением двух команд. 


Команда try

Команда try контролирует некоторый подведомственный ей контекст, реагируя на возникающие в нём ошибки и предоставляя возможность задания реакций на них (обработки исключительных ситуаций). Программисту предоставляется возможность добавлять собственные виды исключений.

Как правило, данная команда состоит из инструкции try (начало контролируемого контекста), catch (блок, где обрабатываются различные виды возникших исключений), и else (блок, который выполняется, если исключения не возникло). Иногда она дополняется инструкцией finally со своим блоком, который выполняется в заключение всегда, независимо от того, возникла ошибка или нет. Это нужно, например, для выполнения некоторых "очистных" операций наподобие закрытия файла.
Названия этих инструкций и форма их работы и взаимосвязи между ними в разных языках программирования, конечно, могут различаться, однако общая схема -- набор минимальных требований к контролю исключительных ситуаций -- приведена выше.

Допускается опускать любые инструкции кроме начальной try. 


Команда raise

Команда raise выходит за пределы текущего контекста -- вызывает обработчик исключений за его пределами. Другими словами, ищется ближайшая к raise команда try (возможно, во вложенных внешних компонентах), в которой обрабатывается соответствующий вид исключений.

Сама по себе исключительная ситуация -- это значение (условный объект), ссылка на который (как декларативная переменная) передаётся механизмом обработки исключений в обрабатывающий код.

В общем случае возможна ситуация, когда такая переменная-исключение будет не определена (ещё не связана со значением): возникновение и перехват исключения и понимание, что это за исключение (наполнение объекта исключительной ситуации нужной информацией), могут выполняться параллельно. Это ещё один аргумент в пользу dataflow-переменных: с их помощью можно понять, что некоторая проблема уже возникла, хотя пока не ясно, что это конкретно за проблема. 



12. Динамическая и статическая типизация

Правильный язык программирования поддерживает строгую типизацию , то есть имеет систему типов, которая принудительно "навязывается" программисту. Существуют и языки со слабой типизацией, которые например допускают внутреннюю манипуляцию системой типов непосредственно из программы. Далее речь будет идти только о языках со строгой типизацией.

Строгая типизация в свою очередь подразделяется на динамическую и статическую типизацию. В динамически типизированных языках (декларативная модель динамически типизирована по умолчанию) подразумевается, что переменная может получить значение любого типа, то есть её тип определяется лишь во время работы программы, динамически. В статически типизированных языках тип каждой переменной всегда известен и либо явно задаётся программистом, либо автоматически выводится компилятором.

Статическая типизация накладывает ограничения на гибкость исходного кода, существенно снижая выразительность языка, однако характеризуется высокой способностью выявлять ошибки (в том числе и на этапе компиляции), высокой эффективностью, высокой безопасностью и возможностью частичной верификации формальной корректности программы.

Статическая типизация вылавливает основное количество ошибок на фазе компиляции. Вообще, хорошо продуманная система типов -- это важнейшая составляющая проекта, по сути частичная формальная спецификация программы, задающая её поведение. Так называемые type checkers (тайп-чекеры) в современных компиляторах весьма умны, и по спецификациям типов умеют также вылавливать весьма тонкие семантические ошибки.
Статическая типизация допускает весьма эффективную реализацию проекта, так как по каждой переменной известен тип, и компилятор может транслировать операции в наиболее оптимальный машинный код.
Статическая типизация обеспечивает высокую безопасность, потому что потенциально допускает конструирование весьма сложных типов, весьма глубоко контролирующих семантику программы.


Динамическая типизация

Динамическая типизация фактически допускает исполнение любой программы, которая синтаксически корректна. Такая гибкость особенно хорошо ощущается опытными программистами, которым доступен широкий диапазон программистских техник и которые тратят существенно меньше времени на "выравнивание" кода по требованиям системы типов.

Динамическая типизация тривиально допускает раздельную компиляцию модулей, так как не требует от модулей никакой информации друг о друге. В результате становится возможной полноценная разработка очень больших систем, когда независимо создаваемые модули могут подключаться в режиме реального времени и сразу начинать взаимодействовать "на лету". В статической типизации это невозможно, так как проектная система типов должна явно "пронизывать" все модули.

Динамическая типизация серьёзно сокращает время от идеи до реализации, допуская пошаговую итеративную разработку и позволяя "в горячую" подключать к работающей системе модули, которые реализованы лишь частично. 


Выбор между динамической и статической типизацией

На практике однако выбор между динамической и статической типизацией чаще всего сводится к эмоциональному решению: тут ведутся многолетние холивары. В то же время различия между этими подходами не так велики, как кажется. Статическая типизация рекомендуется, когда проектное задание чётко сформулировано, методы его реализации хорошо понятны, а эффективность и качество имеют первостепенное значение. Динамическая типизация рекомендуется, когда требуется быстрая разработка в коллективе опытных программистов или быстрое создание прототипа, когда проект должен быть гибким насколько возможно (это типично в случаях, когда проектное задание отсутствует или невразумительно), а также при создании системных скриптов и проектов в области машинного обучения и data science.

Современные тенденции таковы, что статически типизированные языки (Java, C#, C++ ...) постепенно становятся гибче за счёт их расширения динамическими "фишками". Например, это различные виды полиморфизма в ООП, которые сохраняют хороший стиль программирования, допуская при этом проверки на этапе компиляции.

Кроме того, явный тренд -- это объединение в одном языке нескольких парадигм программирования. 



13. Функциональное программирование

В функциональном программировании функции -- это функции в математическом смысле. Если язык допускает исключительно такое их понимание и, соответственно, это единственный способ вычислений, то такой язык программирования называется чистый функциональный язык.

Чистые функциональные языки базируются на формализме, называемом лямбда-исчисление. Существует несколько вариантов этого исчисления, все из которых основываются на двух базовых операциях: определение функции и вычисление функции.

Декларативная модель более общая, нежели лямбда-исчисление, в двух аспектах. Во-первых, она допускает определение функций над неопределёнными переменными, и во-вторых, она использует процедурный синтаксис.

Можно ввести два ограничения в декларативную модель, чтобы получился чистый функциональный язык:
- переменная должна немедленно связываться со значением, как только она была декларирована в программе;
- использовать допускается только функциональный синтаксис (вызовы функций), а не процедурный (явные инструкции, вызывающие процедуры).

Декларативная модель с такими ограничениями называется (строгая) функциональная модель. 

 Функциональная модель, описываемая сейчас, подразумевает динамическую типизацию, однако многие популярные функциональные языки статически типизированы, и в них поддерживается вывод типов, который компилятор выполняет автоматически, определяя типы всех функций.

В декларативной модели функции так называемые жадные по умолчанию -- то есть все аргументы функции заранее вычисляются перед вызовом функции. Ленивое вычисление подразумевает, что соответствующий аргумент будет вычислен только в тот момент, когда он непосредственно потребуется в процессе выполнения тела функции. Это в частности позволяет программе работать с потенциально бесконечными структурами данных.

В итоге, декларативная модель за счёт dataflow-переменных и однократного присваивания позволяет использовать мощные техники программирования, которые недоступны в функциональных языках, даже самых популярных (Haskell, Erlang, ML, Scheme, ...) -- даже каррирование в них поддерживается неполноценно и в плане синтаксиса, и в плане реализации.

Вдобавок декларативный подход позволяет прозрачно расширить вычисления параллельностью, сохраняя при этом все сильные стороны функционального программирования. 




Часть III.
Как программировать в декларативной модели?

Приступаем к изучению конкретных программистских техник, которые вы сразу сможете применять в своей работе, независимо от того, на каком языке вы пишете код.
14. Ключевые преимущества декларативного программирования

У декларативного программирования имеются два ключевых преимущества:

1. Декларативные программы композиционны: декларативная программа состоит из компонентов, каждый из которых может быть разработан, протестирован и проанализирован в плане корректности независимо от других компонентов и от собственной истории вызовов.

2. Формальное рассуждение/думание/мышление о декларативной программе просто. И хотя другие вычислительные модели позволяют писать более выразительный код, он в то же время будет сложнее для понимания. А в отношении декларативных программ вдобавок легко применять различные техники логического и алгебраического анализа.

Первое преимущество напрямую относится к programming in large -- способности продуктивно создавать сложные и надёжные системы. Второе -- к programming in small, непосредственно написанию ясного и корректного кода. Поэтому было бы здорово, если бы все проекты можно было легко программировать в декларативной модели. К сожалению, это не так. Декларативная модель хорошо подходит для некоторых видов задач, но плохо подходит для других.

Хотя, на уровне programming in small элементы декларативного стиля (в формате, например, функционального программирования) вы можете применять всегда, и это будет крайне полезно. 

 Как реализуется композиционнность декларативного кода?

С помощью декларативных операций и декларативных компонентов.

Декларативная операция
-- независима (не зависит ни от какого состояния за её пределами),
-- stateless (не содержит никакого внутреннего состояния, которое запоминается и хранится между вызовами), и
-- детерминистична (всегда выдаёт один и тот же результат для одних и тех же аргументов).

Все программы, написанные в вычислительной модели данного курса, будут декларативны.

Компонент -- это чётко ограниченный фрагмент программы с хорошо определёнными входами и выходами. Компонент может быть определён в терминах множества более простых компонентов. Например, процедура -- это один из видов компонента.
В декларативной модели взаимодействие между компонентами определено исключительно входами и выходами каждого компонента. Любой компонент может быть полностью понят сам по себе, независимо от других компонентов.

В результате, понимание всей декларативной программы в целом -- это линейная сумма пониманий её компонентов.

Если взаимодействие между компонентами будет более тесным, тогда разобраться в каждом из них по отдельности не получится.

Отсюда первый, самый главный принцип, разработки и отдельного модуля (programming in small), и системы в целом (programming in large), независимо от того, какой язык программирования вы используете:

Как можно больше компонентов в системе надо делать декларативными.

Использовать другие вычислительные модели, подразумевающие тесные взаимосвязи между компонентами, надо только в чётко ограниченном и изолированном подмножестве компонентов. 


 15. Как писать декларативные программы?

Самый простой и прямой путь писать декларативные программы (или отдельные декларативные компоненты) -- это использовать рассмотренную в предыдущих разделах декларативную модель :)

Использовать переменные только для однократных присваиваний. Использовать только арифметические операции и операции (чистые функции) над списками и записями (классами без методов). Комбинировать декларативные операции, что даст на выходе тоже декларативную операцию.

Один из способов декларативного комбинирования -- это алгебраическое правило "equals can be replaced by equals" (равное заменяется равным), которое в программировании называется ссылочная прозрачность, существенно упрощающая рассуждения о программе. Например, если известно, что f(a) = a^2, то мы можем заменить f(a) на a^2 в любом месте, где она встречается. Например, равенство b = 7*f(a)^2 станет b = 7*a^4.

С технической точки зрения, написать декларативную программу -- значит, спроектировать эту программу как множество определений чистых рекурсивных функций, комбинируя их по правилам программирования высшего порядка.

Прямая рекурсия означает, что функция явно вызывает себя в своём теле. Непрямая рекурсия означает, что функция вызывает другую функцию, которая вызывает исходную функцию. Программирование высшего порядка означает, что функции могут получать функции как параметры и возвращать их в качестве результата. Этот подход лежит в основе фактически всех техник для построения абстракций, изучаемых на данном курсе.

Такой подход условно назовём "декларативщина" (declarativeness).

В частности, распространено неформальное определение декларативщины: когда программирование задаётся в терминах, что надо сделать (специфицируем результаты, которые мы хотим получить), а не в терминах, как добиться результатов (для чего требуется кодирование в классическом алгоритмическом смысле).

Итак, вышеописанные базовые принципы потенциально уже позволяют писать полностью декларативные программы в повседневной разработке -- на Java, C# и Python и других популярных императивных и ОО-языках. Таким образом, программы, придерживающиеся декларативной вычислительной модели, будут декларативными, однако подход этот не очень практичный. Существуют и другие способы создания программ, которые гарантированно будут декларативными. 

 16. Классификация декларативных программ по степени выразительности кода

Рассмотрим классификацию декларативных программ по их выразительности, чтобы определиться, какой подход на практике будет наиболее практичен.

1. Дескриптивная декларативщина (менее выразительная): декларативная программа просто определяет структуру данных. Это, например, языки HTML или XML, которые конечно слишком слабы, чтобы на них разрабатывать универсальные программы. Однако они удобны, когда требуются вычисления с соответствующими структурами данных (например, задать структуру документа, не указывая, как конкретно выполнять форматирование).

2. Программируемая декларативность (более выразительная). Это, например, язык, основанный на изученной декларативной вычислительной модели. Тут в свою очередь существуют два фундаментально отличных подхода:
2.1. дефиниционная форма, когда декларативщина есть свойство реализации компонента. Например, компонент, реализованный в декларативной модели, по определению будет гарантированно декларативным.
2.2. наблюдаемая форма, когда декларативщина есть свойство интерфейса компонента. Тут мы придерживаемся принципа абстракции: чтобы использовать компонент, достаточно знать его интерфейс, и не нужно знать реализацию. Компонент должен вести себя декларативно: быть независимым, stateless и детерминистичным, но необязательно реализованным в декларативной модели. 

 Для дефиниционной формы в свою очередь характерны два популярных стиля программирования: логический и функциональный. В функциональном стиле компонент -- это математическая функция, в логическом -- логическая взаимосвязь. Формально манипулировать функциями или логическим кодом труднее, нежели в случае дескриптивных программ, однако к ним по прежнему хорошо применимы алгебраические правила.

В наблюдаемой форме компоненты могут быть реализованы в любой вычислительной модели: главное, что в нашей декларативной программе они ведут себя декларативно, и доступны только через свои публичные декларативные интерфейсы (в частности, в парадигме абстрактных типов данных, которые мы изучали на курсе по ООАП).


 17. Языки спецификаций

Декларативное программирование -- это про то, "что" надо сделать, а не "как".

Крайние сторонники декларативного программирования подчас считают, что полностью отвязаны от реализации, и всё что у них есть -- это только спецификация. В этом смысле спецификация -- это программа. Формально это так, и математическое описание может быть реализовано весьма эффективно. Но на практике декларативные программы похожи на любые другие: им нужны алгоритмы, структуры данных, модульность/структуризация проекта и понятие приоритета операций. Они в итоге существенно больше своих спецификаций: приходится искать компромисс между эффективностью и выразительностью, удобством ручного программирования.

Можно определить декларативный язык, который будет существенно выразительнее простого языка, изученного на предыдущих занятиях. Такой язык называется языком спецификации. Однако эффективно реализовать его практически невозможно. Это противоречие на практике решается например так: были созданы так называемые решатели теорем (theorem provers), которые выполняют различные формальные, математические вычисления. Однако они не полностью автономны, а подразумевают интерактивное взаимодействие с человеком. С их помощью разработчик может часто доказывать очень важные и серьёзные утверждения о своём коде, проверять различные характеристики программы (например, гарантированную семантическую корректность определённых функций). Пока на практике потенциал теорем-пруверов ограничен программами небольшого объёма, хотя это очень перспективное направление. 

 18. Итеративные вычисления

Итак, мы добрались до практических ответов на вопрос "Как программировать в декларативной модели?".

Начнём с создания совсем простого вида программ: итеративные вычисления. Они начинаются с исходного состояния S0, и через серию последовательных трансформаций в S1, S2, ... достигают итогового состояния Sn.

Схема итеративных вычислений такая: имеется рекурсивная функция Iterate(Si), которая проверяет, является ли Si конечным состоянием Sn. Если это так, то она прекращает работу, иначе выполняет преобразование Si в Si+1, и вызывает саму себя с аргументом Si+1. На практике тут для удобства комбинируется несколько процедур.

Важная особенность такой схемы, что при итеративных вычислениях не формируется глубокий стек рекурсивных вызовов: по сути, этот стек вообще не нужен, так как никаких дополнительных вычислений над результатом работы не происходит, поэтому данная схема хорошо оптимизируется компилятором.

Например, классический факториал на Julia в декларативном формате запишется так:

function f(n, fin) 
  if fin == 1
     return n
  end 

  n = n * fin
  return f(n, fin-1)
end

println(f(1, 5)) # 120

Для наглядности в подобных случаях добавляют главную процедуру с одним параметром, которая выполняет начальные внутренние настройки и вызов рекурсивной функции с исходными аргументами. 

 Абстракции управления

Далее полезно сделать следующий шаг и превратить нашу универсальную схему в абстракцию управления -- программный компонент, который может использоваться другими компонентами. Схема рекурсивного итеративного вычисления, как вы скорее всего заметили, очень похожа на классический оператор цикла while, только дополненный возвращаемым значением. Чтобы превратить схему в абстракцию управления, надо параметризовать её выделением частей, которые зависят друг от друга. В данном случае таких частей две: это проверка окончания вычислений и трансформация текущего состояния с получением следующего состояния. Каждую из частей можно представить как функцию с одним аргументом (сам аргумент в зависимости от задачи может быть достаточно сложной структурой данных).

Передача функций как аргументов в другие функции относится к группе техник в рамках программирования высшего порядка, рассматриваемых далее.

Получается следующая генерализованная функция нашей схемы -- по сути полноценный компонент, который теперь можно использовать в своих проектах.

function Iterate(S, IsDone, Transform) 
  if IsDone(S)
     return S
  end 

  S = Transform(S)
  return Iterate(S, IsDone, Transform) 
end

Первый параметр -- начальное состояние. Второй параметр -- функция IsDone, которая определяет, будет ли её аргумент (текущее состояние) результирующим. Функция Transform выполняет преобразование текущего состояния в следующее. 

 Например, для вычисления факториала по данной абстракции управления удобно будет использовать такое состояние, как список из двух элементов, где первый элемент -- текущее значение факториала, а второй -- понижающееся до 1 количество итераций, начиная с заданного (исходное число, факториал которого мы вычисляем).

function is_done(S)
  return S[end] == 1 
end

function transform(S)
  S1 = [S[1] * S[2], S[2] - 1] 
  return S1 
end
  
S = Iterate([1, 5], is_done, transform) # S = [120, 1]

В целом, это мощный способ структурировать программу, потому что он разделяет общие схемы управления и их конкретное использование. Программирование высшего порядка будет особенно полезно для такого структурирования.

Если подобная абстракция управления используется в проекте часто, то следующим шагом может стать предоставление её уже в качестве лингвистической абстракции (оператора языка). 


 19. Рекурсия

Итеративные вычисления -- это частный случай более общего вида вычислений, называемых рекурсивные.

Итеративные вычисления по сути представляют собой обычный условный цикл while, в котором выполняется очередная итерация (трансформация состояния) до тех пор, пока не сработает условие окончания вычислений.

Рекурсия в программировании представлена в двух формах: в функциях и в типах данных.

Рекурсивная функция в своём определении содержит собственный вызов, может вызвать себя в любой точке своего тела и не один раз, а много. Тип данных считается рекурсивным, если он определён в терминах самого себя. Например, когда мы разбирали списки, то выяснили, что этот тип данных рекурсивный (либо пустой список, либо головной элемент, к которому прицеплен оставшийся список). Особенно продуктивным механизм рекурсии получается, когда удаётся гармонично объединить рекурсивные функции с рекурсивными типами данных.

Однако в рекурсивных вычислениях стек вызова функций может неограниченно расти. В общем случае неаккуратное использование рекурсии приводит к знаменитой ошибке Stack Overflow (переполнение стека). К сожалению, в ряде случаев потенциально этого избежать невозможно (например, при анализе деревьев). 

 Как ограничивать глубину рекурсии

В прикладном декларативном программировании принято сознательно избегать роста стека, допуская его лишь там, где он точно необходим.

Например, в классической рекурсивной функции вычисления факториала числа N потребуется стек глубиной N.

function f(n)
  if n == 0
     return 1
  elseif n > 0
     return n * f(n-1)
  else
     throw(DomainError())
  end
end

f(5) # 5

Из-за того, что умножение n * f(n-1) должно выполниться уже после того, как вычислится f(n-1), необходимо сохранить в стеке текущее состояние функции, и перейти к рекурсивному вычислению f(n-1). Текущее состояние подразумевает хранение идентификаторов и связанных с ними значений (по сути, замыкание), и реальные вычисления именно так и происходят, однако эта схема неудобна для поддержки более абстрактных схем вычислений.

Рассмотрим на этом примере типичные приёмы избегания роста стека. 

 Как ограничивать глубину рекурсии - 2

Можно добавить в абстрактную декларативную машину простое расширение: механизм замены (подстановка) идентификаторов в инструкциях непосредственно на те сущности, на которые эти идентификаторы ссылаются. Абстрактная машина с подстановками не нуждается в окружении, которое приходится постоянно отображать в идентификаторы (и наоборот).
При этом, правда, стек всё равно будет расти, только уже не в глубину, а в ширину -- в одном элементе стека будут чрезмерно накапливаться промежуточные результаты. Например, в случае факториала большого числа придётся "раскрутить" выражение в ширину на всю "глубину" вызова факториала; вдобавок, такая схема сложна в реализации, и на практике не используется.

Классический способ борьбы с ростом стека -- это переход от рекурсивных вычислений к итеративным. В случае функции факториала и подобных можно расширить количество параметров функции добавлением так называемого аккумулятора промежуточных вычислений:

function f(n, a)
  if n == 0
     return a
  elseif n > 0
     return f(n-1, a*n)
  else
     throw(DomainError())
  end
end
  
f(5,1) # 120

Такую функцию можно для наглядности "обернуть", как говорилось выше, основной функций для внешнего вызова, которая будет получать единственный параметр, а затем вызывать рекурсивную функцию с её начальными параметрами. Кроме того, основная функция может сразу дополнительно контролировать параметр (не будет ли он отрицательным) и т. д. 




Программирование с применением рекурсии.

Программирование со списками

Рекурсивные вычисления -- это сердце декларативного программирования.

Списки -- очень лаконичный тип данных, и в то же время потенциально такой мощный, что позволяет закодировать любую сложную структуру данных. Декларативное программирование работы со списками получается простым и выразительным и предлагает следующие базовые подходы:
- рекурсивное мышление: как решать задачу в терминах более простой задачи;
- преобразование рекурсивных вычислений в итеративные (обычно в рекурсивных вычислениях размер стека растёт пропорционально размеру списка);
- выяснение правильности итеративных вычислений (простой и мощный способ -- через инварианты состояний);
- конструирование программ на основе системы типов (функция, работающая с некоторым типом, почти всегда имеет рекурсивную структуру, очень близкую к определению типа).

Рассмотрим эти подходы более подробно. 


20. Рекурсивное мышление

Список -- рекурсивная структура данных, определённая в терминах более маленькой версии себя. Напомню определение, которое мы давали списку: это либо nil (отсутствие значения), либо некоторое значение, сцепленное с последующим списком-"хвостом".

Поэтому функция для работы со списками будет состоять из двух частей:
- базовый случай, для небольших списков (ноль, один или два элемента) результат возвращается сразу;
- рекурсивный случай, для крупных списков функция вычисляет результат в терминах результата из более мелких списков.

Простая рекурсивная функция, вычисляющая по такой схеме длину списка:

function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end

 Другой пример: функция, которая должна объединить два списка, сформировав из них третий список. По индукции разбор надо начинать с первого списка.

function Append(Ls, Ms)

    if Ls == []
        return Ms
    end

    return pushfirst!(Append(Ls[2:end], Ms), Ls[1])

end

Смысл в том, что мы выделяем голову из первого списка, рекурсивно вызывая Append() для хвоста первого списка и второго списка, после чего добавляем эту голову к результату рекурсии. Мы как бы "выносим" голову первого списка из рекурсии наружу. И так как функция всегда работает только с первым аргументом, постоянно его уменьшая, она гарантированно закончится (это важное требование к декларативным программам).

Операции pushfirst! и подобные ей конечно не входят в декларативную модель, так как непосредственно модифицируют значения списка-аргумента. В декларативной модели операции над списками обычно создают новые списки, поэтому они практически всегда низкоэффективны, за исключением добавления элементов в голову или хвост, хотя это тоже зависит от реализации. 


Рекурсивные функции и их области определения

Определим функцию Nth, которая возвращает N-й элемент списка:

function Nth(Ls, N)
    if N == 1
        return Ls[1]
    elseif N > 1
        return Nth(Ls[2:end], N - 1)
    end
end

println(Nth([1,3,5], 3)) # 5

Но что случится, если мы вызовем Nth([1,3,5], 5)? В данном случае возникнет исключение BoundsError (выход за границы списка/массива). Исключение возникнет также, если N будет равно нулю, и т. д.

Отсюда следует общая техника определения функций: генерировать явные исключения, когда значения параметров находятся вне области определения функции. Однако гарантировать такой контроль весьма трудоёмко (возможны в частности ситуации, когда аргументы окажутся других типов, и т. п.). Компилятор Julia, в отличии, например, от компилятора Java, не отслеживает обязательное завершение всех веток функции, поэтому в динамически типизированных языках это будет проблемой. Тут желательно использовать различный синтаксический сахар, повышающий наглядность и выразительность кода, зависящего от диапазона некоторых параметров. 


Наивные определения часто неэффективны

Как "естественно" реализовать рекурсивную функцию обращения (перевёртывания) списка?

function Rev(Ls)
    if Ls == []
        return []
    end

    head = Ls[1]
    tail = Ls[2:end]
    return push!(Rev(tail), head)
end

println(Rev([1,5,3,7,9])) # [9,7,3,5,1]

Какой примерно будет её производительность? Для списка длиной n придётся сделать n рекурсивных вызовов, и n добавлений элемента в список. Функция push!() в среднем обрабатывает список длиной n/2 элементов, поэтому общая эффективность Rev() будет пропорциональна n*n/2, или по сути O(n*n). Чем длиннее список, тем сильно дольше будет работать такая функция. Кроме того, данная функция имеет ещё один неприятный дефект: для её работы потребуется стек вызовов глубиной n, и если например надо обратить список из миллиона элементов, вполне возможен классический stack overflow.

Любой программист с базовыми навыками, знакомый с императивным языком (например, Java или Python), напишет функцию обращения списка с эффективностью O(n): в одном цикле просто брать i-й от конца исходного списка элемент, и добавлять его в хвост результирующего списка. Поэтому существуют техники, позволяющие превращать такие рекурсивные функции в функции с итеративной формой вычислений, чья эффективность линейна. 


21. Преобразование рекурсивных вычислений в итеративные

Вернёмся к функции определения длины списка.

function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end

Она работает за линейное время, однако всё ещё требует стек размером n (длина списка-параметра). Почему так происходит? Потому что прибавление +1 в заключительном return происходит уже после рекурсивного вызова Len(tail). Вызывающему окружению необходимо "сохраниться" (в частности, запомнить точку возврата в функцию в стеке), о чём уже говорилось -- по сути только для того, чтобы прибавить 1 к результату и сразу его вернуть.

Ранее мы уже обсуждали итеративную схему как последовательность трансформации состояний. В её формате процедуру вычисления длины списка можно представить как последовательность перехода от состояния к состоянию, где каждое состояние -- это пара {длина уже обработанного списка, оставшийся список}. Начальное состояние S0 -- это (0, исходный список), а конечное состояние Sn (для списка длиной n) -- это (n, пустой список). Промежуточное состояние Si -- (i, хвост списка от i+1 до n).

Переведя этот подход в рекурсивный вид, мы получим функцию, которая получает два параметра (длина списка и оставшийся список), увеличивает длину на +1 и удаляет из списка первый элемент.

function IterLen(i, lst)
    if lst == []
        return i
    end
    return IterLen(i+1, lst[2:end])
end

println(IterLen(0, [1,2,3,5,8])) # 5

Теперь увеличение счётчика i на 1 выполняется не после, а до рекурсивного вызова, и так как он последний в коде функции, сохранять её состояние в стеке не требуется. Фактически мы получили рекурсивную версию итеративной схемы расчёта. 

 Применим теперь аналогичную технику к функции обращения списка. В качестве состояния снова будем использовать пару {уже обращённая часть списка, оставшаяся необработанной часть списка}.

function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
end

println(IterRev([], [1,5,3,7,9])) # [9,7,3,5,1]

Чтобы обеспечить пользователя удобством вызова подобных рекурсивных функций, требующих дополнительный параметр, используется "обёртка" в виде родительской функции, вызывающей рекурсивную функцию с начальным аргументом. Нередко, в частности, в такой схеме рекурсивная функция определяется непосредственно внутри родительской функции.

Например:

function Revers(Rs)

  function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end
    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
  end

    return IterRev([], Rs)
end

println(Revers([1,5,3,7,9])) # [9,7,3,5,1]

Функция Revers работает за линейное время и не требует стека. 



22. Корректность с инвариантами состояния

Как уже говорилось, в декларативной модели многие важные вещи реализуются достаточно легко (в частности, доказательство формальной корректности кода). Рассмотрим общую технику такого доказательства на примере функции IterLen -- эта техника легко применяется и к IterRev, и к другим итеративным вычислениям.

Идея этой техники, что мы определяем некоторое свойство P(S-i) состояния (свойство P для i-го состояния S), о котором мы всегда можем сказать (доказать), что оно истинно. Такое свойство называется инвариант состояния. Для простоты можно считать, что это свойство -- предикат (некоторая аксиома тождественности).

Если P выбрано удачно, то корректность всего вычисления будет автоматически получено из истинности P(S-final).

Какое состояние мы выбрали для IterLen? Напомню, это пара {длина уже обработанного списка, оставшийся список} -- (i,Ys). На основе этого состояния и исходного списка Xs введём такое свойство:

P( (i,Ys) ) : length(Xs) = i + length(Ys)

Оно утверждает, что длина всего списка Xs для любого состояния равна текущему значению длины i из этого состояния плюс длина оставшегося списка Ys (второй элемент состояния).

1. Докажем истинность P(S-0). Исходное состояние будет (0, Xs), из чего следует, что length(Xs) = 0 + length(Xs).

2. Из P(S-i), где S-i ещё не заключительное состояние, должно следовать S-i+1. Это будет следовать из семантики оператора if и вызова функции. Пусть S-i = (i,Ys). Так как это ещё не заключительное состояние, длина Ys будет ненулевой. Из семантики, i+1 в коде увеличит i в состоянии на один, а Ys в следующем состоянии станет нынешний Ys без первого элемента. Отсюда доказана истинность P(S-i).

3. Так как Ys будет постоянно уменьшаться на один элемент, мы гарантированно придём к заключительному состоянию S-final, в котором Ys будет пустым списком: (i, []), а функция возвращает i. Так как length([]) = 0, из P(S-final) следует, что i = length(Xs).

Мы доказали это "вручную", но сегодня уже существует немало пруф-ассистантов, которые способны выполнять подобные доказательства корректности автоматичски. 

 Понятно, что наиболее трудный шаг в таком процессе -- это выбор инварианта, свойства P, подразумевающий определённое мастерство. В этом поможет, в частности, такое ограничение, накладываемое на P: свойство должно комбинировать аргументы итерационных вычислений так, чтобы результат не менялся по ходу этих вычислений. Другими словами, мы подбираем, например, некоторый предикат, который задаёт какую-то наглядную и явно истинную характеристику состояния.

Например, в случае функции обращения списка Xs, где состояние -- это пара {уже обращённая часть списка Rs, оставшаяся необработанная часть списка Ys}, в состоянии S-i можно потребовать, чтобы элемент Rs[end] был равен Xs[end - i + 1] (при индексации с единицы), а необработанная часть списка на каждом шаге сокращалась.

Другими словами, в уже обращённой части списка на i-м шаге её последний элемент всегда будет end-i+1 -м элементом в исходном списке (отсчитываем i с конца исходного списка).

Xs = [1,2,3,4,5]
S[1] = 5 + 1,2,3,4
S[2] = 5,4 + 1,2,3
S[3] = 5,4,3 + 1,2
...



23. Конструирование программ на основе рекурсивных типов

Это очень мощное и одно из наиболее сильных на сегодня направление в проектировании сложных систем очень наглядно и ясно понимается именно в простой и минималистичной декларативной парадигме. Классический пример -- это любопытное свойство практически всех функций, обрабатывающих списки. Они всегда проверяют, пустой ли параметр-список, выполняя при этом одни действия, а если он не пустой, то выделяют в нём голову и хвост, выполняя над ними другие действия, включающие рекурсивный вызов.

Фактически рекурсивная структура функции следует из рекурсивной структуры определения типа. Список List -- это элемент-голова типа T, сцепляемый с оставшимся списком List. Это свойство, практически всегда истинное для функций, работающих со списками, хорошо помогает при создании таких функций на практике.

Замечание по поводу типов.
В общем случае формальное определение типа в конкретном языке дескриптивно/описательно: оно просто предлагает набор логических утверждений о множестве значений, которые может принять переменная. Однако такие формальные определения, к сожалению, не могут претендовать на полноценную проверку допустимости конкретных значений. Более того, часто их вообще невозможно проверить, и даже простейшие базовые типы (например, положительные целые числа), описанные в декларативной модели, вообще не могут быть проверены компилятором. 

 Например, требуется написать функцию, которая считает количество элементов в списке, элементами которого также могут быть вложенным списки. Julia допускает такие структуры, например: [[9,7],3,[5,0,1],7]. В таком списке семь элементов.

Как можно определить соответствующий тип NestedList‹T›?

Если обычный список List‹T› определяется так: это ...
-- либо пустой список [],
-- либо элемент T, сцепленный с List‹T›

то NestedList‹T› будет представлен так: это ...
-- либо пустой список [],
-- либо NestedList‹T›, сцепленный с NestedList‹T›,
-- либо элемент T, сцепленный с NestedList‹T›.

Основанная на таком типе функция LengthL(Xs) будет иметь следующую структуру:

-- если Xs -- пустой список [], то return 0

-- если X (голова Xs) -- это NestedList‹T›, и Xr (хвост Xs) -- это NestedList‹T›, то
return LengthL(X) + LengthL(Xs)

-- если X (голова Xs) -- это элемент T, и Xr (хвост Xs) -- это NestedList‹T›, то
return 1 + LengthL(Xs)

function LengthL(Xs)

    if Xs == []
        return 0
    end

    head = Xs[1]
    tail = Xs[2:end]

    if isa(head, Array)
        return LengthL(head) + LengthL(tail)
    end

    return 1 + LengthL(tail)
end


println( LengthL([[9,7],3,[5,0,1],7]) ) # 7

Функция isa() проверяет тип своего первого аргумента на его "равенство" второму аргументу (в данном случае проверяется, список ли голова). 

 Изменение структуры типа может приводить к функции с другой логикой. Например, мы хотим посчитать количество элементов в списке только на её "верхнем" уровне (когда каждый вложенный список считаем за единицу, как обычный элемент).

Зададим для этого новый тип NestedList2‹T›:
-- либо пустой список [],
-- либо NestedList2‹T›, сцепленный с NestedList2‹T›,
-- либо элемент "верхнего" уровня.

Его отличие от NestedList‹T› в том, что NestedList‹T› -- это всегда список, а NestedList2‹T› может быть как списком, так и отдельным элементом типа T.

Функция получится такая:

function LengthL2(Xs::Array)

    if Xs == []
        return 0
    end

    head = Xs[1]
    tail = Xs[2:end]

    if tail == []
        return 1    
    end

    return LengthL2([head]) + LengthL2(tail)
    
end

println( LengthL2([[9,7],3,[5,0,1],7]) ) # 4

Если рекурсия добралась до одиночного элемента (когда хвост -- пустой список), то мы уже не изучаем этот элемент (а не список ли он?), а просто засчитываем его как единицу. 

 Отсюда следует важный урок: надо уметь правильно определять рекурсивный тип перед тем, как писать функцию, которая с этим типом работает. Иначе очень вероятна, например, "наивная" и неэффективная реализация, или даже ошибки во время выполнения. По этой причине, в частности, функциональные языки (например, OCaml/F# или Haskell) автоматически поддерживают так называемый вывод типов (type inference), когда компилятор определяет, какого типа каждая функция (её сигнатура) -- по контексту её использования/вызова в коде. Вывод типов гарантирует, что рекурсивный тип используется корректно, но, конечно, качественное проектирование самого типа зависит от опыта и мастерства программиста.

Многие алгоритмы удобно разрабатывать именно в декларативной модели в силу её минималистичности: она исключает множество потенциальных ошибок. В частности, часто применяется простая стратегия "разделяй и властвуй" (divide-and-conquer): выделяем в некоторой рекурсивной структуре две (или больше) примерно равных её частей, после чего применяем этот алгоритм к каждой части. Данная стратегия отлично работает например для списков, деревьев и многих других более сложных типов. 



24. Аккумуляторы

Мы выяснили, как создавать простые рекурсивные функции для обработки списков, как превращать их в итеративные, как правильно писать и использовать рекурсивные типы данных. Но на практике разработка в декларативной модели обычно исключает первый шаг: функция сразу же пишется итеративной. Идея такого подхода в том, чтобы передавать состояние всё дальше и дальше через вычисления, и никогда не возвращаться обратно через return.

Для этого любое состояние S расширяется парой аргументов S1 и Sn, которая называется аккумулятор. Этот аккумулятор передаётся в процедуру, которая, напомню, подразумевает возвращение значения через свои параметры. S1 тут становится входным состоянием, а Sn -- выходным (результирующим) состоянием. Внутри такой процедуры происходит рекурсивный вызов, который выполняет последовательные преобразования S-i в S-i+1.

P(S, S1, Sn)
  если S заключительное (вычисления не требуются) то 
    Sn = S1
  иначе
    // рекурсивные вызовы 
    P1(S1, S2)
    P2(S2, S3)
    ...
    Pn(Sn-1, Sn)

Выход каждой процедуры Pi служит входом для следующей процедуры Pi+1.

Как правило, качественное отличие этого подхода от рекурсивных функций в том, что за счёт передачи результата по ссылке можно не создавать множество промежуточных копий состояний, указывать только, например, границы (диапазон) обработанных элементов в исходной структуре.

Так, рассмотренная ранее функция IterLen потенциально использует схему с аккумулятором, так как передаёт результат (текущую длину) в следующий вызов -- только не так явно, так как в ней используется return вместо записи результата в аргумент, переданный в параметр по ссылке.
В данном случае удаётся обойтись одним рекурсивным вызовом, но когда требуются вызовы нескольких других "процедур"? Например, если мы обрабатываем дерево, где явно разделяются левое и правое поддеревья, для каждого из них потребуется явный отдельный рекурсивный вызов. 

 Более наглядный пример -- это версия функции LengthL с аккумулятором. В ней мы делим список на две (или больше) примерно равные части, вызываем функцию рекурсивно для каждой из них, после чего возвращаем итог.

function LengthLA(Xs)

    l = length(Xs)
    if l == 0
        return 0
    elseif l == 1
        if isa(Xs,Array)
           return LengthLA(Xs[1])
        else
           return 1
        end 
    end

    head = Xs[1:div(l,2)]
    tail = Xs[div(l,2)+1:end]

    n1 = LengthLA(head)
    n2 = n1 + LengthLA(tail)
    return n2

end

Преимущество её в том, что рекурсивные вызовы для анализа примерно равных частей head и tail могут выполняться параллельно. 

 Однако недостаток подхода с равными частями в том, что требуется создавать множество копий частей исходного списка, как и в оригинальной версии. Аккумуляторы позволяют избавиться от этого существенного недостатка: мы можем передавать основной список по ссылке, а также дополнительно указывать диапазон (начало и конец) в этом списке, который требуется проанализировать. Таким образом мы получаем огромный выигрыш в производительности и экономии памяти.

function LengthLA2(Xs, from, to)
    l = to-from+1
    if l == 0
        return 0
    elseif l == 1
        if isa(Xs,Array)
           return LengthLA2(Xs[from][1],1,length(Xs[from]))
        else
           return 1
        end 
    end

    n1 = LengthLA2(Xs,from,from+div(l,2)-1)
    n2 = n1 + LengthLA2(Xs,from+div(l,2),to)
    return n2
end

В практических проектах количество аккумуляторов в функциях достигает подчас нескольких десятков, что существенно затрудняет программирование. Сегодня схема с аккумуляторами считается устаревшей, её имеет смысл использовать, когда удаётся обойтись не более чем 1-2 аккумуляторами. 


Рекурсивные типы данных
25. Списки различий (Difference lists)

Список различий -- это пара списков, которые связаны друг с другом так: второй список может быть получен из первого удалением нуля или большего числа элементов из первого списка. Список различий записывается в виде этих двух списков, разделённых #.

Например, [a]#[a] или [a,b,c,d]#[c,d]. Список различий можно отобразить в обычный список, если из хвоста первого списка удалить элементы второго списка. То есть [a]#[a] отображается в [], а [a,b,c,d]#[c,d] в [a,b].

Списки различий -- это частный случай структур различий. Структуры различий -- это пары значений, в которых второе значение встроено в первое значение. Структура различий репрезентует значение, равное первой структуре минус вторая структура. Структуры различий позволяют легко конструировать итеративные вычисления над самыми разными рекурсивными структурами (списками, деревьями, ...). В свою очередь структуры различий -- это частные случаи аккумуляторов (когда нам требуется сразу писать итеративный код). 

 Особенность списков различий в том, что их хвосты могут быть неопределённы (хранят в самом конце неопределённую переменную). Например, имеются списки (a|b|c|X)#X и (d|e|f|Y)#Y, где X и Y -- неопределённые переменные (не связанные со значением). Тогда, если мы захотим сложить эти списки, то сможем сделать это за константное время O(1) независимо от их длины. В данном случае мы просто проинициализируем переменную X вторым списком (ссылкой на него), и получим (a|b|c|d|e|f|Y)#Y. Но за такую эффективность приходится расплачиваться: например, подобное сложение можно выполнить лишь один раз, так как первый список фактически перестаёт существовать (неопределённая переменная получит значение).

Списки различий были определены в языке логического программирования Пролог и служат основной для множества техник программирования в этом языке. Как программистская концепция, список различий находится где-то между концепцией значения и концепцией состояния: он имеет все характеристики значения (программы, использующие его, будут декларативными) и при этом предлагает мощность состояния, потому что их можно складывать за константное время.



26. Очереди

Структуру данных "очередь" мы изучали на первом курсе по алгоритмам и структурам данных. Напомню, что очередь работает по принципу FIFO (первый вошёл - первый вышел) и представляет собой список с двумя операциями без дополнительных аргументов. Операция добавления добавляет элемент в хвост очереди, а операция удаления удаляет элемент из её головы (что соответствует работе реальной очереди).

В императивной модели очередь реализуется легко и эффективно с помощью двухсвязного списка, что позволяет выполнять эти две операции за константное время O(1). Однако в декларативной модели у нас нету ни переменных, ни указателей, и если добавление элемента в голову -- это обычно тоже константная по времени операция, то удаление из хвоста приходится реализовывать "вручную", и оно подразумевает сложность O(n).

Поэтому была разработана отдельная достаточно эффективная реализация очереди именно для декларативной модели, обеспечивающая O(1) и для добавления, и для удаления элемента в очереди. Для этого будем использовать две операции (добавление в голову и удаление из головы), которые работают за константное время, в отличие от операций, работающих с хвостом. 

 В ООП мы естественно представляли очередь как объект (экземпляр класса со скрытой реализацией), но в декларативной модели нам доступны лишь списки и записи. Будем считать очередью запись, состоящую из двух элементов: F и R, где имена F и R связаны со своими значениями-списками. То есть очередь -- это структура из пары именованных списков.

Так как в декларативной модели мы не можем менять значения полей в записи, каждая из операций над очередью (добавление или удаление элемента) всегда создаёт (возвращает в качестве своего значения) новую очередь. Соответственно, конкретная очередь в программе сама по себе -- понятие эфемерное, формально она существует с момента своего создания до момента, когда она больше не используется в программе.

Очередь создаётся например, когда в неё (а на самом деле, в другую будущую, эфемерную очередь) добавляется новый элемент: операция выдаёт новую очередь взамен старой, которая сразу перестаёт существовать. По этой причине нельзя использовать одну и ту же очередь (условную переменную) в качестве входного объекта для нескольких операций. 

 F хранит список, в котором находится первая часть очереди, и R хранит список, в котором находится вторая часть очереди, перевёрнутая от конца к началу. Зачем? Так как добавление элементов осуществляется в хвост очереди, эта операция требует O(n) для списка, поэтому мы переворачиваем вторую часть очереди (список), чтобы добавлять новый элемент в голову этого списка за O(1), учитывая, что этот хвост весь перевёрнут. Удаление элемента из головы списка F также выполняется за константное время.

Однако как только очередь потребуется целиком где-то в программе, её надо будет представить в виде обычного списка. Для этого необходимо, во-первых, перевернуть список R, и во-вторых, добавить его к списку F: в новой очереди эта композиция запишется в F, а R станет пустым списком. Такая операция, понятно, требует уже совсем не константное время.

Если операции и использование очереди перемешаны (в любой момент может выполниться добавление в хвост, считывание из головы или запрос всей очереди для внешних операций), то средняя эффективность будет явно хуже константной. В то же время, если удастся разделить пакет операций обработки очереди (добавление и удаление элементов) и её внешний запрос в виде списка (а на практике так часто и бывает), то данная конструкция будет работать с эффективностью, близкой к константной, пока список F остаётся не пустым.

Более того, если аккуратно использовать списки различий, можно ещё существенно повысить эффективность такой реализации (когда, например, итоговое сцепление F с перевёрнутым R выполняется за константное время). 


27. Персистентные очереди и объекты

В ряде случаев бывают востребованы так называемые персистентные (persistent) структуры данных, для которых хранится история их изменения. Например, очередь исходно пуста, потом мы три раза добавляем элементы, затем два раза удаляем, и таким образом получаем одно текущее и четыре исторических состояния. Очередь, которая поддерживает одновременно такое множество состояний, называется персистентной.

Самый простой наивный способ -- хранить каждое состояние как отдельную очередь, и организовывать доступ к её содержимому в режиме "только чтение" (неизменяемая, immutable-очередь). Однако если в очереди много элементов (тысячи, миллионы, ...) и она быстро изменяется, такой подход ведения истории оказывается крайне неэффективным и в плане быстродействия, и в плане использования памяти. Поэтому были придуманы различные специальные алгоритмы ведения истории распространённых структур данных. 

Одна из известных проблем персистентных структур -- это неоднозначность их будущего, неоднозначность дальнейшего усложнения, которое начинает очень сильно зависеть от конкретной схемы работы со структурой, что делает затруднительным универсальный анализ учетных стоимостей. Можно конечно брать классическую наихудшую оценку, но она скорее всего будет сильно неэффективной и может существенно отличаться от реальной. Кроме того, персистентные структуры могут сильно разрастаться по критерию памяти, а работа сборщика мусора для них (ведение счётчиков ссылок на конкретные экземпляры в памяти) может стать ощутимо медленной. В некоторых случаях даже становится эффективнее обходить весь граф персистентной структуры в целом в поисках объектов, которые можно удалить из памяти. Вдобавок счётчики ссылок сами по себе по сути лишают систему иммутабельности. 



28. Деревья

Немного коснёмся такой не менее популярной структуры данных, как деревья, встречающиеся в огромном количестве проектов. Если список -- это всегда линейная структура, и за каждым его элементом следует более маленький список, то дерево -- это структура иерархическая. За каждым элементом дерева "следует" произвольное количество (начиная с нуля) более маленьких деревьев.

Подробно деревья, разновидностей коих существует множество, и алгоритмы работы с ними вы изучали на отдельном курсе.

Познакомимся с деревом как с рекурсивным типом данных в рамках декларативной модели.

Дерево состоит из элементов двух типов: листья (элементы дерева, у которых нету поддеревьев) и узлы, которые содержат одно или более деревьев (называемых поддеревья). Каждый элемент дерева независимо от типа также содержит некоторое значение, обычно называемое ключ. В деревьях не может быть замкнутых циклов связей.

Тип Tree -- это:
-- либо лист Leaf, хранящий значение Key;
-- либо узел, хранящий значение Key и 
        множество поддеревьев Tree1, Tree2, ..., TreeN.

В некоторых видах деревьев вводятся дополнительные типы узлов – например, левый и правый узел (поддерево) для двоичных деревьев.

Из такого рекурсивного определения достаточно легко, как описывалось выше, реализуются рекурсивные функции работы с деревьями. 



29. Эффективность по времени и памяти

Декларативное программирование -- это прежде всего программирование. Несмотря на то, что оно обладает сильными математическими свойствами, результатом его получаются всё те же реальные программы, которые работают на реальных компьютерах. Поэтому и тут важно думать о вычислительной эффективности (время и память). Эта тема затрагивалась на курсах по алгоритмам и структурам данных, где мы ориентировались на О-большое (наихудший случай).

На практике, из-за того, что программы работают на всё усложняющемся железе и используют весьма сложные возможности стандартных библиотек языка и операционной системы, виртуальные модели памяти и т. п., определить реальную производительность и требуемые ресурсы алгоритма без его привязки к контексту исполнения в общем случае становится почти невозможно. Поэтому применяется также амортизационный анализ (когда мы учитываем, что шагами алгоритма могут быть как "лёгкие" операции, так и весьма нагрузочные).

Декларативная модель в алгоритмическом плане -- одна из самых простых, поэтому оценивать эффективность декларативных алгоритмов достаточно легко. В частности, надо активно учитывать распространённость рекурсии, которая, как было показано, довольно часто на практике, при слабой реализации, требует существенных ресурсов по памяти (стек). Но прикладная (не математическая) оптимизация по памяти обычно выполняется значительно проще, нежели оптимизация по производительности. 

 Во-первых, в декларативной модели сам алгоритм, как мы видели, легче и по известным схемам переписывается в более экономный вид;

во-вторых, под очень многие задачи можно подобрать простую, экономную и хорошо изученную структуру данных (прежде всего из рассмотренных выше);

в-третьих, саму память можно оптимизировать, например, с помощью сборщиков мусора и алгоритмов сжатия, и т. д.

Однако оптимизированный код никогда не бывает "оптимальным" ни в каком математическом смысле. Обычно программа может быть легко улучшена, но лишь до некоторой точки, после чего отдача от её улучшений начинает уменьшаться, а сама программа быстро усложняется, и последующие улучшения дают ещё меньший эффект. Поэтому оптимизация не должна выполняться, если в ней нет явной необходимости.

Оптимизация имеет как хорошую, так и плохую сторону. Хорошая сторона в том, что в целом время выполнения большинства приложений в значительной степени определяется работой очень малой части кода программы. Поэтому оптимизация производительности при реальной необходимости почти всегда может быть ограничена переписыванием только этой маленькой части (иногда буквально нескольких строк).

Плохая сторона в том, что обычно не очевидно даже опытным программистам, где эта часть априори находится. Поэтому эта часть сперва должна быть идентифицирована в процессе работы программы -- как правило, с помощью технологии профилирования.

Оптимизировать (сократить) использование программой оперативной памяти обычно заметно проще, нежели сократить время её выполнения. Если память -- это критическая проблема, то хорошим приёмом будет использование алгоритмов сжатия данных, которые не участвуют в основных вычислениях. Тут придётся искать баланс между экономией пространства и повышением быстродействия. 


Программирование высшего порядка

Программирование высшего порядка представляет собой набор методов программирования, которые становятся доступными при использовании значений процедур в программах. Под значениями процедур понимается, во-первых, наличие в системе типа данных "процедура", и соответственно, во-вторых, любая реальная процедура, определённая в программе, автоматически становится значением (как число, строка, список), которое можно передавать в другие процедуры в качестве аргумента, или получать в качестве результата их работы.

Как правило, программирование высшего порядка связано с понятием лексического замыкания, когда функция существует в программе как объект и может обращаться к внешнему контенту (например, локальным переменным в текущем блоке).

Термин "высший порядок" происходит от концепции порядка процедуры. Процедура, все аргументы которой не являются процедурами, имеет нулевой порядок. Процедура, имеющая в аргументах хотя бы одну процедуру нулевого порядка, считается процедурой первого порядка.

И так далее: процедура имеет порядок n + 1, если у неё есть, по крайней мере, один аргумент порядка n и ни одного аргумента более высокого порядка.

По сути, программирование высшего порядка означает просто, что процедуры теперь могут быть любого порядка, а не только нулевого. 

 Существуют четыре основные операции, которые лежат в основе всех техник программирования высшего порядка:

1) Процедурная абстракция: способность преобразовывать любую программную логику в значение процедуры.

2) Обобщение (Genericity): возможность передавать значения процедур в качестве аргументов при вызове другой процедуры.

3) Инстанцирование: возможность возврата процедурного значения как результата вызова процедуры.

4) Встраивание: возможность помещать значения процедур в структуры данных. 



30. Процедурная абстракция

Процедурная абстракция подразумевает, что мы "упаковываем" инструкции в процедуру, помещая их внутрь заголовка процедуры, и получаем конструкцию (определение процедуры), которая сама по себе не выполняется, но считается процедурным значением (замыканием).

Выполнение процедуры даёт точно такой же результат, как и выполнение команд из её тела. Фактически процедура имеет смысл отложенного выполнения инструкций.

У процедурных значений имеются параметры, которые влияют на работу тела процедуры.

Процедурная абстракция чрезвычайно сильна. Она лежит в основе парадигмы программирования высших порядков, сегодня поддерживаемой многими популярными языками, и даже в основе объектно-ориентированного программирования, и поэтому чрезвычайно полезна для построения программистских абстракций.

Ряд старых императивных языков поддерживает ограниченную форму процедурной абстракции. Процедуры в них либо все глобальны (не могут быть вложены друг в друга), либо видны только в пределах своего файла, что не позволяет полноценно применять программирование высших порядков, а из-за того, что замыкания реализованы неполноценно, наличие локальных переменных внутри процедур нередко приводит к висячим ссылкам, и к багам, когда программа становится достаточно крупной. 



31. Обобщения

Сделать функцию "общей" -- значит, позволить любой конкретной сущности (т.е. любой операции или значению) становиться аргументом в теле функции. Такая сущность абстрагируется от функционального тела, а конкретно задается, когда функция вызывается непосредственно. Каждый раз при вызове функции может быть задана другая сущность.

Например:

function SumList(Ls)
    if Ls == []
        return 0
    end

    head = Ls[1]
    tail = Ls[2:end]
    return head + SumList(tail)
end

println(SumList([1,5,3,7,9]))

В функции SumList имеется нейтральный элемент 0, не влияющий на результат, и операция "+", которые можно обобщить до любого нейтрального элемента и любой операции (функции с двумя аргументами).

function FoldR(Ls, F, U)
    if Ls == []
        return U
    end

    head = Ls[1]
    tail = Ls[2:end]
    return F(head, FoldR(tail, F, U))
end

function Plus(x, y)
    return x+y
end

function Mul(x, y)
    return x*y
end

println(FoldR([1,5,3,7,9], Plus, 0))
println(FoldR([1,5,3,7,9], Mul, 1))

Функция FoldR обобщила исходный код суммирования до универсального: она получает в дополнение к списку саму операцию (функцию F) и нейтральный элемент U, и теперь мы можем использовать её для всех похожих ассоциативных вычислений (когда порядок аргументов функции F не важен для её результата).

FoldR -- функция с таким названием существует во многих языках функционального программирования. Это функция-свёртка, а буква R в её конце означает правую ассоциацию – схема её вызовов развёртывается в цепочку, пока не будет достигнуто самое крайнее (правое) значение в списке, после чего начнутся непосредственные вычисления. 

 FoldR часто используется для универсальной обработки списков. Например, создадим функцию, которая возвращает true, если хотя бы один элемент списка – true.

function tru(x, y)
    return x || y
end

function Some(L)
    return FoldR(L, tru, false)
end

println(Some([false,false,false,true]))

FoldR – это пример абстракции цикла (рассматривается далее). 



32. Инстанцирование

Инстанцирование (возможность возврата процедурного значения как результата вызова процедуры) реализуется как правило с помощью так называемых фабрик или генераторов функций.
Прямая возможность "производить" функцию поддерживается далеко не во всех языках, хотя и существуют различные обходные пути для этого.

Например, есть универсальная функция сортировки списка, когда конкретный алгоритм сортировки ("реализацию") мы передаём в такую функцию-фабрику, и получаем на выходе функцию, применяющую нужный алгоритм сортировки. Таким образом мы можем на лету менять реализацию, выбирать более продуктивные схемы сортировки под конкретную задачу, и при этом обходиться без довольно сложных и неочевидных паттернов императивно-объектного проектирования.

function FactoryOp(Op)
    function inner(x,y)
        return Op(x,y)
    end
end

function Add(a,b)
    return a+b
end

f = FactoryOp(Add) # f - это функция, созданная "на лету"

println( f(2,3) )


33. Встраивание

Встраивание -- это техника, когда мы не формируем полную структуру данных за один раз, при обращении к любому её элементу, а строим её постепенно, по мере запросов, как бы "встраивая" внутрь неё программный код, генерирующий нужные данные.

Например, если требуется список из миллиона линейно увеличивающихся чисел, и запрашивается самый первый элемент, то достаточно сгенерировать список только из этого одного элемента. Такая схема вычислений называется ленивой в противоположность жадной, когда сразу вычисляется всё. 


Абстракция цикла

Как мы видели, циклы в декларативной модели как правило многословны, потому что им нужны явные рекурсивные вызовы. Эти рекурсивные петли можно сделать более лаконичными и универсальными, определяя их в виде абстракций. Существует много различных видов циклов, которые мы можем определить в декларативной модели.

В этом разделе мы сначала определим простые циклы в духе классических "for" в императивном программировании -- для работы с целыми числами и списками, а затем добавим к ним аккумуляторы, чтобы сделать их более полезными. 


33. Целочисленный цикл

Классический цикл For получает четыре параметра: начальное и конечное значения цикла и шаг, и процедуру P, которая должна быть применена к каждому значению условного "счётчика" цикла.

function For(A, B, S, P)
   if A > B
      return
   end 
   P(A)
   For(A+S, B, S, P)   
end

For(1,10,3,println) # печать значений 1,4,7,10


34. Цикл по спискам

Цикл ForAll получает список и некоторую процедуру, которую применяет к каждому элементу списка.

function ForAll(Ls, P)
    if Ls == []
       return
    end
    head = Ls[1]
    tail = Ls[2:end]
    P(head)
    ForAll(tail, P)
end

ForAll([3,2,1],println) # печать каждого элемента списка [3,2,1]


35. Цикл с аккумулятором

Циклы For и ForAll сами по себе довольно бесполезны, если требуется не просто вывести данные, а выполнить над ними какие-либо вычисления (например, просуммировать элементы списка или целые значения в диапазоне). В декларативной модели циклы расширяются концепцией аккумулятора, который накапливает промежуточное значение.

Цикл для диапазона с шагом:

function ForAcc(A, B, S, P, Acc)
   if A > B
      return Acc
   end 
   Acc = P(Acc, A)
   ForAcc(A+S, B, S, P, Acc)   
end

function Sum(x,y)
  return x + y
end

# суммирование всех значении в диапазоне
println( ForAcc(1,5,1,Sum,0) ) 

 Цикл для обработки списков:

function ForAllAcc(Ls, P, Acc)
    if Ls == []
       return Acc
    end
    head = Ls[1]
    tail = Ls[2:end]
    Acc = P(Acc, head)
    ForAllAcc(tail, P, Acc)
end

function Sum(x,y)
  return x + y
end

println( ForAllAcc([3,2,1],Sum, 0) ) # сумма всех элементов списка

Этот итеративный способ по сути работает как FoldL -- аналог FoldR, только с левой ассоциацией, когда мы не раскручиваем цепочку вычислений до конца, а вычисляем значения сразу, непосредственно начиная с самого левого элемента.

На самом деле, и FoldR – это тоже по сути цикл с аккумулятором, только аккумулятор там скрытый, добавляется компилятором. 


36. Свёртка списка и дополнительные способы поддержки циклов

Существует ещё одна схема цикла с аккумулятором для списка. Свёртка (folding) фактически означает, что мы "вставляем" операцию между значениями списка:

"+" [1,2,3] = 1 + 2 + 3

Способ вычисления такой конструкции отдаётся компилятору, что позволяет достигать хорошей производительности -- например, за счёт распараллеливания.

В языках программирования, в том числе и декларативных, могут реализовываться самые разные лингвистические способы поддержки циклов. Классическая запись цикла
for заголовок тело
по сути эквивалентна схеме, когда тело выделяется в отдельную процедуру, и она многократно вызывается, получая в качестве параметра счётчик цикла.

Однако имеется фундаментальное различие между декларативным и императивным определениями циклов. В последнем случае счетчик циклов -- изменяемая переменная, которой присваивается разное значение для каждой итерации. Декларативный цикл совершенно другой: на каждой итерации он фактически объявляет новую переменную, хотя обращение к ней происходит по одному и тому же идентификатору. Такая разница даёт серьёзные последствия.

В частности, итерации декларативного цикла полностью независимы от друг друга -- таким образом, их можно выполнять одновременно, не меняя окончательный результат работы цикла. А так как никаких состояний в смысле классических переменных в декларативной модели нету, то и не возникают типовые проблемы конкуренции, которые мы изучали на первом курсе по парадигмам программирования.

А вот сделать так в императивном цикле практически невозможно: внутри каждой итерации больше нельзя быть уверенным, что она получает доступ к правильному значению счётчика цикла, если попытаться выполнять все итерации одновременно.

Аналогично во многих языках программирования имеется синтаксическая версия итерации по спискам -- например, цикл foreach, а что касается свёртки списка, то в стандартные библиотеки часто включаются функции map/reduce, выполняющие вычисления по свёртке и foldL/R.

В декларативной схеме цикла возможны конечно ещё многие другие дополнительные расширения. Например: немедленный выход из цикла (break), немедленный выход и возврат явного результата (return), немедленное выполнение следующей итерации (continue), итераторы по спискам наподобие foreach, и другие процедуры, "подразумевающие" цикл (нахождение суммы элементов списка, максимальное значение в списке и т. п.). 




Программирование, управляемое данными
(Data-driven)

Частой и даже универсальной задачей считается выполнение некоторой операции над структурой данных (на практике достаточно большой), итерация или обход этой структуры и вычисление некоторой другой структуры данных на основе такого обхода.
Эта схема чаще всего применяется к спискам и деревьям. Для списков обычно применяются операции FoldR и FoldL, есть и другие типовые техники.

Классическая универсальная операция над списками – это Map, которая вычисляет новый список такого же размера, как и исходный, применяя заданную функцию к каждому его элементу. Реализация Map имеется практически во всех популярных языках программирования, в Julia например она называется map().

Допустим, мы хотим округлить с помощью функции round() все значения в списке:

map(round, [1.2, 3.5, 1.7]) # [1.0, 4.0, 2.0]


37. Map/Filter/Reduce

Реализация Map с помощью программирования высшего порядка может быть, например, такой:

function Map(Ls, F)

  function IterMap(Rs, Ys, F)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    return IterMap(push!(Rs,F(head)), tail, F)
  end

  return IterMap([], Ls, F)
end

function Square(x)
    return x*x
end

Map([1,5,3,7,9], Square) # [1, 25, 9, 49, 81]



38. Filter

Другая универсальная операция над списками – это Filter, которая формирует новый список, в который включаются только те элементы исходного списка, которые соответствуют некоторому предикату. В Julia она называется filter().

Например, мы хотим выделить из исходного списка [1,2,3,4,5,6,7] только нечётные элементы; стандартная функция-предикат isodd() возвращает true, если её аргумент нечётный.

filter(isodd, [1,2,3,4,5,6,7]) # [1, 3, 5, 7]

Наша релизация Filter() может быть такой:

function Filter(Ls, F)

  function IterFilter(Rs, Ys, F)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    if F(head)
       return IterFilter(push!(Rs,head), tail, F)
    else
       return IterFilter(Rs, tail, F)
    end
  end

  return IterFilter([], Ls, F)
end

Filter([1,2,3,4,5,6,7], isodd) # [1, 3, 5, 7]



39. Fold/Reduce

Как уже отмечалось, FoldR и FoldL (свёртка folding в мэйнстриме часто называется reduce) работают как цикл for с аккумулятором, однако мы можем выразить его через универсальный итератор Iterate, который мы изучали ранее:

function Iterate(S, IsDone, Transform)
  if IsDone(S)
     return S
  end 

  S = Transform(S)
  return Iterate(S, IsDone, Transform) 
end

function is_done(Ls)
  return length(Ls) == 1
end

function transform(Ls)
  S1 = [Ls[1] * Ls[2]; Ls[3:end]] 
  return S1 
end

function FoldL(Ls, F, U)
    if Ls == []
       return []
    end
    if is_done(Ls)
       return Ls[1]
    end

    return Iterate(Ls, is_done, F)
end

println(FoldL([1,5,3,7,9], transform, 1))

На самом деле, Iterate -- это универсальная абстракция while-цикла с аккумулятором. Все абстракции цикла могут быть выражены через этот итератор. 



Деревья

Общая операция для дерева, как упоминалось выше – это обход всех его узлов в некотором заданном порядке, и выполнение некоторой операции над каждым узлом (в частности, при его посещении во время обхода). Например, если это абстрактное синтаксическое дерево, то при его обходе можно сразу генерировать результирующий программный код.

Стандартная процедура обхода дерева DFS (depth-first search) очень проста: находясь в некотором узле, мы последовательно вызываем DFS для каждого из его дочерних узлов. Сама по себе она не очень полезна, так как ничего не вычисляет. Можно например её использовать для вывода дерева на печать, но для какого-то реального применения потребуется версия DFS с аккумулятором.

В таком случае появятся три версии DFS:
– сверху вниз (результат накапливается по мере движения от родительских узлов к дочерним, это по сути FoldL),
- снизу вверх (результат накапливается при подъеме от дочерних узлов, когда мы рекурсивно спустились к ним, обратно к родителям, это по сути FoldR),
- или в каком-то другом порядке (например, по уровням дерева). 



40. Явное ленивое оценивание

Во многих современных языках программирования применяется встроенная стратегия "вычисления" кода, называемая ленивое оценивание или ленивое исполнение, которое немного упоминалось раньше. Скрытое ленивое оценивание практически всегда связано с параллельным выполнением, а вот явное ленивое оценивание хорошо реализуется с помощью программирования высшего порядка.

Ленивое исполнение/оценивание подразумевает, что некоторая структура данных (например, список) формируется последовательно. Например, очередной элемент списка "готовится" непосредственно в тот момент, когда он реально потребовался в каких-то вычислениях. При этом вполне возможна ситуация, когда например элементы списка с миллионом объектов вообще не будут востребованы, или будут востребовано лишь малое их количество, что позволит сэкономить много ресурсов. Это так называемое вычисление/исполнение по запросу.
Классическая же реализация предполагает, что все структуры данных к моменту начала программы полностью сформированы независимо от того, будут ли они вообще востребованы.

Реализация ленивого исполнения подразумевает наличие некоторого механизма запроса нового элемента. Назовём такой механизм триггером. Есть два способа выразить триггеры в декларативной модели: переменные dataflow (используются в декларативном параллелизме, который мы немного рассматривали во вступительных статьях), и программирование высшего порядка. Во втором случае триггером выступает функция, которая возвращает пару значений: элемент списка и новую функцию. Новая функция – это новый триггер: вызов её даёт следующий элемент данных и следующую новую функцию, и так далее. 


41. Карринг (Currying)

Эта техника упрощает программы, где активно применяется программирование высшего порядка. Идея карринга – записать одну функцию с n параметрами как n функций с одним параметром.

Напрямую в Julia отсутствует карринг (а во многих функциональных языках Haskell, OCaml и др. все функции по умолчанию каррированы), и в декларативной модели в целом какой-либо специальной его поддержки нету. Но интенсивное применение программирования высшего порядка на практике обычно подразумевает поддержку карринга.

Например можно установить поддерживающий карринг в Julia пакет Currier. Перейдите в менеджер пакетов Pkg (запустите командную строку Julia и нажмите "]") и введите

add https://github.com/MasonProtter/Currier.jl

Пример использования пакета Currier:

using Currier

@curried function foo(x, y, z)
    return x + y + z
end

a = foo(1, 2, 4) # 7
a = foo(1)(2)(4) # 7

f = foo(1)(2) # f – функция с одним параметром
a = f(4) # 7

f = foo(1) # f - функция с двумя параметрами
a = f(2)(4) # 7



42. Абстрактные типы данных (АТД)

Вы, возможно, уже хорошо познакомились с АТД на практике, на моих курсах по ООАП. Напомню, что АТД -- это описание структуры данных исключительно в терминах операций над ней. Внутренняя реализация (включая любые атрибуты типа) полностью скрыта в АТД, ну или точнее, она просто отсутствует. Ближе всего к АТД в программировании понятие интерфейса или абстрактного класса.

Рассмотрим теперь АТД с точки зрения декларативной парадигмы – что же они собой представляют?

Тип данных, или просто тип – это множество значений, с которым связано множество допустимых операций над этими значениями. В декларативной модели имеется предопределённый набор базовых типов, которые мы изучали ранее. В дополнение к ним разработчик может свободно определять новые типы.

Тип называется абстрактным, если он полностью определён своим множеством операций и при этом полностью независим от реализации. Это значит, что всегда можно менять его текущую реализацию, не меняя сам АТД (как интерфейс в программировании). 


Декларативный стек

АТД Stack<T> (стек, содержащий элементы типа T) может быть описан четырьмя операциями (функциями):
-- NewStack() – создать новый стек;
-- Push(Stack s, T elem) – втолкнуть элемент elem в стек s;
-- Pop(Stack s) – вытолкнуть элемент из стека s;
-- T Peek(Stack s) – получить верхний элемент стека s, не меняя сам стек;
-- IsEmpty(Stack s) – булева проверка, пустой ли стек s.

Попытка вытолкнуть элемент из пустого стека вызовет ошибку (исключение).

Важный момент: первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов. Таким образом, мы можем выстраивать целые конвейеры таких функций, которые передают друг другу промежуточные результаты (стеки), и порядок обработки данных при этом становится весьма нагляден и последователен.

Реализовывать этот набор функций мы можем самими разными схемами, при этом оригинальный АТД Stack остаётся неизменным. 


Защита АТД

Однако лёгкая сменяемость имплементаций АТД несёт в себе определённую опасность. В частности, далеко не всегда хорошо делать реализацию открытой и видимой для всех. Пока предложенная модель стека может легко дополняться любым разработчиком, который может создавать новые операции над стеком, так как его реализация открыта и доступна.

Но на практике это приводит к двум серьёзным проблемам:

1) Программу становится гораздо сложнее развивать и сопровождать. Например, мы хотим повысить эффективность АТД Словарь, заменив его реализацию на основе списков реализацией на основе деревьев. В таком случае придётся прочесать весь код программы для выяснения, какие её части зависят от реализации Словаря на основе списка.
Кроме того, если в каких-то частях программы в реализации некоторого АТД имеются ошибки, то в процессе их исправления вполне могут возникать правки и в самом АТД, что в свою очередь загрязнит другие части программы.

2) Программа становится подверженной потенциально вредоносному вмешательству. Это более тонкая проблема, связанная с безопасностью. Она возникает в основном с открытыми программами, которыми пользуется много людей. Под открытой программой будем понимать программу, взаимодействующую с такими другими программами, которые «доступны» только в рантайме, например через API (нету доступа к их исходным текстам). Но что получится, если другая программа вредоносна, и захочет нарушить выполнение открытой программы? 

 Базовый принцип решения упомянутых проблем – защитить конкретные реализации АТД от неавторизованного вмешательства. Внутренняя реализация, "вычислитель" значений, помещается внутрь некоторой границы защиты.

Есть два способа использования такой границы:

1) Стационарное значение. Значение никогда не выходит за границы. Чётко определенный и задокументированный набор операций фактически и становится такой границей. Схема вычислений остаётся внутри границ.

2) Мобильное значение. Значение, вычисленное реализацией, может покинуть границу, и затем снова вернуться обратно. Когда оно снаружи, с ним можно работать внешнему коду. Определённым операциям с соответствующего разрешения допускается вывести значение за границу, вычислить на его основе новое значение, и результат вернуть обратно внутрь границы.

В каждом из этих случаев достаточно лишь посмотреть на реализацию операций АТД. Классический пример первого случая -- цифровой банкинг. У каждого клиента имеется счёт с некоторой суммой денег. Клиент может совершить операцию по переводу денег со своего счёта на другой счет. Но так как клиенты никогда на самом деле не приходят физически в банк, то и физические деньги банк не покидают. 

 Второй пример – сейф или банковская ячейка. Он хранит деньги и может быть открыт клиентами, у которых есть ключ. Каждый клиент может забрать деньги из сейфа, или положить их в него. Выйдя из банка, клиент может отдать деньги другому клиенту. Но когда деньги в сейфе, они в безопасности.

Этот способ -- самый простой для понимания в рамках декларативной модели. Авторизация, требуемая для преодоления границы защиты, и есть своего рода "ключ". Мы добавляем его как новое понятие к декларативной модели, и называем «имя».

Но для этого декларативную модель требуется расширить. Во-первых, потребуется защитить значения, и во-вторых, потребуется защитить несвязанные декларативные переменные.

Один из возможных подходов – создать операции-«обёртки» с «ключом» доступа. Доступ к внутреннему представлению некоторой структуры данных становится возможен только тем, у кого имеется такой специальный ключ. С его помощью можно создавать «обёртки» и взаимодействовать с другими «обёртками» с таким же ключом. 

 Рассмотрим пример создания "обёртки" с ключом. Пусть имеется некоторый тип Name («имя»), хранящий атомарное значение. Для него не определены операции вывода на экран и преобразования в число или строку. Всё, что можно делать с типом Name – это создавать новые экземпляры (операция NewName), и сравнивать их с другими значениями типа Name с помощью == .

Операция создания нового «имени» NewName гарантирует, что результирующее значение уникально в программе. Однако тут необходимо отметить, что эта операция не декларативна: вызывав её дважды, мы получим разные результаты (что подразумевает, что у этой операции имеется внутренняя память, которая хранит некоторое состояние, гарантирующее уникальность очередного имени). Однако если мы применяем NewName исключительно для создания безопасного АТД, это не проблема – получившийся АТД останется декларативным.

Теперь с помощью NewName мы можем создавать уникальные ключи в программе, и при этом не имеется никакой возможности выяснить их значение и как-то нарушить границы безопасности. Сравнение тут не поможет, так как NewName гарантированно выдаёт только уникальные значения, и нету никакой другой возможности создать экземпляр типа Name.

Как эта схема применяется на практике? Например, мы реализовали АТД Stack внутри как обычный список.

S = NewStack()

Мы знаем, что S – это стек с известным набором операций, но не имеем прямого доступа к его физическому содержимому в виде списка (в рамках декларативной модели, а не в конкретном языке программирования).

Создадим в программе ключ доступа к Stack:

StackKey = NewName()

Теперь можно определить функцию GetStackInternal(), которая получает на вход стек и ключ, и либо возвращает список-реализацию стека, если ключ-параметр совпадает с ключом StackKey, либо не делает ничего. 


Обёртка как АТД

Подобная схема при создании безопасных АТД может применяться часто, поэтому она сама, в свою очередь, напрашивается быть выделенной в абстрактную «обёртку». Сделать это лучше тоже с помощью АТД, который будет иметь две операции: Wrap и Unwrap. Ключ генерируется скрыто в «конструкторе» АТД.

Операция Wrap, получая на вход некоторое значение, возвращает функцию, которая требует наличия ключа при своём вызове, и только тогда возвращает «хранимое» в ней значение.

Операция Unwrap получает на вход подобную функцию, передаёт ей скрытый ключ, и возвращает, соответственно, снова незащищённое значение.

Например, имеем незащищённый список S:

S = [1, 2, 3]

Получим его защищённую версию:

SecS = Wrap(S)

Теперь, просто обратившись напрямую к SecS (это уже не значение, а функция), мы ничего не получим.

Обратно вернуть открытое значение можно так:

S1 = Unwrap(SecS)

Wrap и Unwrap -- это операции, которые вызываются внутри других операций АТД, за его границами они недоступны. 

 Защищенная версия стека SecureStack, где в качестве реализации применяется список, может выглядеть так:

-- NewStack() возвращает Wrap( [ ] ) – защищённый пустой список.

-- Push(Stack s, T elem) делает Unwrap(s), добавляет в хвост (или голову, в зависимости от того, что считаем вершиной стека) получившемуся списку elem, и затем выполняет Wrap() для нового списка, что и возвращает.

-- Pop(Stack s) делает Unwrap(s), удаляет элемент из хвоста получившегося списка, и затем выполняет Wrap() для нового списка, и возвращает защищённый результат.

-- Peek(Stack s) делает Unwrap(s) и возвращает элемент из хвоста списка.

-- IsEmpty(Stack s) делает Unwrap(s) и проверяет, не пустой ли список.

Обе операции Wrap и Unwrap скрыты внутри реализации АТД, поэтому нету абсолютно никакой возможности получить доступ к его содержимому. 



Защита несвязанных переменных

Сами значения мы защитили с помощью операций-обёрток, что же делать с несвязанными переменными -- ведь, имея соответствующую ссылку, кто угодно может связать их со значением. Один вариант решения – разрешать только считывать значение переменных, но не выполнять их связывание. Для этого декларативная модель расширяется условной операцией !! , которая, получая имя переменной, возвращает её некоторый «образ», допускающий лишь считывание значения.

В частности, в этих целях создаётся дополнительное так называемое read-only хранилище. Операция связывания значения с переменной модифицируется так, что предварительно проверяется, не находится ли переменная в read-only хранилище – и если она там имеется, то тогда связывание блокируется. 

 Как уже говорилось, операция создания нового «имени» NewName не декларативна.

Как же гарантировать, что некоторое имя в реализации декларативной модели будет уникальным? Если все программы выполняются в одном процессе, то можно, например, просто использовать последовательные целые числа. Однако в открытом мире такая схема не сработает.

1. Централизованный подход. Где-то в открытом мире есть единственная фабрика имён, и чтобы получить оригинальное имя, необходимо отправить сообщение этой фабрике и получить ответ с новым именем. Физически фабрика может быть рассредоточена по многим компьютерам (как в случае организации IP-протокола с уникальными IP-адресами для каждого компьютера в мире, который подключен к Интернету). Можно, в частности, дополнить IP-адрес компьютера, запросившего имя, временным идентификатором высокого разрешения (микросекунды), добавляющим к адресу время создания нового имени. Это даст уникальную константу.

2. Децентрализованный подход. Генерируем имя как набор (вектор) случайных битов, а сам алгоритм генерации должен зависеть от некоторой случайной внешней информации, чтобы разные компьютеры не генерировали один и тот же набор. Если такой вектор будет достаточно длинный, то можно добиться очень высокой вероятности того, что имена на основе этих векторов будут уникальны. Теоретически, вероятность неуникальности имени всегда будет ненулевая, но на практике эта техника работает хорошо. 



44. "Недекларативщина"

Декларативное программирование благодаря своему "чисто функциональному" взгляду на программирование несколько оторвано от реального мира, в котором сущности имеют память (состояние) и могут развиваться независимо и проактивно (параллельно). Чтобы связать декларативную программу с реальным миром, необходимо её дополнить некоторыми не совсем декларативными операциями.

Одни из наиболее востребованных классов таких операций -- это файловый ввод/вывод и графические интерфейсы пользователя. На самом деле такие недекларативные операции укладываются в более общие вычислительные модели, нежели декларативные -- в частности stateful- (например, императивные) и параллельные модели.

Простой способ стыковки декларативного программирования с реальным миром -- это использование файлов. В общем случае файл представляет собой последовательность значений, которые хранятся вне запущенной программы на постоянном носителе информации, например, на жёстком диске. В декларативной модели файл, открытый на чтение, может представляться, например, как список, и обрабатываться итератором. Операция, модифицирующая файл, может работать так, словно она получает на вход старый файл, и создаёт новый файл, хотя физически он на диске остаётся всё тот же.

А прямой способ взаимодействия программ с человеком через графический интерфейс пользователя (GUI) в декларативной модели продуктивно реализуется через определения GUI с помощью компактных и преимущественно декларативных спецификаций -- с помощью описательного декларативного языка. 


Проектирование программ

Мы познакомились с различными методами программирования в декларативной модели, и следующим логическим шагом будет их использование для создания реальных программ. Этот шаг называется проектированием (design) программ. Он начинается с формулировки проблемы или задачи, которую надо решить/реализовать. Как правило, эта формулировка делается словами, и часто далеко не точно и не без противоречий. Проектирование даёт нам высокоуровневую структуру программы: какие программистские техники мы будем использовать, и как они будут связаны между собой, и как в конечном итоге будет получена полная программа, которая решает исходную проблему.

При проектировании программ надо учитывать важное классическое различие между "программированием в малом" (programming in small) и "программированием в большом" (programming in large). В зависимости от подхода полученные программы можно называть "маленькие программы" и "большие программы". Однако данное различие не имеет ничего общего с размером/объёмом программы – прежде всего оно определяет, сколько людей было задействовано в её разработке.

Маленькие программы пишутся одним человеком за относительно короткий промежуток времени. Большие программы пишутся двумя и большим количеством людей или в течение длительного периода времени. Дело в том, что один и тот же человек-разработчик «сегодня» и «через год» рассматривается в программной инженерии как два разных разработчика, так как человек за год забудет много важных деталей.

Впрочем, существует и другое разделение programming in small / large: small подразумевает прежде всего кодирование, написание ясного, чистого, продуктивного кода; а large -- это прежде всего про правильное проектирование, которое действительно становится крайне актуальным, едва программа становится более-менее большой (начиная с нескольких тысяч строк кода). 



45. Методология проектирования в малом/in small

Возникла ситуация, когда требуется в одиночку разработать относительно небольшую программу (ориентировочный объём – до единичных десятков тысяч строк). Рекомендуется следующая простая методика проектирования, в которой смешаны творческий подход и формальное мышление:

1) Неформальная спецификация. Мы начинаем с того, что записываем как можно точнее, что должна делать программа: что она будет получать на вход, что должна выдавать на выходе, и каким образом выходные данные соотносятся с входными. Такое описание называется неформальная спецификация (в мэйнстриме она часто называется техническим заданием). Несмотря на то, что она будет, как мы рассчитываем, точна как только можно, мы называем ее "неформальной", потому что она будет написана на обычном русском языке. "Формальные" спецификации записываются в математической нотации.

2) Примеры. Чтобы ещё больше прояснить спецификацию, всегда хорошо и полезно представить примеры того, что делает программа в конкретных случаях (лучше всего в формате тестов). Эти примеры должны, во-первых, показывать «границы» программы (проверять её работу в граничных условиях и самыми неожиданными способами, которые мы можем себе представить), и во-вторых, демонстрировать типовые сценарии её эксплуатации.

3) Исследование. Чтобы выяснить, какие конкретно методы программирования нам подойдут лучше всего, хороший способ -- использовать интерактивный интерфейс для экспериментов с фрагментами программы. Идея состоит в том, чтобы написать небольшие достаточно автономные операции, которые, как мы думаем, буду необходимы нашей программе. Эти операции достаточно наглядны и обеспечивают некоторый системный базис программы. Этот шаг дает нам более чёткое представление о том, что представляет собой структура нашей программы. 

 4) Структура и реализация. Теперь мы можем сформировать структуру программы: делаем приблизительный набросок операций, необходимых для расчета результатов, получаемых на входе, и способы, которыми эти операции будут комбинироваться друг с другом. Затем мы заполняем оставшиеся пробелы, добавляя реальный код. Операции должны быть простыми: каждая операция должна делать только одну вещь. Для улучшения структуры мы группируем связанные операции в модули.

5) Тестирование и обдумывание. Наконец, мы должны убедиться, что наша программа работает правильно. Мы проверяем её на серии тестовых случаев, включая примеры, которые мы придумали раньше. Мы исправляем ошибки до тех пор, пока программа не заработает хорошо. Мы также можем порассуждать о структуре программы и о её сложности, используя формальную семантику для непонятных частей. Тестирование и обдумывание взаимодополняемы: важно делать и то, и другое, чтобы получить качественную программу.

Как видите, подход программирования в малом весьма простой. Перечисленные шаги не являются обязательными, они скорее служат вдохновляющей схемой для разработчика. Не стесняйтесь адаптировать их к своим конкретным обстоятельствам. Например, на любом шаге может появиться понимание того, что надо внести определённые коррективы в предыдущие шаги, в частности, в спецификацию. Пока разработчик один, код пишется аккуратно и его не очень много, такие итерации не вызывают особых проблем. Однако, никогда не забывайте о самом важном шаге в процессе programming in small -- тестировании. В частности, полезно сразу применять какую-нибудь конкретную методику, тесно связанную с тестами, например, TDD. 


Пример подхода programming in small

Имеется простое рабочее задание для программиста-стажёра:

Напишите функцию, которая получает в качестве аргумента имя файла, содержащего текст книги, и затем выводит на экран список пар, где каждая пара состоит из слова и целого числа, показывающего количество раз, сколько это слово встречается в файле.

Достаточно ли точна эта спецификация? Надо ли выводить результат в отсортированном порядке? В каком именно? Что понимается под "словом", как слова отделяются друг от друга? Надо ли учитывать разные кодировки (не ASCII), надо ли учитывать в качестве разделителей знаки препинания, или символы табуляции? Что, если файл в двоичном формате? Что должно быть выведено, если файл пустой или сбойный?

Мы обращаемся к заказчику (или старшему программисту), который нехотя уточняет: считайте словом непрерывную последовательность из английских букв и цифр (хотя, скорее всего, понадобится также учитывать и дефис, и символ подчёркивания).

В данной ситуации хорошо помогли бы примеры, но, как часто бывает, их нету.

Хорошо, следующий шаг -- проектирование структуры программы, как минимум, предварительное обдумывание её в уме, абсолютно обязательно -- физически не перед экраном компьютера. Применим схему организации функций как конвейера, что мы делали при создании декларативного стека: сначала функция читает файл в виде списка символов, затем преобразовывает список символов в список слов.

Важный момент, что восприятие файла как списка строк – слабая абстракция, так как каждую строку придётся вводить и обрабатывать отдельно, что добавляет ненужную сложность. Правильнее воспринимать файл как непрерывный поток символов.

По мере того, как последовательно выделяются слова, надо накапливать по ним статистику. Для этого нужна структура данных, которая позволяет использовать слова как индексы или ключи – стандартный словарь хорошо подойдёт.

Далее мы делаем тесты, готовим несколько файлов с тестовыми данными, статистика по словам которых собрана вручную, и особо проверяем непонятные или нечёткие случаи, чтобы в случае чего быстро их исправить и проверить.

Такая схема в общем и целом близка практической работе программиста над небольшими проектами. В ней нету никаких сложных моментов, главное:
- обеспечивать адекватность спецификации, не допуская по возможности неоднозначных мест, которые потом могут серьёзно усложнить доработку,
- сохранять ясность и выразительность кода, чтобы он был легко понятен и самому разработчику, и другим людям,
- поддерживать хорошее множество тестов, покрывающих как спецификацию (словесное описание задания), так и реализацию (код). 



46. Правильная организация программы

Что такое правильная организация программы? Можно написать программу как один большой монолит, но по мере роста объёма он начинает стремительно запутываться. Лучший способ борьбы с растущей сложностью – разделить (декомпозировать) программу на логические единицы, каждая из которых реализует набор операций, каким-то образом связанный в одно целое (хороший подход – через абстрактные типы данных).

Каждая логическая единица имеет две части: интерфейс и реализацию. Только один интерфейс «виден» снаружи логического блока, а реализации могут свободно заменяться.

При таком подходе программа представляется направленным графом без циклов, где ребро между двумя логическими единицами означает, что первая нуждается во второй для своей реализации. В мэйнстриме такие логические единицы называют "модули" или "компоненты", хотя точных определений этих слов обычно не даётся. На данном курсе мы выясняем, какие тут существуют основные понятия и как их можно применять для создания небольших декларативных программ. Аналогичная тема в разрезе programming in large рассматривается на следующих курсах. 



Модули и функторы

Мы называем модулем часть программы, которая группирует связанные по смыслу операции в одну сущность, которая имеет интерфейс и реализацию. В декларативной модели модули могут быть внедрены простым способом:
- Интерфейс модуля представляет собой запись, которая группирует связанные сущности (как правило, процедуры и функции, но в целом разрешено всё, включая классы, объекты, и тому подобное);
- Реализация модуля представляет собой набор языковых сущностей, которые доступны через интерфейс, а всё остальное снаружи недоступно. Реализация скрыта с помощью лексической видимости.

Спецификации модулей будем рассматривать как сущности, отличные от самих модулей. Спецификация модуля -- это вид шаблона, который создает новый модуль (как класс «создаёт» объект в ООП). Спецификация модуля иногда называется программным компонентом, но к сожалению, термин " программный компонент" широко используется в программировании для обозначения множества самых разнообразных понятий. Поэтому спецификацию модуля мы будем называть функтор.
Функтор – это функция, получающая на вход набор модулей, которые требуются для создания нового модуля, и возвращает новый созданный модуль.

Строго говоря, функтор получает на вход интерфейсы модулей как аргументы, создаёт новый модуль и возвращает его интерфейс. 

 Функтор состоит из трёх частей:
- импорт, задающий перечень требуемых модулей;
- экспорт, определяющий интерфейс итогового модуля;
- реализация, включающая код инициализации функтора.

В терминах программной инженерии, программный компонент – это элемент для независимого развёртывания (не требующий ничего дополнительного для своей установки и использования, кроме, возможно, перечня стандартных библиотек). Главное, что программный компонент не имеет внутреннего состояния, поэтому хорошо укладывается в декларативную модель.

Функторы можно считать одним из видов программных компонентов; тогда модулем будет экземпляр программного компонента – результат инсталляции функтора в конкретном рабочем окружении. Такое окружение включает множество модулей, каждый из которых может иметь внутреннее состояние. 

 Приложение называется автономным (standalone), если оно не подразумевает активного взаимодействия с пользователем, как правило, через GUI. Оно состоит из главного функтора, который вычисляется при старте приложения и импортирует нужные модули, что в свою очередь приводит к вызову других функторов.

Вычисление, или «инсталляция» функтора выполняется в три шага.
Во-первых, идентифицируются модули, которые будут требоваться для его работы.
Во-вторых, выполняется код инициализации.
В-третьих, загружаются модули, которые непосредственно востребованы во время работы.
Вычисление не главных функторов может происходить в самое разное время работы программы, непосредственно в те моменты, когда в коде запрашивается некоторый ресурс из пока невычисленного функтора.
Это так называемое динамическое связывание, в противоположность статическому связыванию, когда все модули загружаются сразу в момент старта приложения.
В любой момент множество инсталлированных модулей называется рабочим модульным окружением. 




Поддержка модулей в Julia

В Julia поддерживается концепция модулей, весьма близкая к вышеописанной декларативной модели: docs.julialang.org/en/v1/manual/modules/

В качестве примера определим модуль MyList, содержащий функции для работы со списками.

Создадим файл MyList.jl, и обозначим его как модуль с соответствующим названием с помощью ключевого слова module, заканчивающегося end:

module MyList
 # ...
end

Мы определим в модуле три функции:
- Append(), которая добавляет новый элемент в хвост списку;
- Is(), которая проверяет, присутствует ли элемент в списке;
- Sort(), которая сортирует список. 

 Экспортируемые из модуля функции, типы и другие сущности (имена) задаются в разделе экспорта, после ключевого слова export.

Добавим для простоты стандартные реализации.

module MyList

export Append, Is, Sort, x, y

function Append(Ls, Elem)
  return vcat(Elem, Ls)
end

function Is(Ls, Elem)
  return Elem in Ls
end

function Sort(Ls)
  return sort(Ls)
end

x() = "x"
y = "y"
z() = "z"

end

Мы также добавили две функции x() и z(), одна из которых x() экспортируется из модуля, а другая z() доступна только внутри него. Кроме того, в модуль добавлена экспортируемая переменная y. 

 Как использовать модуль в своей программе? Это правильнее делать с помощью инструкции using или import, но они подразумевают, что модуль установлен в системе Julia с помощью менеджера пакетов. Поэтому для простоты воспользуемся такой схемой:

include("MyList.jl")

import .MyList: x

print( x() )

Сперва мы включаем с помощью include код модуля из файла MyList.jl, находящегося в текущем каталоге, в файл с данным кодом, который расположен в одном каталоге с MyList.jl.
Затем мы импортируем модуль MyList, что называется, in place – непосредственно из текущего файла, для чего ставим точку перед именем импортируемого модуля:

import .MyList

Наконец, после имени импортируемого модуля через двоеточие задаётся перечень импортируемых из этого модуля имён:

import .MyList: x

Выполняя import или using, мы вызываем функтор MyList, который создаёт и возвращает «экземпляр» модуля MyList со всем его физическим содержимым. Например, выполнив

import .MyList: x, y

мы получим в нашей программе полноценную переменную y, проинициализированную значением "y1".

Как видно, модуль как функтор вычисляется в реальном времени. Он вполне может содержать данные, рассчитываемые в момент вызова. Функтор может быть размещён в отдельном файле, и при этом он может быть совсем «лёгким» -- например, хранить один объект или класс.

Фактически функторы – это значения, однако в Julia модули позиционируются прежде всего как синтаксические единицы, как пространства имён для инкапсуляции и разграничения видимости. В любом случае, модули сегодня присутствуют практически в любом языке программирования и поддерживают схему компонентно-ориентированного программирования, которая особенно продуктивна в языках с динамической типизацией: компоненты (модули) создаются и гибко связываются в реальном времени. При этом полезная возможность, поддерживаемая в Julia – это предварительная компиляция модулей для их быстрой загрузки, если они не требуют ввода данных из внешнего мира.

Но следует помнить и о типичных проблемах иерархий модулей, когда потенциально возможны, например, закольцованные ссылки. Чем больше модулей в системе, тем тщательнее надо продумывать взаимосвязи между ними. 


