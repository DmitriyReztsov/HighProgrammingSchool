#=
Один из хороших способов правильно организовать программирование с параллелизмом и состоянием -- 
это использовать атомарные операции. Операция является атомарной, если мы не можем наблюдать какие-то 
промежуточные состояния обрабатываемых ей данных. Атомарная операция сразу "прыгает" непосредственно 
от начального состояния к конечному результату.

Упоминавшаяся проблема race conditions связана с тем, что нити, выполняющие некоторый набор действий над 
одной общей ячейкой памяти, начинают перебивать работу других нитей, выполняющих аналогичные действия. 
В результате значение этой ячейки меняется непредсказуемо: одна нить обрабатывает ранее считанное значение, 
и ещё не записала свой результат обратно, а в это время влезла другая нить и тоже изменила значение на своё. 
Один из способов борьбы с race conditions -- это организация так называемого потоково-безопасной (thread-safe) 
работы программы. Программисту предоставляется механизм атомарного выполнения: набор действий над общей ячейкой 
объявляется некоторой нитью атомарным, и пока он полностью не закончится, никакая другая нить не сможет работать 
с этой ячекой.

С помощью атомарных операций мы можем решить вышеприведённую проблему с неверным итоговым изменением переменной "a" 
в нескольких нитях. Идея заключается в том, чтобы обеспечить такой режим работы, когда тело каждой нити будет атомарным. 
Для этого нам нужен механизм построения атомарных операций.

Однако, атомарность и thread-safe в общем случае не гарантируют недетерминизма.

thread A
начало атомарной операции
y = 0
x = y
конец атомарной операции
print x

thread B
начало атомарной операции
y = 1
x = y
конец атомарной операции
print x

Теперь каждая из операций будет выполняться в своём кванте времени, без перебивки другими, однако итоговый результат 
всё равно будет непредсказуем (0 1 или 1 0).

Правильная детерминированная модель:

thread A
x = 0
запуск thread B
начало атомарной операции
x = x + 1
конец атомарной операции
ожидание окончания работы thread B
print x

thread B
начало атомарной операции
x = x + 2
конец атомарной операции
завершиться

В результате всегда будет выводиться 3. 
=#

# Пример на Julia, в котором может проявиться проблема конкуренции (race condition): 
# global i = 0

# ids = zeros(4)
# old_is = zeros(4)

# Threads.@threads for id in 1:4
#     global i = i + id
#     old_is[id] = i
#     ids[id] = id
# end

# println(old_is)
# println(ids)

#=
Тут вполне вероятна ситуация, когда в одной нити выполнится
global i = i + id
после чего в другой нити также выполнится
global i = i + id
и в результате в old_is обоих нитей запишется одно и то же дважды подряд модифицированное значение i. 
=#
#=
 Атомарность в Julia, с поддержкой режима thread-safe, обеспечивается специальным типом Threads.Atomic, 
 в который "оборачиваются" значения, обработка которых должна быть атомарной.

i = Threads.Atomic{Int}(0)

{Int} это тип, параметризующий тип Threads.Atomic под нужное значение. Обратите внимание, что 
global теперь можно не указывать, так как Atomic по определению должен поддерживать "глобальность" переменной.

Вместо обычной операции сложения "i = i + id" теперь надо использовать специальную атомарную операцию 
Threads.atomic_add!(), которая меняет значение своего первого аргумента (это должно быть имя переменной), 
добавляя ему значение второго аргумента. Эта функция возвращает старое значение аргумента, поэтому ей надо добавить id, 
и так как нужное действие выполняется в одной инструкции, можно считать, что в процессе её выполнения не будет переключения 
на другую нить (хотя в каждом конкретном проекте такие нюансы надо тщательно выяснять и тестировать):
=#

# i = Threads.Atomic{Int}(0);

# ids = zeros(4)
# old_is = zeros(4)

# Threads.@threads for id in 1:4
#     old_is[id] = Threads.atomic_add!(i, id) + id
#     ids[id] = id
# end

# println(old_is)
# println(ids)

#=
Существуют также и другие механизмы обеспечения атомарности. Например, функция lock() блокирует некоторую ячейку 
(переменную) от изменения другими нитями до момента, пока она не будет явно разблокирована с помощью unlock(), 
хотя квантование времени и переключение между нитями выполняется в обычном порядке. 
Но эти режимы, как показывалось ранее, в общем случае не гарантируют детерминизм вычислений.
Однако при организации параллельных вычислений всегда обеспечивайте атомарность вычислений, насколько возможно. 
=#

function thread_test(v)
    Threads.@threads for i = 1:length(v)
        # println("i = $i on thread $(Threads.threadid())")
        @inbounds v[i] = i
    end
    println("thread+ $(Threads.threadid())")
    return(v)
end

a = zeros(Int64, 12222200)
m = thread_test(a)
stm = 1
for (i, elm) in enumerate(m)
    global stm
    if i == elm
        stm = stm * 1
    else
        stm = stm * 0
    end
end
println(stm)