
1. О методике проектирования на данном курсе

При выборе какой-либо парадигмы проектирования и разработки надо учитывать достаточно много критериев. Но даже в рамках объектно-ориентированного подхода существуют и активно применяются десятки методологий, подчас отличающихся друг от друга весьма сильно.

Методология, изучаемая на данном цикле курсов, предложена Бертраном Мейером. Мы используем обычную концепцию класса из массовых языков программирования, трактуем класс как модуль и как тип. Класс хорошо подходит и для композиции, и для декомпозиции, его можно использовать и на этапе выработки спецификаций АТД, и при проектировании системы в целом, и на шаге реализации.

Наиболее сильные стороны данной методики:

-- Класс -- это универсальная семантическая и синтаксическая единица проекта.

-- Каждый класс в проекте создаётся на основе своей спецификации (АТД). Если исходить из того, что все АТД были проработаны верно, то на их основе "автоматически" получается практически полностью корректная программная система.

-- Высокая робастность/устойчивость системы обеспечивается принципом "любой выход за пределы спецификации -- ошибка". Таким образом формально определяются границы безошибочности системы, а все ошибочные ситуации легко выявляются и обрабатываются, например, единообразным диагностическим способом.

-- Децентрализованная архитектура (отсутствие единственного класса-ядра), автономность всех модулей, простота адаптации к спецификации (внесение изменений в АТД подразумевает простые действия по их реализации в соответствующих классах) обеспечивают высокую гибкость и расширяемость системы.

-- В процессе разработки не требуется какой-то специальный порядок действий. Практически все классы характеризуются низким сцеплением, что позволяет реализовывать их независимо друг от друга -- проект легко разделяется между множеством разработчиков.

-- Повсеместное повторное использование кода как один из главных принципов проектирования иерархий позволяет создавать очень компактные архитектуры.

Легко расширяемую и при этом допускающую простое повторное использование кода систему называют модульной (независимо от того, используется ли в процессе разработки ООП, функциональный подход или что-то ещё). 


2. Ещё несколько плюсов рассматриваемой методологии


- высокая производительность (линейный рост потребления памяти, вычислительных ресурсов, пропускной способности сети при увеличении количества классов в проекте);

- целостность (защита от потенциально вредных модификаций благодаря наличию спецификации АТД);

- верифицируемость (простота тестирования и отладки);

- экономичность реализации;

- простота и восстанавливаемость (имея формальные описания АТД, всегда можно быстро разобраться в системе на более высоком уровне абстракции, нежели обычный код).

Но самым главным плюсом будет прежде всего корректность (правильность) системы. В программной инженерии проводилось множество исследований, которые доказали, что качество системы -- это самая важная характеристика, из которой следуют и короткие сроки реализации, и хорошие показатели самых разных технических параметров.

Корректно (логически правильно) и устойчиво (без ошибок времени выполнения) работающую систему называют надёжной. 


3. Бесшовность жизненного цикла системы

Одна из сильнейших сторон хорошей методики ООАП -- это бесшовность.

Весь жизненный цикл системы, от анализа и проектирования до реализации, тестирования, развёртывания и сопровождения мы можем гладко выполнять с помощью единой методики (набор спецификаций АТД как "законы" и реализующая его замкнутая система классов как "исполнители"), одного объектно-ориентированного языка программирования и общего набора инструментов.

При этом мы везде работаем исключительно с классами как единственным видом модулей. Никакой главной программы и иных глобальных сущностей в проекте нету, всё объединено единой схемой вычислений. Классы обмениваются информацией только через вызов методов и механизм наследования, а различные исключительные ситуации обрабатывает программная "судебная власть" (механизмы реагирования на ошибочные события, которые можно описать формально).

Данная методика положительно отличается от многих других подходов обратимостью: нередко наилучшие проектные идеи приходят уже во время решения, которое оказывает заметное воздействие на саму исходную проблему. По этой причине бесшовность проявляется и в том, что в проекте исчезают изолированные роли аналитиков, интересующихся лишь некомпьютерными концепциями, проектировщиков, которых волнует лишь общая структура, и разработчиков, заботящихся лишь о коде. Человек становится полноценным универсальным специалистом, способным с помощью единой методики ООАП эффективно решать задачи и аналитика, и разработчика, и проектировщика. ООАП уничтожает классические принципиальные различия между этими тремя этапами, теперь в них применяется единая методика, ориентированная на общую цель. По сути, она поднимает классические концепции программирования до уровня достаточно абстрактного средства моделирования.

Мы смотрим на архитектуру объектно-ориентированной системы как на семейство взаимозависимых объектов. По своим взаимодействиям оно замкнуто -- классы общаются только друг с другом и только через публичные интерфейсы АТД. Это так называемая (хорошая) живучесть. 


4. Модульное проектирование

Вспомним предыдущие курсы, где мы трактовали класс как модуль и класс как тип, и занимались проектированием самих классов и связыванием их через композицию и наследование.

Посмотрим теперь так же на проектирование системы в целом.

Начнём с модульного подхода. Мы выяснили, что расширяемость модулей и их повторное использование не сработают как следует, если в проекте нету поддержки модулей как автономных сущностей -- самодостаточных и предлагающих простые связи друг с другом.

Хорошая поддержка модулей должна отвечать пяти критериям модульного проектирования:

1) Декомпозиция -- раскладывание задачи на более простые, более мелкие и независимые подзадачи (для чего в частности требуется поддержка начальной инициализации каждого модуля независимо от всех других);

2) Композиция -- сборка системы из независимых модулей в совершенно других условиях, отличных от их создания (с хорошей поддержкой повторного использования, соответствующие пять принципов для модулей мы изучали на предыдущем курсе);

3) Понятность -- для понимания кода модуля достаточно ограничиться содержимым лишь этого модуля;

4) Непрерывность -- при не слишком сильных изменениях спецификации АТД и других формальных требований к системе потребуется модифицировать один, максимум 2-3 модуля (это означает, что система в целом устойчива, не подвержена ломке);

5) Защищённость -- любые ошибки, возникающие исключения остаются скрытыми внутри модуля и не выходят за его пределы. 


5. Принципы модульного проектирования на практике

1) Прямое отображение: модель системы напрямую отображается в код, в частности, модульная структура системы -- в модули кода;

2) Минимизация интерфейсов: каждый модуль должен поддерживать минимальное количество связей с другими модулями. Для этого либо вводится централизованный модуль (тогда "периферийные" модули поддерживают только одну связь с ним), либо модули связываются в кольцо (через 1-2 связи с соседями);

3) Явные, формально специфицированные интерфейсы -- всё общение между модулями должно выполняться только через них, тогда оно будет прозрачным, простым, читабельным;

4) Слабая связанность интерфейсов -- если между модулями имеется связь, то она должна подразумевать как можно меньший обмен информацией, а сами открытые интерфейсы должны быть спроектированы так, чтобы минимально изменяться при изменении требований/спецификации;

5) Скрытие данных, внешним пользователям модуля явно доступны только публичные методы, набор команд и запросов, обработка ошибок инкапсулирована внутри них.

Ключевой навык проектирования заключается в умении управлять (прежде всего, минимизировать) количеством и формой связей между модулями через унифицированные интерфейсы, скрывая внутреннюю реализацию.

Класс как модуль, как синтаксическая единица неплохо подходит под все эти требования. Однако когда мы попытаемся приступить к проектированию в модульном режиме, нас ждут известные неприятности. 


6. Модульная декомпозиция

Широко распространённая методика проектирования "сверху вниз" (нисходящее проектирование Дейкстры) подразумевает разбиение сложной задачи на несколько более простых (это и называется декомпозиция), а затем выполняется решение каждой из более простых задач по отдельности, по этой же схеме. Если среди более простых задач снова встречается сложная, опять упрощаем её дальнейшим делением. Например, у нас имеется некоторая достаточно глобальная и сложная функция, и мы пока не знаем, как её сразу реализовать, поэтому постепенно детализируем реализацию, представляя в виде нескольких более простых функций (последовательным их вызовом или какой-то комбинацией).

Однако в результате фактически вся такая архитектура будет отражать личное понимание конкретным программистом механизма работы этой функции. Причём сразу будет задан порядок действий (последовательность более простых шагов, вызовов более простых функций), который всегда "хрупок" -- при любых изменениях требований к проекту потребуются сильные модификации такой архитектуры буквально на уровне кода, изменением последовательности шагов. Это очень неэффективная схема, которая подразумевает модульную конструкцию, механически объединяющую группы функций в модули.

Методика "сверху вниз" также большой акцент делает на пользовательском интерфейсе, когда мы начинаем проектирование с декомпозиции глобальных задач, с реализации пошаговых сценариев use case, с CASE-анализа. Но всё это по большому счёту вообще противоречит принципам ООП и приводит к неэффективной модульной структуре.

Модули в такой ситуации создаются в ответ на конкретные подзадачи, на конкретные сценарии работы пользователей, они непосредственно привязаны к контексту исполнения, и в такой ситуации практически невозможно придумать, как сделать их универсальными.

Методика "сверху вниз" хороша при проектировании достаточно простых и понятных систем, требования к которым не меняются. Но она совсем слабо показывает себя при создании эволюционно развивающейся системы, в отношении которой мы пока в принципе не знаем, что нового в ней может появиться. Кроме того, "сверху вниз" -- это скорее метод разработки, подход к реализации технического задания, который сам по себе никак не масштабируется при усложнении этого задания. А при проектировании гораздо важнее формальный способ описания предметной области, построение её гибкой абстрактной модели, на основе которой и будет происходить реализация. 


7. Правильная методика проектирования

Правильная методика объектно-ориентированного проектирования и построения масштабируемой объектной архитектуры подразумевает, что у нас имеется большой мир, в котором взаимодействуют друг с другом примерно равноправные сущности (объекты). Он организован не иерархически (как в случае модульной архитектуры), а плоско, и может легко развиваться эволюционно.

Главное в таком проектировании -- это внутренняя семантика такого мира, его содержание, множество маленьких независимых "смыслов", потому что форма (например, наборы типовых сценариев действий пользователей) всегда очень изменчива.

С помощью ООП мы по сути разрабатываем математическую модель, некоторую алгебру -- наборы формальных операций. А вот какую-либо непосредственную композицию (сценарии использования) носителей этой алгебры (объектов с публичным интерфейсом) мы пока откладываем. Но подразумеваем при проектировании АТД, конечно, какую внутреннюю семантику они должны реализовывать.

Таким образом, этот подход можно назвать проектированием "снизу вверх". На первом шаге мы разрабатываем достаточно универсальные компактные компоненты (даже не объекты, а типы, АТД), из которых потом и составляем наше приложение с помощью системы типов. На втором шаге (который неразрывно связан с первым) мы дополняем наборы операций в типах различными ограничениями (семантикой), требованиями предметной области. Но при этом постоянно придерживаемся более высокого уровня абстракции, нежели прозаические классы в коде (а именно, думаем о проекте всё время в терминах АТД), иначе физическая реализация будет ничуть не лучше, чем в случае функционального подхода "сверху вниз".

Объектно-ориентированное проектирование подразумевает конструирование архитектуры системы из модулей, полностью основанных на типах объектов, с которыми ведётся работа в моделируемой предметной области.

По мере реализации проекта мы последовательно улучшаем наше понимание структур нужных классов, поддерживаем на основе спецификаций АТД устойчивые и семантически легко расширяемые понятия, и выполняем сборку всё более мощных и крупных подсистем, пока не будет получена окончательная работающая система. Причём собирать её из итогового набора АТД обычно можно по-разному. Такая сборка в некотором смысле получается автоматически: мы разрабатываем своеобразный симулятор, подобие компьютерной игры, в котором после его старта самостоятельно действует множество равноправных объектов, обмениваясь друг с другом сообщениями (вызывая методы).

Отсюда следует важный принцип проектирования:
не спрашивайте, что система делает; спрашивайте, кто в системе делает то-то и то-то.

Но напомню, что в результате мы всё же хотим получить действующий прототип: по окончании анализа и проектирования вам потребуется добавить минимальную реализацию классов, и чтобы проект в итоге легко и просто собирался, запускался и работал.

Для этого критически важен скилл т.н. поведенческой композиции. Она состоит из трёх неразрывно связанных моментов:

- способность разбивать большое сложное поведение на части;
- рациональная уверенность, что это разбиение будет корректно работать как одно целое;
- организация реализации и тестирования этих частей такое, которое гарантирует, что вся система ведёт себя именно так, как ожидалось.

Это сложный навык, поэтому я порекомендую уже с первых шагов придерживаться схемы разработки TDD. Как минимум, почитайте с курса карьеры "TDD: разработка, управляемая тестированием", а также материалы СильныхИдей "25) Как правильно писать тесты" и "27) Как правильно понимать TDD".

Безусловно, у всех нас есть некоторое представление о том, как поведёт себя система, когда мы "закончим", иначе мы бы не начинали. Но, используя методику Мейера и поведенческую композицию, мы не заботимся о том, как ведёт себя вся система в деталях, прежде чем мы начнём работу. Мы постепенно записываем свои ожидания по кусочкам в виде тестов, и удовлетворяем эти ожидания step by step в виде дополнений и изменений в коде.

Задание 1.

Составьте предварительное, самое общее, словесное описание системы, которую вы хотите сделать. Придерживаясь принципов модульности, определите в ней 5-7 наиболее общих сущностей (потенциальных АТД), пока кратко и неформально их опишите.

Укажите, что делает в системе каждая такая сущность, стараясь, чтобы из этого множества формулировок "кто что делает" была бы хорошо понятна и общая идея работы системы в целом. 


8. О важности связи анализа и проектирования

В весьма известных методиках ООАП предлагается формировать классы, исходя прежде всего из типичных сценариев взаимодействия с пользователем, из организации экранных форм, и т. п. Как уже отмечалось, любой намёк на явную реализацию упорядоченной последовательности действий или событий, или на привязку к пользовательским интерфейсам в полном отрыве от внутренней архитектуры -- это верный признак ошибочного подхода. Последовательности очень часто подвержены модификациям, и последствия таких изменений слабо предсказуемы.

Например, популярная методика CRC (Class, Responsibility, Collaboration; Класс, Ответственность, Сотрудничество) подразумевает использование бумажных карточек, которые разработчики заполняют при обсуждении проекта. В CRC, пожалуй, очень наглядно и проявляется ключевой недостаток множества подобных подходов -- стремление сосредоточиться только на анализе технического задания и требованиях заказчика с полным игнорированием требований внутренней архитектуры проекта, предыдущего опыта проектирования и возможностей стандартных библиотек. Чем больше опыт проектировщика, тем больше он будет выполнять ООАП, опираясь на принцип повторного использования: отыскивая и используя уже готовые классы (причём не только классы анализа, но и классы проектирования и классы реализации), или отыскивая готовые идеи их спецификации, нежели создавая новые классы с нуля. При этом явно подразумевается возможность внесения изменений и в само техническое задание, исходя из наличия таких проверенных классов.

ООП -- это децентрализованная парадигма "кто делает" с акцентом на абстракциях данных, в ней максимально избегается подход "что система делает", характерный для функционального проектирования. В ситуациях, когда в проекте всё же нужна активная поддержка последовательностей действий, можно использовать такие классы проектирования, как машины состояний (или паттерн Command), а пользовательские сценарии детально оформлять в режиме тестирования. 


9. Понятие проектирования

Уточним и обобщим понятие проектирования (и в некотором смысле конструирования) объектно-ориентированной системы:

Объектно-ориентированное проектирование и конструирование -- это формирование программной системы как структурированной совокупности реализаций абстрактных типов данных.

Структурирование выполняется через отношения наследования и композиции с учётом полиморфизма.

В совокупности не выделяется одна или нескольких "главных" реализаций -- все объекты равноправны (что не исключает иерархических схем связи и взаимодействия между ними).

Реализации абстрактных типов данных допускаются частичные.

И это всё.

Отсюда, в частности, следует, что классы (типы взаимодействующих объектов) -- это ключевой ресурс при построении системы, а функции (методы классов) лишь слуги классов. Сами по себе абстрактные функции в системе практически не существуют (кроме, возможно, каких-то стандартных математических и системных), все они представляют собой логически сгруппированные операции конкретных структур данных (методы классов).

Обратите внимание на акцент на частичной реализации (эту форму иногда называют отложенными классами) -- это важная составляющая объектно-ориентированной системы. Отложенный (или частично реализованный) класс, в котором реализованы не все методы (или, если конкретный язык программирования такого не позволяет, некоторые методы скрыты пустыми заглушками или генерацией исключений), фактически представляет собой высокоуровневый модуль с базовым набором операций. Он через наследование выделяет группу взаимосвязанных типов, фиксирует общие свойства поведения такой группы, обеспечивает децентрализованную и расширяемую архитектуру системы. ООП естественно стимулирует создание децентрализованной архитектуры, потому что мы делаем акцент не на порядке выполнения программы, а на конкретных возможностях нашей системы типов, нашего множества классов. 


10. Идеальный цикл ООАП

Идеальный цикл объектно-ориентированного анализа, проектирования и реализации состоит из семи шагов:

Шаг 1. Определяем границы разрабатываемой системы (анализ):

- что будет включено в систему, а что точно не надо в неё включать;
- главные подсистемы;
- пользовательские метафоры (что именно пользователь/заказчик понимает под тем, что в рамках проекта он называет, например, "Автомобиль" или "Товар" или "Клиент");
- функциональность;
- библиотеки повторного использования.

Задание 2.

Выполните этот шаг без детализации, по 3-7 ключевых понятий в компактной формулировке по каждому пункту. 


11. Построение модели предметной области

Шаг 2. Составляем множество классов-кандидатов, имеющих отношение к предметной области (пока не очень формально), с акцентом на потенциальные классы анализа и классы проектирования (анализ).

На протяжении всего цикла разработки анализ - проектирование - реализация мы формируем прежде всего модели конкретных сущностей предметной области. ООП тут выступает хорошей техникой и анализа, и проектирования, и реализации, потому что оно предоставляет простые и сильные механизмы именно для моделирования.

Но что конкретно мы получаем в качестве модели?

Это может быть формальное представление конкретной предметной области, напрямую с программной реализацией не связанное. В таком случае мы используем АТД, задаём спецификации абстрактных типов и взаимосвязи между ними.

Это может быть некоторая реализация модели предметной области с использованием подходящих инструментов -- например, представление в виде базы данных, где таблицы связаны реляционными отношениями.

Это может быть объектно-ориентированный код, в котором задано множество классов, связанных отношениями наследования и композиции.

Это может быть работающая программа, где существует множество объектов, связанных ссылками.

Чем ниже мы спускаемся по этому списку, тем дальше и дальше будет наша модель от моделируемой системы реального мира. Работающая программа -- это модель модели модели, причём на каждом шаге добавляется всё больше специальных вычислительных нюансов.

Поэтому так важно выполнять моделирование, поддерживать и улучшать формируемую модель на самом первом, абстрактном уровне АТД. Причём мы не пытаемся сразу создать модель, которая будет как-то "точно" отражать реальный мир, а выделяем в нём некоторое множество абстракций (идентифицируемых своими наборами операций) и их формальные свойства. Мы не обсуждаем "что есть система", мы изучаем, чем она обладает, и всегда понимаем, что строим частичную модель. Тут лучше переборщить с отсеканием лишнего, которое потом при необходимости можно легко добавить просто как новые АТД, не затрагивающие уже созданную систему. 


