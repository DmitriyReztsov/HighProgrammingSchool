
1. О методике проектирования на данном курсе

При выборе какой-либо парадигмы проектирования и разработки надо учитывать достаточно много критериев. Но даже в рамках объектно-ориентированного подхода существуют и активно применяются десятки методологий, подчас отличающихся друг от друга весьма сильно.

Методология, изучаемая на данном цикле курсов, предложена Бертраном Мейером. Мы используем обычную концепцию класса из массовых языков программирования, трактуем класс как модуль и как тип. Класс хорошо подходит и для композиции, и для декомпозиции, его можно использовать и на этапе выработки спецификаций АТД, и при проектировании системы в целом, и на шаге реализации.

Наиболее сильные стороны данной методики:

-- Класс -- это универсальная семантическая и синтаксическая единица проекта.

-- Каждый класс в проекте создаётся на основе своей спецификации (АТД). Если исходить из того, что все АТД были проработаны верно, то на их основе "автоматически" получается практически полностью корректная программная система.

-- Высокая робастность/устойчивость системы обеспечивается принципом "любой выход за пределы спецификации -- ошибка". Таким образом формально определяются границы безошибочности системы, а все ошибочные ситуации легко выявляются и обрабатываются, например, единообразным диагностическим способом.

-- Децентрализованная архитектура (отсутствие единственного класса-ядра), автономность всех модулей, простота адаптации к спецификации (внесение изменений в АТД подразумевает простые действия по их реализации в соответствующих классах) обеспечивают высокую гибкость и расширяемость системы.

-- В процессе разработки не требуется какой-то специальный порядок действий. Практически все классы характеризуются низким сцеплением, что позволяет реализовывать их независимо друг от друга -- проект легко разделяется между множеством разработчиков.

-- Повсеместное повторное использование кода как один из главных принципов проектирования иерархий позволяет создавать очень компактные архитектуры.

Легко расширяемую и при этом допускающую простое повторное использование кода систему называют модульной (независимо от того, используется ли в процессе разработки ООП, функциональный подход или что-то ещё). 


2. Ещё несколько плюсов рассматриваемой методологии


- высокая производительность (линейный рост потребления памяти, вычислительных ресурсов, пропускной способности сети при увеличении количества классов в проекте);

- целостность (защита от потенциально вредных модификаций благодаря наличию спецификации АТД);

- верифицируемость (простота тестирования и отладки);

- экономичность реализации;

- простота и восстанавливаемость (имея формальные описания АТД, всегда можно быстро разобраться в системе на более высоком уровне абстракции, нежели обычный код).

Но самым главным плюсом будет прежде всего корректность (правильность) системы. В программной инженерии проводилось множество исследований, которые доказали, что качество системы -- это самая важная характеристика, из которой следуют и короткие сроки реализации, и хорошие показатели самых разных технических параметров.

Корректно (логически правильно) и устойчиво (без ошибок времени выполнения) работающую систему называют надёжной. 


3. Бесшовность жизненного цикла системы

Одна из сильнейших сторон хорошей методики ООАП -- это бесшовность.

Весь жизненный цикл системы, от анализа и проектирования до реализации, тестирования, развёртывания и сопровождения мы можем гладко выполнять с помощью единой методики (набор спецификаций АТД как "законы" и реализующая его замкнутая система классов как "исполнители"), одного объектно-ориентированного языка программирования и общего набора инструментов.

При этом мы везде работаем исключительно с классами как единственным видом модулей. Никакой главной программы и иных глобальных сущностей в проекте нету, всё объединено единой схемой вычислений. Классы обмениваются информацией только через вызов методов и механизм наследования, а различные исключительные ситуации обрабатывает программная "судебная власть" (механизмы реагирования на ошибочные события, которые можно описать формально).

Данная методика положительно отличается от многих других подходов обратимостью: нередко наилучшие проектные идеи приходят уже во время решения, которое оказывает заметное воздействие на саму исходную проблему. По этой причине бесшовность проявляется и в том, что в проекте исчезают изолированные роли аналитиков, интересующихся лишь некомпьютерными концепциями, проектировщиков, которых волнует лишь общая структура, и разработчиков, заботящихся лишь о коде. Человек становится полноценным универсальным специалистом, способным с помощью единой методики ООАП эффективно решать задачи и аналитика, и разработчика, и проектировщика. ООАП уничтожает классические принципиальные различия между этими тремя этапами, теперь в них применяется единая методика, ориентированная на общую цель. По сути, она поднимает классические концепции программирования до уровня достаточно абстрактного средства моделирования.

Мы смотрим на архитектуру объектно-ориентированной системы как на семейство взаимозависимых объектов. По своим взаимодействиям оно замкнуто -- классы общаются только друг с другом и только через публичные интерфейсы АТД. Это так называемая (хорошая) живучесть. 


4. Модульное проектирование

Вспомним предыдущие курсы, где мы трактовали класс как модуль и класс как тип, и занимались проектированием самих классов и связыванием их через композицию и наследование.

Посмотрим теперь так же на проектирование системы в целом.

Начнём с модульного подхода. Мы выяснили, что расширяемость модулей и их повторное использование не сработают как следует, если в проекте нету поддержки модулей как автономных сущностей -- самодостаточных и предлагающих простые связи друг с другом.

Хорошая поддержка модулей должна отвечать пяти критериям модульного проектирования:

1) Декомпозиция -- раскладывание задачи на более простые, более мелкие и независимые подзадачи (для чего в частности требуется поддержка начальной инициализации каждого модуля независимо от всех других);

2) Композиция -- сборка системы из независимых модулей в совершенно других условиях, отличных от их создания (с хорошей поддержкой повторного использования, соответствующие пять принципов для модулей мы изучали на предыдущем курсе);

3) Понятность -- для понимания кода модуля достаточно ограничиться содержимым лишь этого модуля;

4) Непрерывность -- при не слишком сильных изменениях спецификации АТД и других формальных требований к системе потребуется модифицировать один, максимум 2-3 модуля (это означает, что система в целом устойчива, не подвержена ломке);

5) Защищённость -- любые ошибки, возникающие исключения остаются скрытыми внутри модуля и не выходят за его пределы. 


5. Принципы модульного проектирования на практике

1) Прямое отображение: модель системы напрямую отображается в код, в частности, модульная структура системы -- в модули кода;

2) Минимизация интерфейсов: каждый модуль должен поддерживать минимальное количество связей с другими модулями. Для этого либо вводится централизованный модуль (тогда "периферийные" модули поддерживают только одну связь с ним), либо модули связываются в кольцо (через 1-2 связи с соседями);

3) Явные, формально специфицированные интерфейсы -- всё общение между модулями должно выполняться только через них, тогда оно будет прозрачным, простым, читабельным;

4) Слабая связанность интерфейсов -- если между модулями имеется связь, то она должна подразумевать как можно меньший обмен информацией, а сами открытые интерфейсы должны быть спроектированы так, чтобы минимально изменяться при изменении требований/спецификации;

5) Скрытие данных, внешним пользователям модуля явно доступны только публичные методы, набор команд и запросов, обработка ошибок инкапсулирована внутри них.

Ключевой навык проектирования заключается в умении управлять (прежде всего, минимизировать) количеством и формой связей между модулями через унифицированные интерфейсы, скрывая внутреннюю реализацию.

Класс как модуль, как синтаксическая единица неплохо подходит под все эти требования. Однако когда мы попытаемся приступить к проектированию в модульном режиме, нас ждут известные неприятности. 


6. Модульная декомпозиция

Широко распространённая методика проектирования "сверху вниз" (нисходящее проектирование Дейкстры) подразумевает разбиение сложной задачи на несколько более простых (это и называется декомпозиция), а затем выполняется решение каждой из более простых задач по отдельности, по этой же схеме. Если среди более простых задач снова встречается сложная, опять упрощаем её дальнейшим делением. Например, у нас имеется некоторая достаточно глобальная и сложная функция, и мы пока не знаем, как её сразу реализовать, поэтому постепенно детализируем реализацию, представляя в виде нескольких более простых функций (последовательным их вызовом или какой-то комбинацией).

Однако в результате фактически вся такая архитектура будет отражать личное понимание конкретным программистом механизма работы этой функции. Причём сразу будет задан порядок действий (последовательность более простых шагов, вызовов более простых функций), который всегда "хрупок" -- при любых изменениях требований к проекту потребуются сильные модификации такой архитектуры буквально на уровне кода, изменением последовательности шагов. Это очень неэффективная схема, которая подразумевает модульную конструкцию, механически объединяющую группы функций в модули.

Методика "сверху вниз" также большой акцент делает на пользовательском интерфейсе, когда мы начинаем проектирование с декомпозиции глобальных задач, с реализации пошаговых сценариев use case, с CASE-анализа. Но всё это по большому счёту вообще противоречит принципам ООП и приводит к неэффективной модульной структуре.

Модули в такой ситуации создаются в ответ на конкретные подзадачи, на конкретные сценарии работы пользователей, они непосредственно привязаны к контексту исполнения, и в такой ситуации практически невозможно придумать, как сделать их универсальными.

Методика "сверху вниз" хороша при проектировании достаточно простых и понятных систем, требования к которым не меняются. Но она совсем слабо показывает себя при создании эволюционно развивающейся системы, в отношении которой мы пока в принципе не знаем, что нового в ней может появиться. Кроме того, "сверху вниз" -- это скорее метод разработки, подход к реализации технического задания, который сам по себе никак не масштабируется при усложнении этого задания. А при проектировании гораздо важнее формальный способ описания предметной области, построение её гибкой абстрактной модели, на основе которой и будет происходить реализация. 


7. Правильная методика проектирования

Правильная методика объектно-ориентированного проектирования и построения масштабируемой объектной архитектуры подразумевает, что у нас имеется большой мир, в котором взаимодействуют друг с другом примерно равноправные сущности (объекты). Он организован не иерархически (как в случае модульной архитектуры), а плоско, и может легко развиваться эволюционно.

Главное в таком проектировании -- это внутренняя семантика такого мира, его содержание, множество маленьких независимых "смыслов", потому что форма (например, наборы типовых сценариев действий пользователей) всегда очень изменчива.

С помощью ООП мы по сути разрабатываем математическую модель, некоторую алгебру -- наборы формальных операций. А вот какую-либо непосредственную композицию (сценарии использования) носителей этой алгебры (объектов с публичным интерфейсом) мы пока откладываем. Но подразумеваем при проектировании АТД, конечно, какую внутреннюю семантику они должны реализовывать.

Таким образом, этот подход можно назвать проектированием "снизу вверх". На первом шаге мы разрабатываем достаточно универсальные компактные компоненты (даже не объекты, а типы, АТД), из которых потом и составляем наше приложение с помощью системы типов. На втором шаге (который неразрывно связан с первым) мы дополняем наборы операций в типах различными ограничениями (семантикой), требованиями предметной области. Но при этом постоянно придерживаемся более высокого уровня абстракции, нежели прозаические классы в коде (а именно, думаем о проекте всё время в терминах АТД), иначе физическая реализация будет ничуть не лучше, чем в случае функционального подхода "сверху вниз".

Объектно-ориентированное проектирование подразумевает конструирование архитектуры системы из модулей, полностью основанных на типах объектов, с которыми ведётся работа в моделируемой предметной области.

По мере реализации проекта мы последовательно улучшаем наше понимание структур нужных классов, поддерживаем на основе спецификаций АТД устойчивые и семантически легко расширяемые понятия, и выполняем сборку всё более мощных и крупных подсистем, пока не будет получена окончательная работающая система. Причём собирать её из итогового набора АТД обычно можно по-разному. Такая сборка в некотором смысле получается автоматически: мы разрабатываем своеобразный симулятор, подобие компьютерной игры, в котором после его старта самостоятельно действует множество равноправных объектов, обмениваясь друг с другом сообщениями (вызывая методы).

Отсюда следует важный принцип проектирования:
не спрашивайте, что система делает; спрашивайте, кто в системе делает то-то и то-то.

Но напомню, что в результате мы всё же хотим получить действующий прототип: по окончании анализа и проектирования вам потребуется добавить минимальную реализацию классов, и чтобы проект в итоге легко и просто собирался, запускался и работал.

Для этого критически важен скилл т.н. поведенческой композиции. Она состоит из трёх неразрывно связанных моментов:

- способность разбивать большое сложное поведение на части;
- рациональная уверенность, что это разбиение будет корректно работать как одно целое;
- организация реализации и тестирования этих частей такое, которое гарантирует, что вся система ведёт себя именно так, как ожидалось.

Это сложный навык, поэтому я порекомендую уже с первых шагов придерживаться схемы разработки TDD. Как минимум, почитайте с курса карьеры "TDD: разработка, управляемая тестированием", а также материалы СильныхИдей "25) Как правильно писать тесты" и "27) Как правильно понимать TDD".

Безусловно, у всех нас есть некоторое представление о том, как поведёт себя система, когда мы "закончим", иначе мы бы не начинали. Но, используя методику Мейера и поведенческую композицию, мы не заботимся о том, как ведёт себя вся система в деталях, прежде чем мы начнём работу. Мы постепенно записываем свои ожидания по кусочкам в виде тестов, и удовлетворяем эти ожидания step by step в виде дополнений и изменений в коде.

Задание 1.

Составьте предварительное, самое общее, словесное описание системы, которую вы хотите сделать. Придерживаясь принципов модульности, определите в ней 5-7 наиболее общих сущностей (потенциальных АТД), пока кратко и неформально их опишите.

Укажите, что делает в системе каждая такая сущность, стараясь, чтобы из этого множества формулировок "кто что делает" была бы хорошо понятна и общая идея работы системы в целом. 


8. О важности связи анализа и проектирования

В весьма известных методиках ООАП предлагается формировать классы, исходя прежде всего из типичных сценариев взаимодействия с пользователем, из организации экранных форм, и т. п. Как уже отмечалось, любой намёк на явную реализацию упорядоченной последовательности действий или событий, или на привязку к пользовательским интерфейсам в полном отрыве от внутренней архитектуры -- это верный признак ошибочного подхода. Последовательности очень часто подвержены модификациям, и последствия таких изменений слабо предсказуемы.

Например, популярная методика CRC (Class, Responsibility, Collaboration; Класс, Ответственность, Сотрудничество) подразумевает использование бумажных карточек, которые разработчики заполняют при обсуждении проекта. В CRC, пожалуй, очень наглядно и проявляется ключевой недостаток множества подобных подходов -- стремление сосредоточиться только на анализе технического задания и требованиях заказчика с полным игнорированием требований внутренней архитектуры проекта, предыдущего опыта проектирования и возможностей стандартных библиотек. Чем больше опыт проектировщика, тем больше он будет выполнять ООАП, опираясь на принцип повторного использования: отыскивая и используя уже готовые классы (причём не только классы анализа, но и классы проектирования и классы реализации), или отыскивая готовые идеи их спецификации, нежели создавая новые классы с нуля. При этом явно подразумевается возможность внесения изменений и в само техническое задание, исходя из наличия таких проверенных классов.

ООП -- это децентрализованная парадигма "кто делает" с акцентом на абстракциях данных, в ней максимально избегается подход "что система делает", характерный для функционального проектирования. В ситуациях, когда в проекте всё же нужна активная поддержка последовательностей действий, можно использовать такие классы проектирования, как машины состояний (или паттерн Command), а пользовательские сценарии детально оформлять в режиме тестирования. 


9. Понятие проектирования

Уточним и обобщим понятие проектирования (и в некотором смысле конструирования) объектно-ориентированной системы:

Объектно-ориентированное проектирование и конструирование -- это формирование программной системы как структурированной совокупности реализаций абстрактных типов данных.

Структурирование выполняется через отношения наследования и композиции с учётом полиморфизма.

В совокупности не выделяется одна или нескольких "главных" реализаций -- все объекты равноправны (что не исключает иерархических схем связи и взаимодействия между ними).

Реализации абстрактных типов данных допускаются частичные.

И это всё.

Отсюда, в частности, следует, что классы (типы взаимодействующих объектов) -- это ключевой ресурс при построении системы, а функции (методы классов) лишь слуги классов. Сами по себе абстрактные функции в системе практически не существуют (кроме, возможно, каких-то стандартных математических и системных), все они представляют собой логически сгруппированные операции конкретных структур данных (методы классов).

Обратите внимание на акцент на частичной реализации (эту форму иногда называют отложенными классами) -- это важная составляющая объектно-ориентированной системы. Отложенный (или частично реализованный) класс, в котором реализованы не все методы (или, если конкретный язык программирования такого не позволяет, некоторые методы скрыты пустыми заглушками или генерацией исключений), фактически представляет собой высокоуровневый модуль с базовым набором операций. Он через наследование выделяет группу взаимосвязанных типов, фиксирует общие свойства поведения такой группы, обеспечивает децентрализованную и расширяемую архитектуру системы. ООП естественно стимулирует создание децентрализованной архитектуры, потому что мы делаем акцент не на порядке выполнения программы, а на конкретных возможностях нашей системы типов, нашего множества классов. 


10. Идеальный цикл ООАП

Идеальный цикл объектно-ориентированного анализа, проектирования и реализации состоит из семи шагов:

Шаг 1. Определяем границы разрабатываемой системы (анализ):

- что будет включено в систему, а что точно не надо в неё включать;
- главные подсистемы;
- пользовательские метафоры (что именно пользователь/заказчик понимает под тем, что в рамках проекта он называет, например, "Автомобиль" или "Товар" или "Клиент");
- функциональность;
- библиотеки повторного использования.

Задание 2.

Выполните этот шаг без детализации, по 3-7 ключевых понятий в компактной формулировке по каждому пункту. 


11. Построение модели предметной области

Шаг 2. Составляем множество классов-кандидатов, имеющих отношение к предметной области (пока не очень формально), с акцентом на потенциальные классы анализа и классы проектирования (анализ).

На протяжении всего цикла разработки анализ - проектирование - реализация мы формируем прежде всего модели конкретных сущностей предметной области. ООП тут выступает хорошей техникой и анализа, и проектирования, и реализации, потому что оно предоставляет простые и сильные механизмы именно для моделирования.

Но что конкретно мы получаем в качестве модели?

Это может быть формальное представление конкретной предметной области, напрямую с программной реализацией не связанное. В таком случае мы используем АТД, задаём спецификации абстрактных типов и взаимосвязи между ними.

Это может быть некоторая реализация модели предметной области с использованием подходящих инструментов -- например, представление в виде базы данных, где таблицы связаны реляционными отношениями.

Это может быть объектно-ориентированный код, в котором задано множество классов, связанных отношениями наследования и композиции.

Это может быть работающая программа, где существует множество объектов, связанных ссылками.

Чем ниже мы спускаемся по этому списку, тем дальше и дальше будет наша модель от моделируемой системы реального мира. Работающая программа -- это модель модели модели, причём на каждом шаге добавляется всё больше специальных вычислительных нюансов.

Поэтому так важно выполнять моделирование, поддерживать и улучшать формируемую модель на самом первом, абстрактном уровне АТД. Причём мы не пытаемся сразу создать модель, которая будет как-то "точно" отражать реальный мир, а выделяем в нём некоторое множество абстракций (идентифицируемых своими наборами операций) и их формальные свойства. Мы не обсуждаем "что есть система", мы изучаем, чем она обладает, и всегда понимаем, что строим частичную модель. Тут лучше переборщить с отсеканием лишнего, которое потом при необходимости можно легко добавить просто как новые АТД, не затрагивающие уже созданную систему. 


12. Как находить и выявлять классы?

В отношении уже первых шагов идеального цикла ООАП сразу возникают три вопроса:

1. Как вообще находить и выявлять такие классы, типы данных?

2. Как эти классы правильно реализовывать?

3. Как описывать отношения между объектами? Как формировать из них подсистемы, иерархии?

Ответ на второй вопрос мы разбирали на первом курсе по ООАП: с помощью выделения абстрактных интерфейсов, независимых от реализации (АТД).

Ответ на третий вопрос мы разбирали на втором курсе по ООАП: с помощью двух видов отношения между классами и объектами (композиция и наследование) и с использованием полиморфизма.

Данный курс посвящён прежде всего ответу на первый вопрос. Часто выделение типов в конкретной предметной области (в частности, практика в таксономии) достаточно очевидно. Хотя чаще всего формирование хорошего множества типов всё же требует приличного опыта объектно-ориентированного проектирования, а правильное содержимое таких множеств классов довольно сильно отличается от начального обыденного, наивного представления. Однако всё же определённая естественность в этом процессе присутствует.

Например, создавая компьютерную игру, естественно выделить родительский класс NPC, от которого унаследовать конкретные расы (гномы, эльфы, ...) -- при условии, что между ними имеются достаточно сильные различия по форме (тогда расширяем потомки дополнительным набором операций) или по содержанию (тогда используем полиморфизм). Если же разница только в значениях атрибутов, будет достаточно одного класса NPC или, для повышения наглядности, льготного наследования. Так же естественно добавить классы (или иерархии классов) Weapon, Armor, Item, Resource, Cell и т. д. 


13. Как выполнять анализ

В анализе, изучении, "моделировании реального мира" надо прежде всего понять, а что такое "реальный мир", что же мы анализируем и моделируем? Всегда это будет только чьё-то, в лучшем случае экспертное, описание мира, но по определению всегда ограниченное и неполное. Поэтому если само анализируемое описание "реального мира" плохое и запутанное, продуктивно работающую программную систему мы создать не сможем.

Все рекомендации для выделения классов (или модулей) предполагают, что у нас имеется техническое задание, как-то более-менее удовлетворительно описывающее моделируемую предметную область, и мы будем этого придерживаться. Откуда взялось само ТЗ, каково его качество, насколько оно непротиворечиво -- тема, к данным курсам прямого отношения не имеющая. Далее исходим из того, что оно соответствует хотя бы здравому смыслу.

Первый принцип анализа: выявляем, идентифицируем подходящие абстракции (но пока не классы программы) в строгих рамках моделируемой области, заданной некоей внешней спецификацией (например, техническим заданием или словесными объяснениями заказчика).

Эти границы мы определили на первом шаге.

Но как же правильно начинать работу над проектом в самом начале, как выявлять абстракции, АТД? Это конечно процесс неформальный, творческий, он зависит от способностей, опыта и даже от удачи. Такая же ситуация и в математике, где не существует готовых рецептов разработки новых теорий и доказательств.

Тут можно лишь привести хорошие идеи и познакомиться с потенциальными опасностями.

Нередко тут применяется уже упоминавшийся функциональный подход, достаточно интуитивный и понятный практически любому. И как это часто бывает в сложных инженерных областях, такие наивные "очевидные", с ходу напрашивающиеся подходы показывают весьма и весьма низкий коэффициент полезного действия. Более того, подобный наивный подход с применением ООП тоже непродуктивен, о чём ранее уже говорилось. Давайте ещё раз разберём, почему, только более детально.

Функциональный подход предлагает делать акцент при анализе ТЗ на глаголах (действиях), а в объектно-ориентированном подходе акцент условно делается на существительных (описаниях объектов).

Например, в ТЗ имеется такой сценарий-пример (среди сотен и тысяч подобных): "гном прячет меч в ножны, поднимает с земли палицу и берёт её в руки в качестве оружия". Функциональный подход подразумевает, что надо специфицировать три функции "Убрать(существо, оружие, инвентарь)", "Взять-в-руки-с-клетки(существо, предмет, клетка-карты)" и "Сделать-оружием(существо, оружие-в-руках)". Объектный подход предлагает выделить классы Гном (точнее, иерархию Существо - Гном и потомки для других рас), Инвентарь, Карта (включающая в себя например массив из объектов класса Клетка), иерархию Оружие с потомками Меч, Палица и др., и добавить им соответствующие методы. В данном случае мы переходим от синтаксиса "Убрать(существо, оружие, инвентарь)" к более наглядному и безопасному "существо.Убрать-в-инвентарь-оружие-в-руках()".

Однако на практике такой прямой и поверхностный анализ ТЗ чаще просто создаёт больше путаницы независимо от того, применяется ли функциональный или объектный подходы. Само техзадание обычно написано нечётко, составляют его представители заказчика, в проектировании не разбирающиеся, поэтому подобные тексты изобилуют двусмысленностями, неточностями, откровенными ошибками, поэтому проектировать объектную архитектуру таким способом весьма опасно. Например, даже в таком простом случае непонятно, надо ли действительно будет формировать иерархию Оружие с потомками Меч, Палица и другими видами оружия, или же достаточно только одного класса Оружие, если конкретные виды оружия достаточно различать только по их числовым характеристикам?

В результате вместо упрощения создаваемая система только больше усложняется: наследование только запутывает её понимание, а формат "объект . метод" создаёт мнооество зависимостей и проблем, связанных с состояниями объектов. 


14. Правильный подход к ООАП

Существительные из ТЗ слишком часто будут провоцировать на выделение классов, которые на самом деле совершенно не будут нужны. Они будут приводить как к появлению лишних кандидатов, так и к пропуску нужных. И хотя успешность тут практически полностью зависит от опыта, интуиции, мастерства аналитика и проектировщика, всё же существует фундаментальный принцип, с которого всегда следует начинать.

Мы выявляем классы с помощью теории АТД, всегда пытаясь понять, будет ли некоторая сущность (гном или меч) независимым типом данных со своим чётко определённым и уникальным набором операций? Или же достаточно воспользоваться уже существующим набором операций класса-предка?

Если у гнома имеются какие-то уникальные возможности (например, пить пиво), недоступные никаким другим расам, то это однозначный признак для выделения АТД "гном" с операцией "пить пиво", наследующего все остальные действия, общие для всех рас. А если например меч отличается от палицы только внешним видом (кодом картинки-изображения) и числовыми характеристиками удара, то достаточно пока обойтись одним классом Оружие.

Вдобавок при этом мы выявили лишь очевидные классы, отражающие "естественные" сущности, однако помимо них наверняка потребуются классы поведения (например, реализующие пресловутые паттерны проектирования), которые задают внутреннюю специфику работы всей системы, её архитектуру, о которых пользователь системы и не подозревает. Возможна и обратная ситуация -- во время работы программы допустимо появление объектов, которые с точки зрения исходной модели имеют разный тип (например, Меч и Палица), однако реализованы одним типом Оружие. В проекте эти моменты определяются исключительно наличием или отсутствием соответствующего АТД.

Правильная методика объектно-ориентированного анализа и проектирования на основе АТД подразумевает, что в системе существуют только такие объекты, для которых формально определено, что с ними можно делать -- в контексте моделируемой предметной области.

Классические, не самые лучшие, объектно-ориентированные подходы к проектированию считают, что имеется готовое полноценные техническое задание, и в процессе его изучения и анализа сразу формируется непосредственная схема решения (реализации) сформулированных задач. В нашей методике наоборот мы не делаем принципиального различия между постановкой проблемы и её решением. Анализ, проектирование и реализацию надо выполнять, учитывая опыт схожих проектов и возможности используемой платформы, фреймворка, прежде всего их стандартных библиотек с типовыми структурами данных. Техническое задание тут отнюдь не самый руководящий документ, и более того, при необходимости в него желательно вносить коррективы, исходя прежде всего из интересов сильной архитектуры проекта (например, пожертвовать какими-то неважными требованиями). 


15. Ещё о важном преимуществе ОО-подхода

Чем плох модульно-функциональный подход? Хоть он и называется функциональным, но полностью завязан на данные, на состояния системы, обработка которых бессистемно размазывается между модулями, наращивая взаимозависимости между ними. Реакции на действия пользователей, ввод и вывод данных, проверка корректности -- все эти операции зависят от статических состояний и подразумевают программирование множества условных цепочек обработки всевозможных вариантов и условий. В таком случае при добавлении, изменении или удалении состояний приходится вносить правки во множество функций и модулей. Кроме того, если некоторый модуль претендует на универсальность, то он должен обрабатывать вообще все мыслимые состояния из соответствующего диапазона.

Такой подход подразумевает, что мы движемся через анализ, проектирование и реализацию логики обработки данных, но как только мы пытаемся организовать потоки данных через такую функциональную логику, возникает множество побочных эффектов, непрозрачность модулей быстро растёт, и в результате запутанность всего проекта стремительно его усложняет и замедляет. Причём данные тут -- лишь некая второстепенная сущность, простая переменная (содержащая обычное значение, в лучшем случае массив или список), которая перебрасывается между функциями. Фактически этим же грешат и многие методики ООП, отводя объектам как хранилищам данных вторичную роль.

Сильный объектно-ориентированный подход предлагает прямо противоположный принцип: мы начинаем именно с проектирования структур данных и взаимосвязей между ними, а функций полностью погружаются в это всё, представляются в виде простых операций над конкретными структурами данных. В ООП мы постепенно детализируем иерархию АТД, пошагово выделяя общие наборы операций, очень чётко формализуя различие между состояниями сущностей системы. Тут даже нередко можно обойтись только неглубоким наследованием (1-2 уровня) и частичной реализацией, без использования композиции или каких-то сложных форм полиморфизма. Мы плавно формируем архитектуру системы, увязывая все сущности (типы данных) в гармонично согласованные структуры.

При этом, конечно, неявно выполняется и функциональная декомпозиция, только теперь соответствующие функции распределяются по строгим семантическим правилам -- попадают непосредственно в те модули (классы), которые специфицируют определённые структуры данных. В самом низу иерархии типов располагаются классы, которые будут весьма похожи на модули с функциями, только теперь такая архитектура спроектирована с помощью формального способа группировки составляющих её элементов (классов), и предоставляет дополнительные мощные механизмы -- полиморфизм, динамическое связывание, инкапсуляцию и т. п. Она умеет развиваться эволюционно, и всю её пронизывает принцип повторного использования кода.

Таким образом, сформированная в итоге система часто отнюдь не моделирует напрямую "реальный мир", и с точки зрения её архитектуры нельзя ответить на вопрос "что она делает?" -- для децентрализованной схемы он бессмысленный. Результат проектирования и реализации мы оцениваем с точки зрения программной инженерии: насколько проста, гибка, масштабируема система, и насколько точно она отвечает проектным спецификациям (которые сами по себе ничуть не менее реальны, нежели "естественно" воспринимаемые сущности). Выбранные проектировщиком спецификации должны конечно обеспечивать моделирование внешней системы, однако они обычно весьма абстрактны и контринтуитивны для неспециалиста. Умение находить и формализовывать такие абстракции, по большому счёту, и есть мастерство проектировщика.

При этом, конечно, на практике нередки ситуации, когда спецификация неоднократно уточняется, исходя из некоторой оптимальной формы реализации или ограничений фреймворка -- тут нету слепой механической реализации спецификаций, возникает своеобразная рекурсия, но это вполне нормальный подход. Более того, весь цикл анализ - проектирование - кодирование пронизан такой обратной связью и естественно подразумевает итерации. 


16. Приступаем к анализу

Классы в проекте, как ранее отмечалось, делятся на три вида: классы анализа, выделяемые прямым изучением технического задания, классы проектирования и классы реализации.

Классы анализа напрямую связаны с концепциями моделируемого внешнего мира.

Классы проектирования описывают архитектурные решения.

Классы реализации описывают внутренние структуры данных и алгоритмы.

Классы анализа и проектирования -- это высокоуровневые абстракции. Наиболее сложны в поиске и конструировании классы проектирования, связанные с внутренней архитектурой системы. Их невозможно вывести напрямую из ТЗ, тут необходим хороший опыт и интуиция специалиста по проектированию. При этом, что интересно, в плане программирования классы анализа и проектирования как правило просты, в отличие от классов реализации.

Классическое простое правило, причём даже его далеко не всегда придерживаются опытные проектировщики, такое, что класс должен отвечать ровно одной полезной и уникальной цели (принцип единой ответственности SRP). Он действительно должен для чего-то применяться в проекте, и при этом так, что вместо него нельзя использовать никакие другие классы. Это правило всегда рекомендуется применять как минимум для отбраковки сомнительных классов. 


17. Основные источники классов для проекта

"Черпать" из данных источников нередко удачно получается на всех проектных фазах -- анализе, проектировании, разработке.

-- Техническое задание. В качестве потенциальных кандидатов в классы анализируем
-- часто встречающиеся термины,
-- термины, заданные явными, формальными определениями,
-- термины, не определённые точно, но считающиеся само собой разумеющимися.
Не обращаем особого внимания на существительные и глаголы.

-- Обсуждение с заказчиками и потенциальными пользователями.
В качестве потенциальных кандидатов в классы анализируем
-- важные абстракции предметной области,
-- специфический жаргон предметной области.
Учитываем, что потенциальные классы из "внешнего мира" могут описывать как материальные, так и концептуальные объекты.

-- Обсуждения с опытными проектировщиками. Добавляем классы проектирования, успешно использованные ими в схожих предыдущих проектах.

-- Предыдущий опыт. Классы, успешно задействованные в прежних проектах (особенно те, которые были добавлены в стандартную проектную библиотеку) и прошедшие проверку практикой, с большой вероятностью будут востребованы и в новом проекте по схожей тематике или со схожей внутренней архитектурой.

-- Документация, руководства пользователей для похожих систем в этой же проблемной области (например, у конкурентов). В качестве потенциальных кандидатов в классы анализируем моменты из пункта по ТЗ, а также полезные абстракции проектирования.

-- Литература по ОО-проектированию. Добавляем классы проектирования, отражающие подходящие шаблоны проектирования.

-- Литература по алгоритмам и структурам данных. Добавляем в виде классов реализации подходящие структуры данных, поддержанные эффективными алгоритмами.

-- Любые данные в проекте, которые поступают в систему из внешних источников (базы данных, сеть, файлы, ...) или которые явно "меняются" (имеют состояния), и которые семантически достаточно независимы, всегда желательно выделять в отдельную сущность, которая будет допускать изменение и иную обработку своего состояния через набор операций над ней.

-- Необъектные абстракции (например, сгруппированные наборы стандартных математических функций).

-- Если между модулями (классами) наблюдается большое количество связей, различная информация активно передаётся длинным набором параметров, списком или словарём, это частый признак, что такие передающиеся данные желательно выделить в отдельный класс (структуру данных).

-- Активно используемый в проекте класс, который вроде бы требуется модифицировать -- потенциальный кандидат на закрытость по принципу Открыт-Закрыт. Его текущий набор операций уже применяется в проекте, и вносить правки в его спецификацию нежелательно. В таком случае лучше создать наследника, в котором и реализовать нужную специализацию или расширение.

Новые классы желательно продумывать так, чтобы они воплощались частично реализованными (см. далее), чтобы они задавали не просто конкретные структуры данных, а категории достаточно высокого уровня абстракции. Делайте акцент прежде всего на проектировании, откладывая по возможности реализацию до момента её прямой востребованности. 


18. Находим классы анализа

Классы анализа -- это классы, напрямую моделирующие сущности реального мира. Как уже отмечалось, методологически корректнее говорить не о реальном мире, а о внешнем мире -- внешнем по отношению к замкнутому внутреннему миру создаваемой программной системы. Программная модель внешнего мира будет операционной -- это значит, что она формирует объективные практические результаты, и может как-то взаимодействовать с окружающим её миром.

На шаге анализа изучается техническое задание или конкретная предметная область внешнего мира -- прочитываются от начала до конца 2-3 раза с кратким конспектированием наиболее важных моментов. Далее начинается подробное изучение ТЗ, в процессе которого выделяются "непрограммные" абстракции. При этом соответствующие АТД сами по себе могут быть весьма абстрактными, нематериальными: например, в дополнение к классу Автомобиль вполне может быть выделен класс УдобствоВождения, если одна из важных целей проекта -- это прямое изучение такого удобства. Другой классический пример -- это класс УлыбкаЧеширскогоКота.

То есть хорошее итоговое множество классов анализа характеризуется не близостью этих классов явным сущностям изучаемой предметной области, а их долгосрочной значимостью для всего проекта. А классы, выделяемые легко и естественно, обязательно надо тщательно пересматривать и перепроверять по схеме, которую мы рассмотрим далее -- действительно ли они подходят проекту.

Задание 3. Выделите основные классы анализа (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Важно: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


19. Находим классы реализации

Классы реализации задают универсальные, достаточно простые и фундаментальные (в рамках проекта) структуры данных наподобие связных списков или динамических массивов. Особенность в том, что, как правило, их реализация должна быть очень эффективной, что существенно затрудняет кодирование и подразумевает хорошее знание алгоритмов и computer science. Ошибка в выборе алгоритма может обойтись весьма дорого.

Но, как правило, классы реализации легко опытным проектировщиком выявляются, и вдобавок, в стандартных библиотеках обычно доступны самые разные универсальные структуры данных, и достаточно лишь немного их переопределить или расширить под конкретные задачки, а очень часто просто взять готовые.

Готовые классы реализации из стандартных библиотек (списки, словари, деревья, ...), которые используются "как есть", без модификации, включать в проектный список АТД и специфицировать, конечно, не нужно.

Задание 4. Подумайте, потребуются ли вам в проекте специфические структуры данных (например, какие-то особенные способы хранения объектов), поддерживающие и организующие работу с классами анализа, или достаточно будет обойтись возможностями стандартных библиотек.

Выделите при необходимости основные классы реализации (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Важно: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


 
20. Находим классы проектирования

Классы проектирования добавляются в проект обычно двумя путями: проектировщик использует свой прежний успешный опыт или готовые архитектурные решения (прежде всего классические паттерны проектирования) из соответствующей литературы.

Общий принцип остаётся прежним: лучше повторно использовать уже проверенные готовые решения, нежели изобретать самостоятельно.

Классы проектирования правильнее понимать как "машины" (например, машины состояний, "активные" структуры данных с достаточно сложной внутренней логикой и композицией других классов) или "фабрики" (генераторы объектов), нежели как простые сущности.

Задание 5. Выделите основные классы проектирования (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Классы реализации, и особенно классы проектирования далеко не всегда удаётся полноценно выделить на первом этапе анализа. Они часто добавляются в проект уже на этапе проектирования.

Важно-1: но если вы зацепитесь за предыдущую фразу и напишете что-то вроде "На данном этапе трудно выделить классы данного типа. Будет дополнятся по мере продвижения...", значит вы уже двигаетесь явно не туда, пока ваше проектирование -- совсем поверхностный карго-культ.
Подумайте как следует, сформируйте хотя бы 3-5 подходящих классов. Конечно это трудно и всегда будет трудно!
Фраза "далеко не всегда удаётся полноценно выделить..." относится к взрослым серьёзным проектам, а не к учебным.

Важно-2: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


21. Отбраковка плохих классов

Идентификация классов -- процесс двойственный. Он подразумевает как выдвижение кандидатов на АТД и их последующий отбор, так и отсеивание неподходящих. Изучим прежде всего хорошие критерии отбраковки классов. Этот момент в классических методиках ООАП почему-то почти не рассматривается, а в итоге уже с первых строчек технического задания начинается непрерывное выделение классов, и через несколько страниц это приводит к нескончаемому потоку потенциальных АТД.

Основные рекомендации по отбраковке потенциальных АТД:

-- кандидат не подходит, если он инкапсулирует некоторое действие, функцию, а не задаёт структуру данных с оригинальным набором операций (что часто бывает при функциональной декомпозиции). В частности, кандидат отбраковывается, если для него напрашивается название в форме императивного глагола, или инфинитива, или если это полностью реализованный класс с одним публичным методом (он скорее всего реализовывает некоторую функцию, действие, а не структуру данных).
Правильное название класса -- либо существительное, либо прилагательное, описывающее некоторое свойство, характерное для разных структур данных, с окончанием на -able (например, comparable, sortable, ...);

-- кандидат не подходит, если он отвечает на вопрос "этот класс делает ...", если он "выполняет нечто" -- скорее всего, это неподходящая абстракция данных. Класс не должен делать что-то одно важное, все его операции равноправны;

-- кандидат чаще всего не подходит, если он продолжает (или начинает) иерархию классов, когда фаза анализа ещё не закончена. Наследование, как отмечалось на предыдущем курсе, в современных проектах на практике вообще редко используется глубже чем на 2-3 уровня (с учётом классов General и Any, возможно, на 5). Иерархию желательно формировать, только когда основные абстракции проекта уже найдены и хотя бы немного формализованы; при этом, конечно, вполне возможны уточнения выявленных абстракций. То есть спешить с классификацией сущностей никогда не стоит.

-- кандидат не подходит, если это класс без методов. Он может содержать важную информацию, но не реализует АТД. Возможно, в соответствующей спецификации АТД забыли указать набор операций.

-- кандидат не подходит, если это класс без своих полей, или с небольшим их числом, но наследующий атрибуты своих родителей. Вероятно, ошибочно выполнено построение иерархии классов. Скорее всего, возможности этого класса можно корректно делегировать его предкам выше по иерархии.

-- кандидат, как правило, не подходит, если не содержит команды, а только запросы. Возможно, это подобие такого устаревшего типа данных, как "структура" (или современный словарь, допускающий обращение к значениям по ключу), который позволяет работать с его полями напрямую. Исключение из такого случая -- это класс, который инкапсулирует некоторую "неизменяемую" внешнюю сущность (базу данных, сетевой драйвер, информация о работе прибора), и она по определению не должна допускать изменений своего состояния. Два других исключения -- это паттерны наподобие фабрики объектов, которые только создают новые объекты, а также льготное наследование с предыдущего курса (когда например класс содержит лишь наборы констант).

-- кандидат не подходит, если в нём смешаны две или больше разных абстракций. Так бывает например, когда вместо отношения композиции две сущности искусственно сливаются в одну в форме класса, в результате чего набор операций АТД разрастается до явно различных по семантике операций. Такой класс должен быть разделен на несколько классов, по одному на каждую абстракцию.

Задание 6. Отфильтруйте ранее выделенные АТД по этим правилам, укажите, почему вы отказались от тех или иных классов. 


