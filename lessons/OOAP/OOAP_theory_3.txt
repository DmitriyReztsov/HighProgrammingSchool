
1. О методике проектирования на данном курсе

При выборе какой-либо парадигмы проектирования и разработки надо учитывать достаточно много критериев. Но даже в рамках объектно-ориентированного подхода существуют и активно применяются десятки методологий, подчас отличающихся друг от друга весьма сильно.

Методология, изучаемая на данном цикле курсов, предложена Бертраном Мейером. Мы используем обычную концепцию класса из массовых языков программирования, трактуем класс как модуль и как тип. Класс хорошо подходит и для композиции, и для декомпозиции, его можно использовать и на этапе выработки спецификаций АТД, и при проектировании системы в целом, и на шаге реализации.

Наиболее сильные стороны данной методики:

-- Класс -- это универсальная семантическая и синтаксическая единица проекта.

-- Каждый класс в проекте создаётся на основе своей спецификации (АТД). Если исходить из того, что все АТД были проработаны верно, то на их основе "автоматически" получается практически полностью корректная программная система.

-- Высокая робастность/устойчивость системы обеспечивается принципом "любой выход за пределы спецификации -- ошибка". Таким образом формально определяются границы безошибочности системы, а все ошибочные ситуации легко выявляются и обрабатываются, например, единообразным диагностическим способом.

-- Децентрализованная архитектура (отсутствие единственного класса-ядра), автономность всех модулей, простота адаптации к спецификации (внесение изменений в АТД подразумевает простые действия по их реализации в соответствующих классах) обеспечивают высокую гибкость и расширяемость системы.

-- В процессе разработки не требуется какой-то специальный порядок действий. Практически все классы характеризуются низким сцеплением, что позволяет реализовывать их независимо друг от друга -- проект легко разделяется между множеством разработчиков.

-- Повсеместное повторное использование кода как один из главных принципов проектирования иерархий позволяет создавать очень компактные архитектуры.

Легко расширяемую и при этом допускающую простое повторное использование кода систему называют модульной (независимо от того, используется ли в процессе разработки ООП, функциональный подход или что-то ещё). 


2. Ещё несколько плюсов рассматриваемой методологии


- высокая производительность (линейный рост потребления памяти, вычислительных ресурсов, пропускной способности сети при увеличении количества классов в проекте);

- целостность (защита от потенциально вредных модификаций благодаря наличию спецификации АТД);

- верифицируемость (простота тестирования и отладки);

- экономичность реализации;

- простота и восстанавливаемость (имея формальные описания АТД, всегда можно быстро разобраться в системе на более высоком уровне абстракции, нежели обычный код).

Но самым главным плюсом будет прежде всего корректность (правильность) системы. В программной инженерии проводилось множество исследований, которые доказали, что качество системы -- это самая важная характеристика, из которой следуют и короткие сроки реализации, и хорошие показатели самых разных технических параметров.

Корректно (логически правильно) и устойчиво (без ошибок времени выполнения) работающую систему называют надёжной. 


3. Бесшовность жизненного цикла системы

Одна из сильнейших сторон хорошей методики ООАП -- это бесшовность.

Весь жизненный цикл системы, от анализа и проектирования до реализации, тестирования, развёртывания и сопровождения мы можем гладко выполнять с помощью единой методики (набор спецификаций АТД как "законы" и реализующая его замкнутая система классов как "исполнители"), одного объектно-ориентированного языка программирования и общего набора инструментов.

При этом мы везде работаем исключительно с классами как единственным видом модулей. Никакой главной программы и иных глобальных сущностей в проекте нету, всё объединено единой схемой вычислений. Классы обмениваются информацией только через вызов методов и механизм наследования, а различные исключительные ситуации обрабатывает программная "судебная власть" (механизмы реагирования на ошибочные события, которые можно описать формально).

Данная методика положительно отличается от многих других подходов обратимостью: нередко наилучшие проектные идеи приходят уже во время решения, которое оказывает заметное воздействие на саму исходную проблему. По этой причине бесшовность проявляется и в том, что в проекте исчезают изолированные роли аналитиков, интересующихся лишь некомпьютерными концепциями, проектировщиков, которых волнует лишь общая структура, и разработчиков, заботящихся лишь о коде. Человек становится полноценным универсальным специалистом, способным с помощью единой методики ООАП эффективно решать задачи и аналитика, и разработчика, и проектировщика. ООАП уничтожает классические принципиальные различия между этими тремя этапами, теперь в них применяется единая методика, ориентированная на общую цель. По сути, она поднимает классические концепции программирования до уровня достаточно абстрактного средства моделирования.

Мы смотрим на архитектуру объектно-ориентированной системы как на семейство взаимозависимых объектов. По своим взаимодействиям оно замкнуто -- классы общаются только друг с другом и только через публичные интерфейсы АТД. Это так называемая (хорошая) живучесть. 


4. Модульное проектирование

Вспомним предыдущие курсы, где мы трактовали класс как модуль и класс как тип, и занимались проектированием самих классов и связыванием их через композицию и наследование.

Посмотрим теперь так же на проектирование системы в целом.

Начнём с модульного подхода. Мы выяснили, что расширяемость модулей и их повторное использование не сработают как следует, если в проекте нету поддержки модулей как автономных сущностей -- самодостаточных и предлагающих простые связи друг с другом.

Хорошая поддержка модулей должна отвечать пяти критериям модульного проектирования:

1) Декомпозиция -- раскладывание задачи на более простые, более мелкие и независимые подзадачи (для чего в частности требуется поддержка начальной инициализации каждого модуля независимо от всех других);

2) Композиция -- сборка системы из независимых модулей в совершенно других условиях, отличных от их создания (с хорошей поддержкой повторного использования, соответствующие пять принципов для модулей мы изучали на предыдущем курсе);

3) Понятность -- для понимания кода модуля достаточно ограничиться содержимым лишь этого модуля;

4) Непрерывность -- при не слишком сильных изменениях спецификации АТД и других формальных требований к системе потребуется модифицировать один, максимум 2-3 модуля (это означает, что система в целом устойчива, не подвержена ломке);

5) Защищённость -- любые ошибки, возникающие исключения остаются скрытыми внутри модуля и не выходят за его пределы. 


5. Принципы модульного проектирования на практике

1) Прямое отображение: модель системы напрямую отображается в код, в частности, модульная структура системы -- в модули кода;

2) Минимизация интерфейсов: каждый модуль должен поддерживать минимальное количество связей с другими модулями. Для этого либо вводится централизованный модуль (тогда "периферийные" модули поддерживают только одну связь с ним), либо модули связываются в кольцо (через 1-2 связи с соседями);

3) Явные, формально специфицированные интерфейсы -- всё общение между модулями должно выполняться только через них, тогда оно будет прозрачным, простым, читабельным;

4) Слабая связанность интерфейсов -- если между модулями имеется связь, то она должна подразумевать как можно меньший обмен информацией, а сами открытые интерфейсы должны быть спроектированы так, чтобы минимально изменяться при изменении требований/спецификации;

5) Скрытие данных, внешним пользователям модуля явно доступны только публичные методы, набор команд и запросов, обработка ошибок инкапсулирована внутри них.

Ключевой навык проектирования заключается в умении управлять (прежде всего, минимизировать) количеством и формой связей между модулями через унифицированные интерфейсы, скрывая внутреннюю реализацию.

Класс как модуль, как синтаксическая единица неплохо подходит под все эти требования. Однако когда мы попытаемся приступить к проектированию в модульном режиме, нас ждут известные неприятности. 


6. Модульная декомпозиция

Широко распространённая методика проектирования "сверху вниз" (нисходящее проектирование Дейкстры) подразумевает разбиение сложной задачи на несколько более простых (это и называется декомпозиция), а затем выполняется решение каждой из более простых задач по отдельности, по этой же схеме. Если среди более простых задач снова встречается сложная, опять упрощаем её дальнейшим делением. Например, у нас имеется некоторая достаточно глобальная и сложная функция, и мы пока не знаем, как её сразу реализовать, поэтому постепенно детализируем реализацию, представляя в виде нескольких более простых функций (последовательным их вызовом или какой-то комбинацией).

Однако в результате фактически вся такая архитектура будет отражать личное понимание конкретным программистом механизма работы этой функции. Причём сразу будет задан порядок действий (последовательность более простых шагов, вызовов более простых функций), который всегда "хрупок" -- при любых изменениях требований к проекту потребуются сильные модификации такой архитектуры буквально на уровне кода, изменением последовательности шагов. Это очень неэффективная схема, которая подразумевает модульную конструкцию, механически объединяющую группы функций в модули.

Методика "сверху вниз" также большой акцент делает на пользовательском интерфейсе, когда мы начинаем проектирование с декомпозиции глобальных задач, с реализации пошаговых сценариев use case, с CASE-анализа. Но всё это по большому счёту вообще противоречит принципам ООП и приводит к неэффективной модульной структуре.

Модули в такой ситуации создаются в ответ на конкретные подзадачи, на конкретные сценарии работы пользователей, они непосредственно привязаны к контексту исполнения, и в такой ситуации практически невозможно придумать, как сделать их универсальными.

Методика "сверху вниз" хороша при проектировании достаточно простых и понятных систем, требования к которым не меняются. Но она совсем слабо показывает себя при создании эволюционно развивающейся системы, в отношении которой мы пока в принципе не знаем, что нового в ней может появиться. Кроме того, "сверху вниз" -- это скорее метод разработки, подход к реализации технического задания, который сам по себе никак не масштабируется при усложнении этого задания. А при проектировании гораздо важнее формальный способ описания предметной области, построение её гибкой абстрактной модели, на основе которой и будет происходить реализация. 


7. Правильная методика проектирования

Правильная методика объектно-ориентированного проектирования и построения масштабируемой объектной архитектуры подразумевает, что у нас имеется большой мир, в котором взаимодействуют друг с другом примерно равноправные сущности (объекты). Он организован не иерархически (как в случае модульной архитектуры), а плоско, и может легко развиваться эволюционно.

Главное в таком проектировании -- это внутренняя семантика такого мира, его содержание, множество маленьких независимых "смыслов", потому что форма (например, наборы типовых сценариев действий пользователей) всегда очень изменчива.

С помощью ООП мы по сути разрабатываем математическую модель, некоторую алгебру -- наборы формальных операций. А вот какую-либо непосредственную композицию (сценарии использования) носителей этой алгебры (объектов с публичным интерфейсом) мы пока откладываем. Но подразумеваем при проектировании АТД, конечно, какую внутреннюю семантику они должны реализовывать.

Таким образом, этот подход можно назвать проектированием "снизу вверх". На первом шаге мы разрабатываем достаточно универсальные компактные компоненты (даже не объекты, а типы, АТД), из которых потом и составляем наше приложение с помощью системы типов. На втором шаге (который неразрывно связан с первым) мы дополняем наборы операций в типах различными ограничениями (семантикой), требованиями предметной области. Но при этом постоянно придерживаемся более высокого уровня абстракции, нежели прозаические классы в коде (а именно, думаем о проекте всё время в терминах АТД), иначе физическая реализация будет ничуть не лучше, чем в случае функционального подхода "сверху вниз".

Объектно-ориентированное проектирование подразумевает конструирование архитектуры системы из модулей, полностью основанных на типах объектов, с которыми ведётся работа в моделируемой предметной области.

По мере реализации проекта мы последовательно улучшаем наше понимание структур нужных классов, поддерживаем на основе спецификаций АТД устойчивые и семантически легко расширяемые понятия, и выполняем сборку всё более мощных и крупных подсистем, пока не будет получена окончательная работающая система. Причём собирать её из итогового набора АТД обычно можно по-разному. Такая сборка в некотором смысле получается автоматически: мы разрабатываем своеобразный симулятор, подобие компьютерной игры, в котором после его старта самостоятельно действует множество равноправных объектов, обмениваясь друг с другом сообщениями (вызывая методы).

Отсюда следует важный принцип проектирования:
не спрашивайте, что система делает; спрашивайте, кто в системе делает то-то и то-то.

Но напомню, что в результате мы всё же хотим получить действующий прототип: по окончании анализа и проектирования вам потребуется добавить минимальную реализацию классов, и чтобы проект в итоге легко и просто собирался, запускался и работал.

Для этого критически важен скилл т.н. поведенческой композиции. Она состоит из трёх неразрывно связанных моментов:

- способность разбивать большое сложное поведение на части;
- рациональная уверенность, что это разбиение будет корректно работать как одно целое;
- организация реализации и тестирования этих частей такое, которое гарантирует, что вся система ведёт себя именно так, как ожидалось.

Это сложный навык, поэтому я порекомендую уже с первых шагов придерживаться схемы разработки TDD. Как минимум, почитайте с курса карьеры "TDD: разработка, управляемая тестированием", а также материалы СильныхИдей "25) Как правильно писать тесты" и "27) Как правильно понимать TDD".

Безусловно, у всех нас есть некоторое представление о том, как поведёт себя система, когда мы "закончим", иначе мы бы не начинали. Но, используя методику Мейера и поведенческую композицию, мы не заботимся о том, как ведёт себя вся система в деталях, прежде чем мы начнём работу. Мы постепенно записываем свои ожидания по кусочкам в виде тестов, и удовлетворяем эти ожидания step by step в виде дополнений и изменений в коде.

Задание 1.

Составьте предварительное, самое общее, словесное описание системы, которую вы хотите сделать. Придерживаясь принципов модульности, определите в ней 5-7 наиболее общих сущностей (потенциальных АТД), пока кратко и неформально их опишите.

Укажите, что делает в системе каждая такая сущность, стараясь, чтобы из этого множества формулировок "кто что делает" была бы хорошо понятна и общая идея работы системы в целом. 


