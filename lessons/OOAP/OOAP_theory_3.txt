
1. О методике проектирования на данном курсе

При выборе какой-либо парадигмы проектирования и разработки надо учитывать достаточно много критериев. Но даже в рамках объектно-ориентированного подхода существуют и активно применяются десятки методологий, подчас отличающихся друг от друга весьма сильно.

Методология, изучаемая на данном цикле курсов, предложена Бертраном Мейером. Мы используем обычную концепцию класса из массовых языков программирования, трактуем класс как модуль и как тип. Класс хорошо подходит и для композиции, и для декомпозиции, его можно использовать и на этапе выработки спецификаций АТД, и при проектировании системы в целом, и на шаге реализации.

Наиболее сильные стороны данной методики:

-- Класс -- это универсальная семантическая и синтаксическая единица проекта.

-- Каждый класс в проекте создаётся на основе своей спецификации (АТД). Если исходить из того, что все АТД были проработаны верно, то на их основе "автоматически" получается практически полностью корректная программная система.

-- Высокая робастность/устойчивость системы обеспечивается принципом "любой выход за пределы спецификации -- ошибка". Таким образом формально определяются границы безошибочности системы, а все ошибочные ситуации легко выявляются и обрабатываются, например, единообразным диагностическим способом.

-- Децентрализованная архитектура (отсутствие единственного класса-ядра), автономность всех модулей, простота адаптации к спецификации (внесение изменений в АТД подразумевает простые действия по их реализации в соответствующих классах) обеспечивают высокую гибкость и расширяемость системы.

-- В процессе разработки не требуется какой-то специальный порядок действий. Практически все классы характеризуются низким сцеплением, что позволяет реализовывать их независимо друг от друга -- проект легко разделяется между множеством разработчиков.

-- Повсеместное повторное использование кода как один из главных принципов проектирования иерархий позволяет создавать очень компактные архитектуры.

Легко расширяемую и при этом допускающую простое повторное использование кода систему называют модульной (независимо от того, используется ли в процессе разработки ООП, функциональный подход или что-то ещё). 


2. Ещё несколько плюсов рассматриваемой методологии


- высокая производительность (линейный рост потребления памяти, вычислительных ресурсов, пропускной способности сети при увеличении количества классов в проекте);

- целостность (защита от потенциально вредных модификаций благодаря наличию спецификации АТД);

- верифицируемость (простота тестирования и отладки);

- экономичность реализации;

- простота и восстанавливаемость (имея формальные описания АТД, всегда можно быстро разобраться в системе на более высоком уровне абстракции, нежели обычный код).

Но самым главным плюсом будет прежде всего корректность (правильность) системы. В программной инженерии проводилось множество исследований, которые доказали, что качество системы -- это самая важная характеристика, из которой следуют и короткие сроки реализации, и хорошие показатели самых разных технических параметров.

Корректно (логически правильно) и устойчиво (без ошибок времени выполнения) работающую систему называют надёжной. 


3. Бесшовность жизненного цикла системы

Одна из сильнейших сторон хорошей методики ООАП -- это бесшовность.

Весь жизненный цикл системы, от анализа и проектирования до реализации, тестирования, развёртывания и сопровождения мы можем гладко выполнять с помощью единой методики (набор спецификаций АТД как "законы" и реализующая его замкнутая система классов как "исполнители"), одного объектно-ориентированного языка программирования и общего набора инструментов.

При этом мы везде работаем исключительно с классами как единственным видом модулей. Никакой главной программы и иных глобальных сущностей в проекте нету, всё объединено единой схемой вычислений. Классы обмениваются информацией только через вызов методов и механизм наследования, а различные исключительные ситуации обрабатывает программная "судебная власть" (механизмы реагирования на ошибочные события, которые можно описать формально).

Данная методика положительно отличается от многих других подходов обратимостью: нередко наилучшие проектные идеи приходят уже во время решения, которое оказывает заметное воздействие на саму исходную проблему. По этой причине бесшовность проявляется и в том, что в проекте исчезают изолированные роли аналитиков, интересующихся лишь некомпьютерными концепциями, проектировщиков, которых волнует лишь общая структура, и разработчиков, заботящихся лишь о коде. Человек становится полноценным универсальным специалистом, способным с помощью единой методики ООАП эффективно решать задачи и аналитика, и разработчика, и проектировщика. ООАП уничтожает классические принципиальные различия между этими тремя этапами, теперь в них применяется единая методика, ориентированная на общую цель. По сути, она поднимает классические концепции программирования до уровня достаточно абстрактного средства моделирования.

Мы смотрим на архитектуру объектно-ориентированной системы как на семейство взаимозависимых объектов. По своим взаимодействиям оно замкнуто -- классы общаются только друг с другом и только через публичные интерфейсы АТД. Это так называемая (хорошая) живучесть. 


4. Модульное проектирование

Вспомним предыдущие курсы, где мы трактовали класс как модуль и класс как тип, и занимались проектированием самих классов и связыванием их через композицию и наследование.

Посмотрим теперь так же на проектирование системы в целом.

Начнём с модульного подхода. Мы выяснили, что расширяемость модулей и их повторное использование не сработают как следует, если в проекте нету поддержки модулей как автономных сущностей -- самодостаточных и предлагающих простые связи друг с другом.

Хорошая поддержка модулей должна отвечать пяти критериям модульного проектирования:

1) Декомпозиция -- раскладывание задачи на более простые, более мелкие и независимые подзадачи (для чего в частности требуется поддержка начальной инициализации каждого модуля независимо от всех других);

2) Композиция -- сборка системы из независимых модулей в совершенно других условиях, отличных от их создания (с хорошей поддержкой повторного использования, соответствующие пять принципов для модулей мы изучали на предыдущем курсе);

3) Понятность -- для понимания кода модуля достаточно ограничиться содержимым лишь этого модуля;

4) Непрерывность -- при не слишком сильных изменениях спецификации АТД и других формальных требований к системе потребуется модифицировать один, максимум 2-3 модуля (это означает, что система в целом устойчива, не подвержена ломке);

5) Защищённость -- любые ошибки, возникающие исключения остаются скрытыми внутри модуля и не выходят за его пределы. 


5. Принципы модульного проектирования на практике

1) Прямое отображение: модель системы напрямую отображается в код, в частности, модульная структура системы -- в модули кода;

2) Минимизация интерфейсов: каждый модуль должен поддерживать минимальное количество связей с другими модулями. Для этого либо вводится централизованный модуль (тогда "периферийные" модули поддерживают только одну связь с ним), либо модули связываются в кольцо (через 1-2 связи с соседями);

3) Явные, формально специфицированные интерфейсы -- всё общение между модулями должно выполняться только через них, тогда оно будет прозрачным, простым, читабельным;

4) Слабая связанность интерфейсов -- если между модулями имеется связь, то она должна подразумевать как можно меньший обмен информацией, а сами открытые интерфейсы должны быть спроектированы так, чтобы минимально изменяться при изменении требований/спецификации;

5) Скрытие данных, внешним пользователям модуля явно доступны только публичные методы, набор команд и запросов, обработка ошибок инкапсулирована внутри них.

Ключевой навык проектирования заключается в умении управлять (прежде всего, минимизировать) количеством и формой связей между модулями через унифицированные интерфейсы, скрывая внутреннюю реализацию.

Класс как модуль, как синтаксическая единица неплохо подходит под все эти требования. Однако когда мы попытаемся приступить к проектированию в модульном режиме, нас ждут известные неприятности. 


6. Модульная декомпозиция

Широко распространённая методика проектирования "сверху вниз" (нисходящее проектирование Дейкстры) подразумевает разбиение сложной задачи на несколько более простых (это и называется декомпозиция), а затем выполняется решение каждой из более простых задач по отдельности, по этой же схеме. Если среди более простых задач снова встречается сложная, опять упрощаем её дальнейшим делением. Например, у нас имеется некоторая достаточно глобальная и сложная функция, и мы пока не знаем, как её сразу реализовать, поэтому постепенно детализируем реализацию, представляя в виде нескольких более простых функций (последовательным их вызовом или какой-то комбинацией).

Однако в результате фактически вся такая архитектура будет отражать личное понимание конкретным программистом механизма работы этой функции. Причём сразу будет задан порядок действий (последовательность более простых шагов, вызовов более простых функций), который всегда "хрупок" -- при любых изменениях требований к проекту потребуются сильные модификации такой архитектуры буквально на уровне кода, изменением последовательности шагов. Это очень неэффективная схема, которая подразумевает модульную конструкцию, механически объединяющую группы функций в модули.

Методика "сверху вниз" также большой акцент делает на пользовательском интерфейсе, когда мы начинаем проектирование с декомпозиции глобальных задач, с реализации пошаговых сценариев use case, с CASE-анализа. Но всё это по большому счёту вообще противоречит принципам ООП и приводит к неэффективной модульной структуре.

Модули в такой ситуации создаются в ответ на конкретные подзадачи, на конкретные сценарии работы пользователей, они непосредственно привязаны к контексту исполнения, и в такой ситуации практически невозможно придумать, как сделать их универсальными.

Методика "сверху вниз" хороша при проектировании достаточно простых и понятных систем, требования к которым не меняются. Но она совсем слабо показывает себя при создании эволюционно развивающейся системы, в отношении которой мы пока в принципе не знаем, что нового в ней может появиться. Кроме того, "сверху вниз" -- это скорее метод разработки, подход к реализации технического задания, который сам по себе никак не масштабируется при усложнении этого задания. А при проектировании гораздо важнее формальный способ описания предметной области, построение её гибкой абстрактной модели, на основе которой и будет происходить реализация. 


7. Правильная методика проектирования

Правильная методика объектно-ориентированного проектирования и построения масштабируемой объектной архитектуры подразумевает, что у нас имеется большой мир, в котором взаимодействуют друг с другом примерно равноправные сущности (объекты). Он организован не иерархически (как в случае модульной архитектуры), а плоско, и может легко развиваться эволюционно.

Главное в таком проектировании -- это внутренняя семантика такого мира, его содержание, множество маленьких независимых "смыслов", потому что форма (например, наборы типовых сценариев действий пользователей) всегда очень изменчива.

С помощью ООП мы по сути разрабатываем математическую модель, некоторую алгебру -- наборы формальных операций. А вот какую-либо непосредственную композицию (сценарии использования) носителей этой алгебры (объектов с публичным интерфейсом) мы пока откладываем. Но подразумеваем при проектировании АТД, конечно, какую внутреннюю семантику они должны реализовывать.

Таким образом, этот подход можно назвать проектированием "снизу вверх". На первом шаге мы разрабатываем достаточно универсальные компактные компоненты (даже не объекты, а типы, АТД), из которых потом и составляем наше приложение с помощью системы типов. На втором шаге (который неразрывно связан с первым) мы дополняем наборы операций в типах различными ограничениями (семантикой), требованиями предметной области. Но при этом постоянно придерживаемся более высокого уровня абстракции, нежели прозаические классы в коде (а именно, думаем о проекте всё время в терминах АТД), иначе физическая реализация будет ничуть не лучше, чем в случае функционального подхода "сверху вниз".

Объектно-ориентированное проектирование подразумевает конструирование архитектуры системы из модулей, полностью основанных на типах объектов, с которыми ведётся работа в моделируемой предметной области.

По мере реализации проекта мы последовательно улучшаем наше понимание структур нужных классов, поддерживаем на основе спецификаций АТД устойчивые и семантически легко расширяемые понятия, и выполняем сборку всё более мощных и крупных подсистем, пока не будет получена окончательная работающая система. Причём собирать её из итогового набора АТД обычно можно по-разному. Такая сборка в некотором смысле получается автоматически: мы разрабатываем своеобразный симулятор, подобие компьютерной игры, в котором после его старта самостоятельно действует множество равноправных объектов, обмениваясь друг с другом сообщениями (вызывая методы).

Отсюда следует важный принцип проектирования:
не спрашивайте, что система делает; спрашивайте, кто в системе делает то-то и то-то.

Но напомню, что в результате мы всё же хотим получить действующий прототип: по окончании анализа и проектирования вам потребуется добавить минимальную реализацию классов, и чтобы проект в итоге легко и просто собирался, запускался и работал.

Для этого критически важен скилл т.н. поведенческой композиции. Она состоит из трёх неразрывно связанных моментов:

- способность разбивать большое сложное поведение на части;
- рациональная уверенность, что это разбиение будет корректно работать как одно целое;
- организация реализации и тестирования этих частей такое, которое гарантирует, что вся система ведёт себя именно так, как ожидалось.

Это сложный навык, поэтому я порекомендую уже с первых шагов придерживаться схемы разработки TDD. Как минимум, почитайте с курса карьеры "TDD: разработка, управляемая тестированием", а также материалы СильныхИдей "25) Как правильно писать тесты" и "27) Как правильно понимать TDD".

Безусловно, у всех нас есть некоторое представление о том, как поведёт себя система, когда мы "закончим", иначе мы бы не начинали. Но, используя методику Мейера и поведенческую композицию, мы не заботимся о том, как ведёт себя вся система в деталях, прежде чем мы начнём работу. Мы постепенно записываем свои ожидания по кусочкам в виде тестов, и удовлетворяем эти ожидания step by step в виде дополнений и изменений в коде.

Задание 1.

Составьте предварительное, самое общее, словесное описание системы, которую вы хотите сделать. Придерживаясь принципов модульности, определите в ней 5-7 наиболее общих сущностей (потенциальных АТД), пока кратко и неформально их опишите.

Укажите, что делает в системе каждая такая сущность, стараясь, чтобы из этого множества формулировок "кто что делает" была бы хорошо понятна и общая идея работы системы в целом. 


8. О важности связи анализа и проектирования

В весьма известных методиках ООАП предлагается формировать классы, исходя прежде всего из типичных сценариев взаимодействия с пользователем, из организации экранных форм, и т. п. Как уже отмечалось, любой намёк на явную реализацию упорядоченной последовательности действий или событий, или на привязку к пользовательским интерфейсам в полном отрыве от внутренней архитектуры -- это верный признак ошибочного подхода. Последовательности очень часто подвержены модификациям, и последствия таких изменений слабо предсказуемы.

Например, популярная методика CRC (Class, Responsibility, Collaboration; Класс, Ответственность, Сотрудничество) подразумевает использование бумажных карточек, которые разработчики заполняют при обсуждении проекта. В CRC, пожалуй, очень наглядно и проявляется ключевой недостаток множества подобных подходов -- стремление сосредоточиться только на анализе технического задания и требованиях заказчика с полным игнорированием требований внутренней архитектуры проекта, предыдущего опыта проектирования и возможностей стандартных библиотек. Чем больше опыт проектировщика, тем больше он будет выполнять ООАП, опираясь на принцип повторного использования: отыскивая и используя уже готовые классы (причём не только классы анализа, но и классы проектирования и классы реализации), или отыскивая готовые идеи их спецификации, нежели создавая новые классы с нуля. При этом явно подразумевается возможность внесения изменений и в само техническое задание, исходя из наличия таких проверенных классов.

ООП -- это децентрализованная парадигма "кто делает" с акцентом на абстракциях данных, в ней максимально избегается подход "что система делает", характерный для функционального проектирования. В ситуациях, когда в проекте всё же нужна активная поддержка последовательностей действий, можно использовать такие классы проектирования, как машины состояний (или паттерн Command), а пользовательские сценарии детально оформлять в режиме тестирования. 


9. Понятие проектирования

Уточним и обобщим понятие проектирования (и в некотором смысле конструирования) объектно-ориентированной системы:

Объектно-ориентированное проектирование и конструирование -- это формирование программной системы как структурированной совокупности реализаций абстрактных типов данных.

Структурирование выполняется через отношения наследования и композиции с учётом полиморфизма.

В совокупности не выделяется одна или нескольких "главных" реализаций -- все объекты равноправны (что не исключает иерархических схем связи и взаимодействия между ними).

Реализации абстрактных типов данных допускаются частичные.

И это всё.

Отсюда, в частности, следует, что классы (типы взаимодействующих объектов) -- это ключевой ресурс при построении системы, а функции (методы классов) лишь слуги классов. Сами по себе абстрактные функции в системе практически не существуют (кроме, возможно, каких-то стандартных математических и системных), все они представляют собой логически сгруппированные операции конкретных структур данных (методы классов).

Обратите внимание на акцент на частичной реализации (эту форму иногда называют отложенными классами) -- это важная составляющая объектно-ориентированной системы. Отложенный (или частично реализованный) класс, в котором реализованы не все методы (или, если конкретный язык программирования такого не позволяет, некоторые методы скрыты пустыми заглушками или генерацией исключений), фактически представляет собой высокоуровневый модуль с базовым набором операций. Он через наследование выделяет группу взаимосвязанных типов, фиксирует общие свойства поведения такой группы, обеспечивает децентрализованную и расширяемую архитектуру системы. ООП естественно стимулирует создание децентрализованной архитектуры, потому что мы делаем акцент не на порядке выполнения программы, а на конкретных возможностях нашей системы типов, нашего множества классов. 


10. Идеальный цикл ООАП

Идеальный цикл объектно-ориентированного анализа, проектирования и реализации состоит из семи шагов:

Шаг 1. Определяем границы разрабатываемой системы (анализ):

- что будет включено в систему, а что точно не надо в неё включать;
- главные подсистемы;
- пользовательские метафоры (что именно пользователь/заказчик понимает под тем, что в рамках проекта он называет, например, "Автомобиль" или "Товар" или "Клиент");
- функциональность;
- библиотеки повторного использования.

Задание 2.

Выполните этот шаг без детализации, по 3-7 ключевых понятий в компактной формулировке по каждому пункту. 


11. Построение модели предметной области

Шаг 2. Составляем множество классов-кандидатов, имеющих отношение к предметной области (пока не очень формально), с акцентом на потенциальные классы анализа и классы проектирования (анализ).

На протяжении всего цикла разработки анализ - проектирование - реализация мы формируем прежде всего модели конкретных сущностей предметной области. ООП тут выступает хорошей техникой и анализа, и проектирования, и реализации, потому что оно предоставляет простые и сильные механизмы именно для моделирования.

Но что конкретно мы получаем в качестве модели?

Это может быть формальное представление конкретной предметной области, напрямую с программной реализацией не связанное. В таком случае мы используем АТД, задаём спецификации абстрактных типов и взаимосвязи между ними.

Это может быть некоторая реализация модели предметной области с использованием подходящих инструментов -- например, представление в виде базы данных, где таблицы связаны реляционными отношениями.

Это может быть объектно-ориентированный код, в котором задано множество классов, связанных отношениями наследования и композиции.

Это может быть работающая программа, где существует множество объектов, связанных ссылками.

Чем ниже мы спускаемся по этому списку, тем дальше и дальше будет наша модель от моделируемой системы реального мира. Работающая программа -- это модель модели модели, причём на каждом шаге добавляется всё больше специальных вычислительных нюансов.

Поэтому так важно выполнять моделирование, поддерживать и улучшать формируемую модель на самом первом, абстрактном уровне АТД. Причём мы не пытаемся сразу создать модель, которая будет как-то "точно" отражать реальный мир, а выделяем в нём некоторое множество абстракций (идентифицируемых своими наборами операций) и их формальные свойства. Мы не обсуждаем "что есть система", мы изучаем, чем она обладает, и всегда понимаем, что строим частичную модель. Тут лучше переборщить с отсеканием лишнего, которое потом при необходимости можно легко добавить просто как новые АТД, не затрагивающие уже созданную систему. 


12. Как находить и выявлять классы?

В отношении уже первых шагов идеального цикла ООАП сразу возникают три вопроса:

1. Как вообще находить и выявлять такие классы, типы данных?

2. Как эти классы правильно реализовывать?

3. Как описывать отношения между объектами? Как формировать из них подсистемы, иерархии?

Ответ на второй вопрос мы разбирали на первом курсе по ООАП: с помощью выделения абстрактных интерфейсов, независимых от реализации (АТД).

Ответ на третий вопрос мы разбирали на втором курсе по ООАП: с помощью двух видов отношения между классами и объектами (композиция и наследование) и с использованием полиморфизма.

Данный курс посвящён прежде всего ответу на первый вопрос. Часто выделение типов в конкретной предметной области (в частности, практика в таксономии) достаточно очевидно. Хотя чаще всего формирование хорошего множества типов всё же требует приличного опыта объектно-ориентированного проектирования, а правильное содержимое таких множеств классов довольно сильно отличается от начального обыденного, наивного представления. Однако всё же определённая естественность в этом процессе присутствует.

Например, создавая компьютерную игру, естественно выделить родительский класс NPC, от которого унаследовать конкретные расы (гномы, эльфы, ...) -- при условии, что между ними имеются достаточно сильные различия по форме (тогда расширяем потомки дополнительным набором операций) или по содержанию (тогда используем полиморфизм). Если же разница только в значениях атрибутов, будет достаточно одного класса NPC или, для повышения наглядности, льготного наследования. Так же естественно добавить классы (или иерархии классов) Weapon, Armor, Item, Resource, Cell и т. д. 


13. Как выполнять анализ

В анализе, изучении, "моделировании реального мира" надо прежде всего понять, а что такое "реальный мир", что же мы анализируем и моделируем? Всегда это будет только чьё-то, в лучшем случае экспертное, описание мира, но по определению всегда ограниченное и неполное. Поэтому если само анализируемое описание "реального мира" плохое и запутанное, продуктивно работающую программную систему мы создать не сможем.

Все рекомендации для выделения классов (или модулей) предполагают, что у нас имеется техническое задание, как-то более-менее удовлетворительно описывающее моделируемую предметную область, и мы будем этого придерживаться. Откуда взялось само ТЗ, каково его качество, насколько оно непротиворечиво -- тема, к данным курсам прямого отношения не имеющая. Далее исходим из того, что оно соответствует хотя бы здравому смыслу.

Первый принцип анализа: выявляем, идентифицируем подходящие абстракции (но пока не классы программы) в строгих рамках моделируемой области, заданной некоей внешней спецификацией (например, техническим заданием или словесными объяснениями заказчика).

Эти границы мы определили на первом шаге.

Но как же правильно начинать работу над проектом в самом начале, как выявлять абстракции, АТД? Это конечно процесс неформальный, творческий, он зависит от способностей, опыта и даже от удачи. Такая же ситуация и в математике, где не существует готовых рецептов разработки новых теорий и доказательств.

Тут можно лишь привести хорошие идеи и познакомиться с потенциальными опасностями.

Нередко тут применяется уже упоминавшийся функциональный подход, достаточно интуитивный и понятный практически любому. И как это часто бывает в сложных инженерных областях, такие наивные "очевидные", с ходу напрашивающиеся подходы показывают весьма и весьма низкий коэффициент полезного действия. Более того, подобный наивный подход с применением ООП тоже непродуктивен, о чём ранее уже говорилось. Давайте ещё раз разберём, почему, только более детально.

Функциональный подход предлагает делать акцент при анализе ТЗ на глаголах (действиях), а в объектно-ориентированном подходе акцент условно делается на существительных (описаниях объектов).

Например, в ТЗ имеется такой сценарий-пример (среди сотен и тысяч подобных): "гном прячет меч в ножны, поднимает с земли палицу и берёт её в руки в качестве оружия". Функциональный подход подразумевает, что надо специфицировать три функции "Убрать(существо, оружие, инвентарь)", "Взять-в-руки-с-клетки(существо, предмет, клетка-карты)" и "Сделать-оружием(существо, оружие-в-руках)". Объектный подход предлагает выделить классы Гном (точнее, иерархию Существо - Гном и потомки для других рас), Инвентарь, Карта (включающая в себя например массив из объектов класса Клетка), иерархию Оружие с потомками Меч, Палица и др., и добавить им соответствующие методы. В данном случае мы переходим от синтаксиса "Убрать(существо, оружие, инвентарь)" к более наглядному и безопасному "существо.Убрать-в-инвентарь-оружие-в-руках()".

Однако на практике такой прямой и поверхностный анализ ТЗ чаще просто создаёт больше путаницы независимо от того, применяется ли функциональный или объектный подходы. Само техзадание обычно написано нечётко, составляют его представители заказчика, в проектировании не разбирающиеся, поэтому подобные тексты изобилуют двусмысленностями, неточностями, откровенными ошибками, поэтому проектировать объектную архитектуру таким способом весьма опасно. Например, даже в таком простом случае непонятно, надо ли действительно будет формировать иерархию Оружие с потомками Меч, Палица и другими видами оружия, или же достаточно только одного класса Оружие, если конкретные виды оружия достаточно различать только по их числовым характеристикам?

В результате вместо упрощения создаваемая система только больше усложняется: наследование только запутывает её понимание, а формат "объект . метод" создаёт мнооество зависимостей и проблем, связанных с состояниями объектов. 


14. Правильный подход к ООАП

Существительные из ТЗ слишком часто будут провоцировать на выделение классов, которые на самом деле совершенно не будут нужны. Они будут приводить как к появлению лишних кандидатов, так и к пропуску нужных. И хотя успешность тут практически полностью зависит от опыта, интуиции, мастерства аналитика и проектировщика, всё же существует фундаментальный принцип, с которого всегда следует начинать.

Мы выявляем классы с помощью теории АТД, всегда пытаясь понять, будет ли некоторая сущность (гном или меч) независимым типом данных со своим чётко определённым и уникальным набором операций? Или же достаточно воспользоваться уже существующим набором операций класса-предка?

Если у гнома имеются какие-то уникальные возможности (например, пить пиво), недоступные никаким другим расам, то это однозначный признак для выделения АТД "гном" с операцией "пить пиво", наследующего все остальные действия, общие для всех рас. А если например меч отличается от палицы только внешним видом (кодом картинки-изображения) и числовыми характеристиками удара, то достаточно пока обойтись одним классом Оружие.

Вдобавок при этом мы выявили лишь очевидные классы, отражающие "естественные" сущности, однако помимо них наверняка потребуются классы поведения (например, реализующие пресловутые паттерны проектирования), которые задают внутреннюю специфику работы всей системы, её архитектуру, о которых пользователь системы и не подозревает. Возможна и обратная ситуация -- во время работы программы допустимо появление объектов, которые с точки зрения исходной модели имеют разный тип (например, Меч и Палица), однако реализованы одним типом Оружие. В проекте эти моменты определяются исключительно наличием или отсутствием соответствующего АТД.

Правильная методика объектно-ориентированного анализа и проектирования на основе АТД подразумевает, что в системе существуют только такие объекты, для которых формально определено, что с ними можно делать -- в контексте моделируемой предметной области.

Классические, не самые лучшие, объектно-ориентированные подходы к проектированию считают, что имеется готовое полноценные техническое задание, и в процессе его изучения и анализа сразу формируется непосредственная схема решения (реализации) сформулированных задач. В нашей методике наоборот мы не делаем принципиального различия между постановкой проблемы и её решением. Анализ, проектирование и реализацию надо выполнять, учитывая опыт схожих проектов и возможности используемой платформы, фреймворка, прежде всего их стандартных библиотек с типовыми структурами данных. Техническое задание тут отнюдь не самый руководящий документ, и более того, при необходимости в него желательно вносить коррективы, исходя прежде всего из интересов сильной архитектуры проекта (например, пожертвовать какими-то неважными требованиями). 


15. Ещё о важном преимуществе ОО-подхода

Чем плох модульно-функциональный подход? Хоть он и называется функциональным, но полностью завязан на данные, на состояния системы, обработка которых бессистемно размазывается между модулями, наращивая взаимозависимости между ними. Реакции на действия пользователей, ввод и вывод данных, проверка корректности -- все эти операции зависят от статических состояний и подразумевают программирование множества условных цепочек обработки всевозможных вариантов и условий. В таком случае при добавлении, изменении или удалении состояний приходится вносить правки во множество функций и модулей. Кроме того, если некоторый модуль претендует на универсальность, то он должен обрабатывать вообще все мыслимые состояния из соответствующего диапазона.

Такой подход подразумевает, что мы движемся через анализ, проектирование и реализацию логики обработки данных, но как только мы пытаемся организовать потоки данных через такую функциональную логику, возникает множество побочных эффектов, непрозрачность модулей быстро растёт, и в результате запутанность всего проекта стремительно его усложняет и замедляет. Причём данные тут -- лишь некая второстепенная сущность, простая переменная (содержащая обычное значение, в лучшем случае массив или список), которая перебрасывается между функциями. Фактически этим же грешат и многие методики ООП, отводя объектам как хранилищам данных вторичную роль.

Сильный объектно-ориентированный подход предлагает прямо противоположный принцип: мы начинаем именно с проектирования структур данных и взаимосвязей между ними, а функций полностью погружаются в это всё, представляются в виде простых операций над конкретными структурами данных. В ООП мы постепенно детализируем иерархию АТД, пошагово выделяя общие наборы операций, очень чётко формализуя различие между состояниями сущностей системы. Тут даже нередко можно обойтись только неглубоким наследованием (1-2 уровня) и частичной реализацией, без использования композиции или каких-то сложных форм полиморфизма. Мы плавно формируем архитектуру системы, увязывая все сущности (типы данных) в гармонично согласованные структуры.

При этом, конечно, неявно выполняется и функциональная декомпозиция, только теперь соответствующие функции распределяются по строгим семантическим правилам -- попадают непосредственно в те модули (классы), которые специфицируют определённые структуры данных. В самом низу иерархии типов располагаются классы, которые будут весьма похожи на модули с функциями, только теперь такая архитектура спроектирована с помощью формального способа группировки составляющих её элементов (классов), и предоставляет дополнительные мощные механизмы -- полиморфизм, динамическое связывание, инкапсуляцию и т. п. Она умеет развиваться эволюционно, и всю её пронизывает принцип повторного использования кода.

Таким образом, сформированная в итоге система часто отнюдь не моделирует напрямую "реальный мир", и с точки зрения её архитектуры нельзя ответить на вопрос "что она делает?" -- для децентрализованной схемы он бессмысленный. Результат проектирования и реализации мы оцениваем с точки зрения программной инженерии: насколько проста, гибка, масштабируема система, и насколько точно она отвечает проектным спецификациям (которые сами по себе ничуть не менее реальны, нежели "естественно" воспринимаемые сущности). Выбранные проектировщиком спецификации должны конечно обеспечивать моделирование внешней системы, однако они обычно весьма абстрактны и контринтуитивны для неспециалиста. Умение находить и формализовывать такие абстракции, по большому счёту, и есть мастерство проектировщика.

При этом, конечно, на практике нередки ситуации, когда спецификация неоднократно уточняется, исходя из некоторой оптимальной формы реализации или ограничений фреймворка -- тут нету слепой механической реализации спецификаций, возникает своеобразная рекурсия, но это вполне нормальный подход. Более того, весь цикл анализ - проектирование - кодирование пронизан такой обратной связью и естественно подразумевает итерации. 


16. Приступаем к анализу

Классы в проекте, как ранее отмечалось, делятся на три вида: классы анализа, выделяемые прямым изучением технического задания, классы проектирования и классы реализации.

Классы анализа напрямую связаны с концепциями моделируемого внешнего мира.

Классы проектирования описывают архитектурные решения.

Классы реализации описывают внутренние структуры данных и алгоритмы.

Классы анализа и проектирования -- это высокоуровневые абстракции. Наиболее сложны в поиске и конструировании классы проектирования, связанные с внутренней архитектурой системы. Их невозможно вывести напрямую из ТЗ, тут необходим хороший опыт и интуиция специалиста по проектированию. При этом, что интересно, в плане программирования классы анализа и проектирования как правило просты, в отличие от классов реализации.

Классическое простое правило, причём даже его далеко не всегда придерживаются опытные проектировщики, такое, что класс должен отвечать ровно одной полезной и уникальной цели (принцип единой ответственности SRP). Он действительно должен для чего-то применяться в проекте, и при этом так, что вместо него нельзя использовать никакие другие классы. Это правило всегда рекомендуется применять как минимум для отбраковки сомнительных классов. 


17. Основные источники классов для проекта

"Черпать" из данных источников нередко удачно получается на всех проектных фазах -- анализе, проектировании, разработке.

-- Техническое задание. В качестве потенциальных кандидатов в классы анализируем
-- часто встречающиеся термины,
-- термины, заданные явными, формальными определениями,
-- термины, не определённые точно, но считающиеся само собой разумеющимися.
Не обращаем особого внимания на существительные и глаголы.

-- Обсуждение с заказчиками и потенциальными пользователями.
В качестве потенциальных кандидатов в классы анализируем
-- важные абстракции предметной области,
-- специфический жаргон предметной области.
Учитываем, что потенциальные классы из "внешнего мира" могут описывать как материальные, так и концептуальные объекты.

-- Обсуждения с опытными проектировщиками. Добавляем классы проектирования, успешно использованные ими в схожих предыдущих проектах.

-- Предыдущий опыт. Классы, успешно задействованные в прежних проектах (особенно те, которые были добавлены в стандартную проектную библиотеку) и прошедшие проверку практикой, с большой вероятностью будут востребованы и в новом проекте по схожей тематике или со схожей внутренней архитектурой.

-- Документация, руководства пользователей для похожих систем в этой же проблемной области (например, у конкурентов). В качестве потенциальных кандидатов в классы анализируем моменты из пункта по ТЗ, а также полезные абстракции проектирования.

-- Литература по ОО-проектированию. Добавляем классы проектирования, отражающие подходящие шаблоны проектирования.

-- Литература по алгоритмам и структурам данных. Добавляем в виде классов реализации подходящие структуры данных, поддержанные эффективными алгоритмами.

-- Любые данные в проекте, которые поступают в систему из внешних источников (базы данных, сеть, файлы, ...) или которые явно "меняются" (имеют состояния), и которые семантически достаточно независимы, всегда желательно выделять в отдельную сущность, которая будет допускать изменение и иную обработку своего состояния через набор операций над ней.

-- Необъектные абстракции (например, сгруппированные наборы стандартных математических функций).

-- Если между модулями (классами) наблюдается большое количество связей, различная информация активно передаётся длинным набором параметров, списком или словарём, это частый признак, что такие передающиеся данные желательно выделить в отдельный класс (структуру данных).

-- Активно используемый в проекте класс, который вроде бы требуется модифицировать -- потенциальный кандидат на закрытость по принципу Открыт-Закрыт. Его текущий набор операций уже применяется в проекте, и вносить правки в его спецификацию нежелательно. В таком случае лучше создать наследника, в котором и реализовать нужную специализацию или расширение.

Новые классы желательно продумывать так, чтобы они воплощались частично реализованными (см. далее), чтобы они задавали не просто конкретные структуры данных, а категории достаточно высокого уровня абстракции. Делайте акцент прежде всего на проектировании, откладывая по возможности реализацию до момента её прямой востребованности. 


18. Находим классы анализа

Классы анализа -- это классы, напрямую моделирующие сущности реального мира. Как уже отмечалось, методологически корректнее говорить не о реальном мире, а о внешнем мире -- внешнем по отношению к замкнутому внутреннему миру создаваемой программной системы. Программная модель внешнего мира будет операционной -- это значит, что она формирует объективные практические результаты, и может как-то взаимодействовать с окружающим её миром.

На шаге анализа изучается техническое задание или конкретная предметная область внешнего мира -- прочитываются от начала до конца 2-3 раза с кратким конспектированием наиболее важных моментов. Далее начинается подробное изучение ТЗ, в процессе которого выделяются "непрограммные" абстракции. При этом соответствующие АТД сами по себе могут быть весьма абстрактными, нематериальными: например, в дополнение к классу Автомобиль вполне может быть выделен класс УдобствоВождения, если одна из важных целей проекта -- это прямое изучение такого удобства. Другой классический пример -- это класс УлыбкаЧеширскогоКота.

То есть хорошее итоговое множество классов анализа характеризуется не близостью этих классов явным сущностям изучаемой предметной области, а их долгосрочной значимостью для всего проекта. А классы, выделяемые легко и естественно, обязательно надо тщательно пересматривать и перепроверять по схеме, которую мы рассмотрим далее -- действительно ли они подходят проекту.

Задание 3. Выделите основные классы анализа (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Важно: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


19. Находим классы реализации

Классы реализации задают универсальные, достаточно простые и фундаментальные (в рамках проекта) структуры данных наподобие связных списков или динамических массивов. Особенность в том, что, как правило, их реализация должна быть очень эффективной, что существенно затрудняет кодирование и подразумевает хорошее знание алгоритмов и computer science. Ошибка в выборе алгоритма может обойтись весьма дорого.

Но, как правило, классы реализации легко опытным проектировщиком выявляются, и вдобавок, в стандартных библиотеках обычно доступны самые разные универсальные структуры данных, и достаточно лишь немного их переопределить или расширить под конкретные задачки, а очень часто просто взять готовые.

Готовые классы реализации из стандартных библиотек (списки, словари, деревья, ...), которые используются "как есть", без модификации, включать в проектный список АТД и специфицировать, конечно, не нужно.

Задание 4. Подумайте, потребуются ли вам в проекте специфические структуры данных (например, какие-то особенные способы хранения объектов), поддерживающие и организующие работу с классами анализа, или достаточно будет обойтись возможностями стандартных библиотек.

Выделите при необходимости основные классы реализации (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Важно: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


 
20. Находим классы проектирования

Классы проектирования добавляются в проект обычно двумя путями: проектировщик использует свой прежний успешный опыт или готовые архитектурные решения (прежде всего классические паттерны проектирования) из соответствующей литературы.

Общий принцип остаётся прежним: лучше повторно использовать уже проверенные готовые решения, нежели изобретать самостоятельно.

Классы проектирования правильнее понимать как "машины" (например, машины состояний, "активные" структуры данных с достаточно сложной внутренней логикой и композицией других классов) или "фабрики" (генераторы объектов), нежели как простые сущности.

Задание 5. Выделите основные классы проектирования (АТД) в проекте -- только на уровне их названий (на английском) и краткого описания в несколько слов (на русском).

Классы реализации, и особенно классы проектирования далеко не всегда удаётся полноценно выделить на первом этапе анализа. Они часто добавляются в проект уже на этапе проектирования.

Важно-1: но если вы зацепитесь за предыдущую фразу и напишете что-то вроде "На данном этапе трудно выделить классы данного типа. Будет дополнятся по мере продвижения...", значит вы уже двигаетесь явно не туда, пока ваше проектирование -- совсем поверхностный карго-культ.
Подумайте как следует, сформируйте хотя бы 3-5 подходящих классов. Конечно это трудно и всегда будет трудно!
Фраза "далеко не всегда удаётся полноценно выделить..." относится к взрослым серьёзным проектам, а не к учебным.

Важно-2: если вы будете делать задания для галочки, кое-как, на ходу, не тратя на это много времени, чтобы просто поскорее пробежаться по курсу, то вы не только не обучитесь ООАП, но и наборот, сформируете плохой и кривой навык поверхностного проектирования, который будет приносить в реальном проектировании только новые проблемы и быстро запутывать проект. 


21. Отбраковка плохих классов

Идентификация классов -- процесс двойственный. Он подразумевает как выдвижение кандидатов на АТД и их последующий отбор, так и отсеивание неподходящих. Изучим прежде всего хорошие критерии отбраковки классов. Этот момент в классических методиках ООАП почему-то почти не рассматривается, а в итоге уже с первых строчек технического задания начинается непрерывное выделение классов, и через несколько страниц это приводит к нескончаемому потоку потенциальных АТД.

Основные рекомендации по отбраковке потенциальных АТД:

-- кандидат не подходит, если он инкапсулирует некоторое действие, функцию, а не задаёт структуру данных с оригинальным набором операций (что часто бывает при функциональной декомпозиции). В частности, кандидат отбраковывается, если для него напрашивается название в форме императивного глагола, или инфинитива, или если это полностью реализованный класс с одним публичным методом (он скорее всего реализовывает некоторую функцию, действие, а не структуру данных).
Правильное название класса -- либо существительное, либо прилагательное, описывающее некоторое свойство, характерное для разных структур данных, с окончанием на -able (например, comparable, sortable, ...);

-- кандидат не подходит, если он отвечает на вопрос "этот класс делает ...", если он "выполняет нечто" -- скорее всего, это неподходящая абстракция данных. Класс не должен делать что-то одно важное, все его операции равноправны;

-- кандидат чаще всего не подходит, если он продолжает (или начинает) иерархию классов, когда фаза анализа ещё не закончена. Наследование, как отмечалось на предыдущем курсе, в современных проектах на практике вообще редко используется глубже чем на 2-3 уровня (с учётом классов General и Any, возможно, на 5). Иерархию желательно формировать, только когда основные абстракции проекта уже найдены и хотя бы немного формализованы; при этом, конечно, вполне возможны уточнения выявленных абстракций. То есть спешить с классификацией сущностей никогда не стоит.

-- кандидат не подходит, если это класс без методов. Он может содержать важную информацию, но не реализует АТД. Возможно, в соответствующей спецификации АТД забыли указать набор операций.

-- кандидат не подходит, если это класс без своих полей, или с небольшим их числом, но наследующий атрибуты своих родителей. Вероятно, ошибочно выполнено построение иерархии классов. Скорее всего, возможности этого класса можно корректно делегировать его предкам выше по иерархии.

-- кандидат, как правило, не подходит, если не содержит команды, а только запросы. Возможно, это подобие такого устаревшего типа данных, как "структура" (или современный словарь, допускающий обращение к значениям по ключу), который позволяет работать с его полями напрямую. Исключение из такого случая -- это класс, который инкапсулирует некоторую "неизменяемую" внешнюю сущность (базу данных, сетевой драйвер, информация о работе прибора), и она по определению не должна допускать изменений своего состояния. Два других исключения -- это паттерны наподобие фабрики объектов, которые только создают новые объекты, а также льготное наследование с предыдущего курса (когда например класс содержит лишь наборы констант).

-- кандидат не подходит, если в нём смешаны две или больше разных абстракций. Так бывает например, когда вместо отношения композиции две сущности искусственно сливаются в одну в форме класса, в результате чего набор операций АТД разрастается до явно различных по семантике операций. Такой класс должен быть разделен на несколько классов, по одному на каждую абстракцию.

Задание 6. Отфильтруйте ранее выделенные АТД по этим правилам, укажите, почему вы отказались от тех или иных классов. 


22. Формируем кластеры

Шаг 3. Отбираем итоговое множество классов, удаляя лишние (анализ) и формируем из них кластеры: объединяем классы как модули в логические группы (переход к проектированию).

Замечание по поводу кластеров.

Кластеры нередко зависят друг от друга, но даже если зависимые кластеры не завершены, разработку можно вести, учитывая формальные спецификации необходимых АТД (по сути, публичные интерфейсы классов), или используя их абстрактные или частично реализованные версии. Разработка разных кластеров может вестись параллельно и независимо.

Задание 7. Выполните этот пункт. 


23. Где граница между анализом и проектированием?

Этап выработки спецификаций (исходно не связываемый с реализацией) часто называется анализом или определением задачи, а проектирование относится к построению схемы решения этой задачи. Следующей за ними следует реализация этой схемы. На практике границы между этапами анализа, проектирования и реализации обычно провести достаточно сложно, и сами эти этапы могут смешиваться.

Неплохой критерий для разграничения анализа и проектирования -- это момент, когда мы выявили все возможные АТД в проекте (скорее всего, с предполагаемыми, но пока частичными, весьма ограниченными наборами самых основных операций), но пока не знаем, каким образом и какими способами между ними будут организованы связи. В частности, по этой причине в процессе анализа желательно избегать любого использования наследования.

Другими словами, анализ заканчивается, когда мы перестаём думать о программном проекте неформально. При этом однако, в процессе общения с заказчиком и пользователями, желательно и полезно как раз активно использовать спецификации АТД (наброски), потому что это по сути формальный текст, он строго определён и охватывает как семантику, так и структурные свойства проектных сущностей.

Шаг 4. Начинаем создание формальных спецификаций АТД, выделяем абстрактные, частично реализованные классы и т. д., увязываем их в иерархию (проектирование).

Шаг 5. Продолжаем уточнение формальных спецификаций АТД, подробно и развёрнуто определяем классы в терминах запросов, команд и ограничений (проектирование). 


24. Классы поведения

Класс, частично реализующий АТД, называют классом поведения. Такие классы играют важную роль в проектировании, задавая поведение, характерное для некоторой группы, множества вариантов АТД. Класс поведения фиксирует общее поведение этой группы, а его конкретные варианты воплощаются в потомках. Сам по себе класс поведения может встречаться во множестве и классов анализа, и классов проектирования, и классов реализации.

В отличие от модульного подхода, когда имеются только модули с наборами функций, логика которых настраивается исключительно через их параметры, при использовании классов поведения разработчик формирует своеобразный шаблон системы с пустыми "пазами", в которые он может добавлять свои реализации. Это очень важный момент, отличающий правильный объектно-ориентированный подход от классической разработки, которую нередко сравнивают с конструктором лего (и не в хорошем смысле). Дескать, у нас есть набор простых кирпичиков, и из него можно собрать всё что угодно. Действительно, собрать можно всё что угодно, но правильно спроектированная система должна прежде всего иметь хорошую внутреннюю структуру, допускающую лишь замену некоторых компонентов, что лего-подход никак не подразумевает -- количество вариантов в нём огромно и свобода выбора коварно велика.

Частично реализованные классы также очень полезны на первых шагах проектирования. Мы по сути начинаем понемногу специфицировать нашу рабочую систему, нашу архитектуру, пока не переходя к полной реализации. Идеологически такой подход можно частично сравнить с подходом "сверху-вниз" в том плане, что мы сперва начинаем с высокоуровневого описания, и затем детализируем его. Только в случае классического неверного "сверху-вниз" мы сразу пишем код, активную логику, не проектируя корректную систему в целом, а просто наугад реализуя отдельные пошаговые сценарии.

Наш подход конечно тоже стратегически ориентирован на реализацию (только немного по-другому), так как мы пишем спецификацию системы по сути просто через взаимосвязи между классами с учётом пред- и постусловий. Классификация сущностей в системе реализуется наследованием, а семантика свойств, отличных от явно задаваемых атрибутами классов, задаётся пред- и постусловиями. Это на самом деле большой плюс, потому что многие методики проектирования предлагают слишком абстрактные, слишком нечёткие способы описания системы (например, различные графические нотации), которые потом трудно переводить в код. Мы же используем единый формальный язык (спецификации АТД) и для проектирования, и для программирования, и переход от проектирования к реализации получается очень плавным за счёт активного использования классов поведения.

Задание 8.

Выполните шаги 4 и 5. 

25. Завершение дизайна
Описать схемы создания объектов, обработку событий, тесты для типовых сценариев, особенности взаимодействия с фреймворком


26. Замечание по поводу стандартных библиотек

Создание стандартных библиотек -- это важный методологический приём проектирования. В частности, по завершении проекта полезно выполнить дополнительный шаг обобщения: выделить в стандартную библиотеку для повторного использования в следующих проектах наиболее подходящие для этого классы. Применяются тут, в частности, факторизация и абстрагирование, рассматривавшиеся в конце предыдущего курса.

Мы выделяем в библиотеки все подходящие структуры данных и алгоритмы и поддержку графического интерфейса, а также всевозможные вторичные функции, представимые в виде классов формальных свойств (-able) через структурное наследование.

Задание 10.

Какие классы из текущего проекта вы можете взять в следующий проект? 



27. Замечание про композицию и ссылки на объекты

Важный момент в процессе моделирования, когда мы пытаемся абстрагироваться от реализации (практики, максимально удалённой от исходной модели на базе АТД, которая наиболее близка к "реальности") -- это понимание композиции как составного объекта. Тут всегда исходим из того, что в родительский объект другие объекты вложены "физически", то есть мы не рассматриваем их как объекты, "физически" связанные через ссылки. Понятие программных ссылок на верхнем уровне моделирования отсутствует.

Тут имеется определённая концептуальная проблема, связанная с тем, что на фазе реализации активно применяется концепция ссылок на объекты (и в том числе обычны ситуации, когда много переменных указывают на один и тот же объект), однако на этапах анализа и проектирования мы их принципиально избегаем. В то же время популярные структуры данных (например, списки и деревья) практически во всей классической литературе определяются через понятие ссылки (ссылки на следующий и предыдущий узлы, на родительский и дочерние, и т. д.).

И эта проблема ставит под сомнение вообще саму возможность систематического подхода к моделированию с помощью ООП. Но и разрешается она просто -- прагматически.

Объектно-ориентированный подход -- это прежде всего повторное использование. Поэтому как только в некотором проекте возникает потребность какого-то достаточно сложного и запутанного манипулирования ссылками между объектами, это просто верный признак плохого проектирования.

Так как у нас в проекте имеются только классы, соответственно, ненужное манипулирование ссылками подразумевает какие-то странные, подозрительные физические операции, определённые за рамками этих классов (а эти классы сами по себе всегда модели конкретных структур данных). Но во-первых, в 90% случаев можно воспользоваться стандартными библиотеками, где определены почти все мыслимые часто используемые структуры данных (деревья, стеки, графы, очереди, хэш-таблички...), где вся работа со ссылками скрыта внутри них. Всегда можно соответствующие стандартные классы унаследовать и аккуратно расширить или переопределить их возможности.

Во-вторых, если возникает потребность в какой-то действительно достаточно сложной и оригинальной структуре данных, для которой в стандартных библиотеках подходящего аналога или основы не находится, то это признак, что данная структура как раз и выступает как некий универсальный тип данных. Поэтому её надо особо тщательно продумать и реализовать в качестве нового типа данных, добавляемого в стандартную библиотеку (фундаментальный принцип повторного использования), максимально избегая добавления лишних сущностей наподобие ссылок. В качестве эталонных примеров можно ориентироваться на реализации структур данных из стандартной библиотеки. В исключительных ситуациях, связанных с использованием внешних компонентов, необходимые операции работы с ссылками надо реализовать максимально безопасно и наглядно. 


28. Замечание про метаклассы

В некоторых языках программирования имеется понятие метаклассов -- классов, экземплярами которых становятся сами классы (не объекты, а типы данных). Это позволяет определять наборы свойств, характерные для множеств классов. Метаклассы также позволяют более гибко создавать методы, принадлежащие не объектам, а самим классам, хотя такая возможность нередко поддерживается в формате статических методов. Наконец, метаклассы упрощают получение информации о классах (типах данных), но во всех популярных языках программирования уже имеются развитые стандартные библиотеки для выполнения такой рефлексии. А вот проведение статических проверок типов при использовании метаклассов существенно усложняется, поэтому данную возможность (как и многие другие, формально отличающиеся от классического понятия класса) применять не рекомендуется. В частности, вместо метаклассов нагляднее использовать частично реализованные классы, задающие множества потомков с определёнными характеристиками. 


29. Стоит ли создавать объекты динамически?

В некоторых случаях, например

cat = new Cat("Барсик")

явное, статическое создание объектов (размещение их в памяти, связывание с переменной, ...) компилятор может взять на себя. Но если это происходит например внутри циклов с непредсказуемым количеством итераций, создание объектов будет происходить динамически. Чем выше требования к системе в плане быстродействия и эффективности, тем больше объектов желательно создавать статически. При этом конечно приходится отказываться от многих важных и полезных возможностей (автоматическое управление памятью, рекурсия и др.), однако и время исполнения многих операций в программе тоже становится небольшим и предсказуемым.

В некотором смысле получается, что мы работаем вообще без операционной системы -- в формате изолированного контейнера, где никакой динамической работы с памятью не происходит, и поэтому, в частности, достаточно задействовать для работы системы ровно один процесс. По этой схеме функционируют системы жёсткого реального времени (ОС РВ), встраиваемые например в космические аппараты, где реакция на внешние события должна нередко укладываться в 50-100 микросекунд. Сами ОС РВ создаются по сути именно в такой статической архитектуре: это подчас не готовая операционная система наподобие Windows, а просто набор исходных файлов, которые компилируются вместе с прикладной программой и оптимизируются под её единственное выполнение.

Однако в абсолютном большинстве проектов, когда подобная экономия некритична, лучше организовывать простую и универсальную схему, нежели множество частных и специальных случаев. Всегда надо стараться сохранять систему типов (классов) и их отношения друг с другом максимально простыми, независимо от того, сколь сложную и запутанную систему связанных динамических объектов она порождает в итоге в процессе исполнения программы. 


30. Допустимы ли глобальные объекты?

Несмотря на то, что архитектура объектно-ориентированной системы получается децентрализованной "автоматически" -- каких-то "главных", или глобальных объектов в ней не подразумевается, потребность в них на практике нередко возникает. Это может быть шлюз для подключения к сети, драйвер базы данных, системный монитор событий и т. д. Однако такие "разделяемые", shared-объекты вступают в явное противоречие с ООП -- ведь мы наоборот постоянно стремимся к созданию автономных модулей, максимально изолированных друг от друга. А если вдобавок таких глобальных объектов в проекте получается много?

Одно из возможных решений в рамках ООП -- это создание либо статических функций/классов, либо синглетонов. Статическая функция -- это функция, принадлежащая классу, а не объекту, который для её вызова физически создавать не надо. В более общем случае, можно определить отдельный статический класс, экземпляры которого создавать не допускается.

Расширением этого подхода стал паттерн проектирования Синглетон/Одиночка. Это обычный класс, экземпляр которого однако может существовать в единственном виде. Такой подход более сильный, так как часто требуемая начальная инициализация (например, установка связи с базой данных или настройка сетевого соединения) может явно выделяться в конструктор, а сам объект, глобально существующий в системе в единственном экземпляре, можно передавать в другие функции в качестве параметра.

Однако недостаток этого подхода -- что обращения к таким синглтонам размазываются по всему коду, выполняются бессистемно откуда угодно, и фактически ничем не отличаются от глобальных вызовов. Поэтому данный паттерн лучше реализовывать не в виде статического класса, а в виде обычного класса, создание второго экземпляра которого программно запрещено (технически это решается многими способами). В таком случае мы избавляемся от прямых обращений к синглтону откуда угодно: соответствующий единственный объект получится использовать, только корректно передавая его в качестве аргумента методам, наравне со всеми другими объектами. 


31. Замечание про объектные базы данных

В 1990-е годы был временный бум развития объектных баз данных, которые несколько обогнали время, и через некоторое время интерес к ним полностью сошёл на нет. Казалось, что реляционная модель полностью победила, однако в начале 2000-х этот бум возник снова, в формате так называемых NoSQL систем управления базами данных. Они хорошо подходят для прямого использования в ООП-проектах и нередко позволяют избегать больших ограничений, которые накладывают реляционные СУБД на объектные модели, требуя сложных промежуточных механизмов (Object Relational Mapping и т. д.).

В общем случае любое объектное хранилище должно удовлетворять четырём базовым требованиям:
1) обеспечивать стандартные функции баз данных (CRUD, транзакции, административные функции, права доступа, ...);
2) различать объекты по уникальным идентификаторам;
3) поддерживать инкапсуляцию, допускать скрытие определённых атрибутов объектов, ограничивая к ним доступ средствами самой базы данных;
4) разрешать объектам содержать ссылки на другие объекты.

Для обеспечения реально высокой живучести надо реализовать такой механизм хранения, который бы умел сохранять не только сами объекты, но и текущие связи между ними. Хотя связи между объектами -- вещь довольно условная, которая реализуется как правило через композицию и систему ссылок, однако если мы хотим полностью сохранять в базе некоторое состояние, срез всей нашей системы со множеством динамически созданных объектов, включая и их внутренние состояния, придётся как-то формально (на уровне спецификаций АТД, которые предоставляют только набор операций) определить такую схему сохранения, которая будет учитывать и внутреннюю реализацию классов (в частности, реализацию композиции). Но зато в итоге мы получим возможность в любой момент создавать законченные "слепки", своеобразные дампы нашей системы, и легко и быстро восстанавливать работу всей системы с контрольных точек. 


32. Замечание про пользовательские интерфейсы

Типичная проблема, с которой сталкиваются начинающие проектировщики -- как совместить АТД с пользовательским интерфейсом UI. Обычно для создания UI используются готовые событийно-ориентированные фреймворки, где предлагается большой набор стандартных классов UI (форма, кнопка, меню, список, ...), а разработчику предлагается задавать реакции на те или иные события. Тут нередко возникают затруднения, так как формы, кнопки или меню сами по себе никаких данных вроде бы не хранят, однако программировать приходится в довольно жёсткой и ограниченной событийной парадигме, которая вдобавок нередко реализована весьма странно.

Общая схема тут остаётся прежней. Во-первых, относимся к реакциям на события в UI, как к вызовам методов класса экранной формы например. Такие реакции ничего качественно нового в нашу концепцию не добавляют, они подразумевают выполнение некоторых сценариев, которые мы реализуем как обычно, программной логикой с использованием команд и запросов существующих объектов.

Во-вторых, событие может подразумевать изменение состояния экранного компонента. Как правило, работа с состоянием уже полноценно реализована внутри компонента (что показатель хорошего качества стандартной библиотеки UI), и новых сущностей в проект добавлять не требуется. Например, переключатель автоматически запоминает своё текущее состояние, которое можно прочитать в любой момент.

В-третьих, нередко всё же возникают случаи, когда стандартные возможности надо скрестить с достаточно нетривиальной программной логикой. Обычно так бывает, когда организуется работа со списками или таблицами. Например, список просто отображает объекты в каком-то наглядном однострочном текстовом формате, а требуется организовать некую модификацию объектов, соответствующих выбираемым строкам списка. В таком случае лучше создать наследник стандартного класса Список, в котором инкапсулировать нужную дополнительную логику.

В целом придерживаемся основного принципа: выделяем в классы всё, что подразумевает изменение состояния некоторых данных в программе, в идеале, используя готовые компоненты, или наследуясь от них. Во всех остальных случаях, при реализации различных прикладных сценариев, достаточно просто аккуратно выполнить композицию уже имеющихся наборов операций проектных АТД. В некотором смысле, используем возможности реализованных АТД как встроенный, "скриптовый" высокоуровневый язык программирования внутри нашей программы. 


33. Небольшое теоретическое дополнение

Напомню, что, в контексте проектирования, спецификации АТД задают формальную модель вычислений на соответствующих структурах данных, которые эти типы определяют. Мы не просто теперь можем строить сложные выражения через комбинирование вызовов методов, но и математически представлять понятия системы (программы) и способы её исполнения.

Мы не используем при этом императивных линейных схем, не работаем ни с состояниями объектов, ни с переменными, значения которых могут изменяться во времени, ни с последовательностями действий. Математическая объектно-ориентированная модель основывается на классических методах символьного преобразования выражений: часто можно "вычислить", получить результат, не выполняя все вызовы, а просто упрощая их, работая с ними как с формулами. Например, в алгебре можно выполнять эквивалентные преобразования выражений друг в друга:

(x + y)*(x - y) = x^2 - y^2

не выполняя непосредственных вычислений.

Важный момент, что правила такого вывода, таких преобразований, позволяют доказать истинность любой формулы, выразимой на "языке" нашей объектно-ориентированной модели. Язык нашей "теории" -- это множество корректно построенных (не приводящих к ошибкам компиляции) и осмысленных (не приводящих к ошибкам времени выполнения) выражений, сконструированных из вызовов функций АТД, с корректным в плане типов набором аргументов. Сами аргументы рекурсивно определяются как такие же функции, а их значения должны удовлетворять требованиям предусловия "родительской" функции, параметрами которой они выступают. Такой подход делает нашу ОО-систему формально полноценной математической теорией (понятие полноты в математике).

По этой теме, обязательно изучите в частности материалы "3 способа думания о программе" из СильныхИдей. 


34. Заключительное замечание про инварианты

Мы не затрагивали на курсе такую концепцию ООАП, как инвариант класса, дополняющий пред- и постусловия.

Инвариант -- это набор аксиом, формально задающих внутреннюю логику поведения объекта. Это некое абстрактное "ядро", гарантирующее, что любой экземпляр класса всегда будет соответствовать некоторому набору логических утверждений о нём.

Например, в динамическом массиве размер "виртуального" массива, предоставляемого пользователю через публичный интерфейс, не может превышать размер внутреннего буфера (в частности, он должен быть в 1.5-2 раза меньше). Множество не может содержать одинаковых элементов; в ограниченном стеке никогда не будет более заданного количества объектов, и т. д.

Инвариант отличается от пред- и постусловий тем, что он относится к объекту в целом, а условия -- к конкретным методам.

Инвариант нужен прежде всего для того, чтобы различные комбинации вызовов методов никогда не приводили к ошибочному внутреннему состоянию класса, к нарушению его логической целостности (консистентности). При этом в процессе выполнения конкретных методов инвариант, конечно, может временно нарушаться, однако по их завершении он должен быть полностью восстановлен.

Умение успешно выделять, формировать инварианты -- отдельная большая тема. Она относится уже не столько к проектированию, сколько к следующему шагу -- созданию формально корректных программ.

На практике порекомендую такой приём. Оформите инвариант класса, как некоторый скрытый метод, в котором сосредотачивайте проверки текущего состояния объекта (по аналогии с тем, как вы пишете тесты, добавляете проверки assert и т. д.). В случае ошибки инвариант может генерировать исключение или выводить сообщение в отладочный лог. Добавляйте вызов инварианта во все команды, изменяющие состояние объекта -- в их конец, по окончании такого изменения.

Кроме того, обязательно наследуйте родительский инвариант в классах-потомках. Его нельзя переопределять, но можно расширять дополнительными проверками.

Инварианты активно используются, например, в крупных проектах, где ведётся асинхронная обработка огромного количества запросов. Они обрабатываются так называемыми воркерами, или акторами -- по сути, автономными объектами, которые получают запросы на обработку. Когда логика синхронная, то новый запрос может принудительно поступить воркеру, когда он ещё не обработал текущий запрос, что приводит к ошибкам. А асинхронная модель подразумевает такое глобальное предусловие, что воркер приступает к работе, только если его инвариант не нарушен. Поэтому, закладываясь на инварианты, мы по сути потенциально готовим нашу систему к работе в нагрузочном асинхронном режиме. 


Заключительное задание

Доведите ваш проект до логического завершения: соберите действующий прототип.

Добавьте некоторую минимальную реализацию каждому АТД в вашем проекте, чтобы он нормально собирался и запускался (например, с консольным интерфейсом), и демонстрировал некоторое приемлемое поведение в соответствии с исходным замыслом.

Напишите в документации небольшую инструкцию по сборке проекта, и программные и технические требования к нему.

Если вы делали предыдущие задания не поверхностно, не на "отвязаться", а вдумчиво и глубоко, тогда сборка должна выполниться автоматически и без проблем просто после добавления реализации. Но...


