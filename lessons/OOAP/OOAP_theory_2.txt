
Наследование, композиция и полиморфизм

1. Что такое наследование, композиция и полиморфизм

Наследование -- это прежде всего про повторное использование кода. Это гибкий, мощный и компактный механизм снижения проектной сложности.

Наследование даёт возможность использования уже готовых компонентов, предлагая уточнение (иногда расширение, иногда ограничение) класса-предка и спецификации АТД.

Наследование также подразумевает возможность переопределения реализации метода класса-предка, типов аргументов, типа (результата) работы метода.

Наследование -- это одно из двух фундаментальных видов отношений между классами в ООП.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

Композиция -- это отношение "содержит" (has-a), когда один объект содержит объект другого класса (как поле соответствующего типа).

Наследование может быть единичным и множественным (когда класс наследует возможности сразу нескольких классов).

Наследование тесно связано с полиморфизмом. В общем случае под полиморфизмом понимается способность различных сущностей в программе менять свою "форму" -- становиться объектами разных типов по цепочке иерархии наследования.

Задание 1.
Напишите небольшой пример кода с комментариями, где применяются наследование, композиция и полиморфизм. 


2. Введение

В первом цикле, посвящённом проектированию классов, мы видели, что даже простой подход к правильному проектированию классов на основе АТД как автономных сущностей предоставляет отличные возможности для формирования библиотек классов под конкретную предметную область, которые удобно использовать и модифицировать. Интерфейсы полностью отделены от реализаций; универсальный подход АТД (набор операций, отделённых от состояний) обеспечивает высокую гибкость; предусловия и постусловия позволяют достаточно строго контролировать корректность семантики классов и их целостность. В программировании вообще популярен и хорошо работает принцип Keep it simple, stupid (KISS), предполагающий, что большинство систем работают тем лучше, чем они проще.

Однако когда мы задумываемся о расширении нашего набора автономных классов, оказывается, что для этого требуются более мощные механизмы. В частности, наследование как концепция повторного использования кода позволила нам создать иерархию классов, где никакие методы практически не дублировались, а её структура довольно легко расширялась новыми идеологически схожими классами (различные виды списков). Это соответствие принципу You aren't gonna need it (YAGNI) -- избегание любой избыточной функциональности.

Формальный подход к наследованию подразумевает три принципиально разные возможности:
-- расширение класса-родителя (наследник задаёт более общий случай родителя);
-- специализация класса-родителя (наследник задаёт более специализированный случай родителя);
-- комбинация нескольких родительских классов.

Далеко не все языки поддерживают все эти виды отношений, мы рассмотрим универсальную, не зависящую от языков, концепцию наследования, из которой на практике вы можете применять наиболее подходящие вам приёмы.

Задание 2.
Напишите небольшой пример кода с комментариями, где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя. 

Решения задания 2

Python

class Bicycle: // велосипед
    def __init__(self, wheel_count: int = 2):
        self.wheels = [Wheel() for _ in range(wheel_count)]

class Engine: // электромотор
    def __init__(self, power: float):
        self.power = power
        print('engine power is', power)

# Специализация: шоссейный велосипед -- подтип велосипеда
# Расширение: электровелосипед, дополнен мотором
class ElectricRoadBicycle(Bicycle):
    def __init__(self, power: float):
        super().__init__()
        self.engine = Engine(power)

Java

public class Human{
    // -- voice()
    // -- walk()
    // -- run()
}

public class Worker extends Human{ 
    // специализация класса-родителя, 
    // т.к. рабочий - более частный случай,
    // т.к. все работники - люди, но не все люди - работники
    // -- work()
}

public class Car{
    // -- drive()
    // -- park()
    // -- startEngine()
}

public class AutonomousCar extends Car{ 
    // расширение класса-родителя, 
    // т.к. все самоуправляемые машины
    // являются машинами, но не все машины - самоуправляемы

    // -- autoDrive()
    // -- autoPark()
}



3. Класс как модуль и класс как тип

Класс -- это, как говорилось на первом курсе, и модуль (синтаксическая единица проекта) и тип данных (семантическая единица проекта). Наследование в каждом из этих двух случаев играет разные роли.

1) Класс как модуль.

Класс как модуль означает, что класс выступает базовой синтаксической единицей, и в виде отдельного файла, и в виде автономно компилируемой сущности. Наследование в таком случае выступает прежде всего как механизм повторного использования кода. Когда мы думаем в этой парадигме, то сосредотачиваемся в первую очередь на том, как эффективнее всего избавляться от деталей, как использовать наиболее общие подходы. В программировании это широко известный принцип Don’t repeat yourself (DRY).

Создавая новый модуль, мы опираемся на уже существующий модуль, из которого заимствуем существенную часть базовой функциональности, и дополняем его новой. В таком случае класс рассматривается как поставщик определённых служб, некоторого интерфейса. Модуль, наследующий родительский модуль, расширяет его дополнительными службами.

Реализуя в модуле (классе) "Двухсвязный список" метод left(), отсутствующий в родительском модуле "Универсальный список", мы создаём множество сущностей, к которым применим набор операции универсального списка, и дополнительно набор операций двухсвязного списка. То есть множество наборов операций, применимых к универсальному списку, будет подмножеством множества операций, применимых к двусвязному списку.

В настоящем курсе этот подход через расширение возможностей модуля-предка предлагается считать единственным способом добавления новых модулей в проект.

Когда проект большой, взаимосвязи между модулями неочевидны, поэтому каждый модуль надо стремиться делать легко расширяемым, и при этом максимально автономным -- все его связи с другими модулями должны быть строго (формально) ограничены. Модуль по сути предоставляет некоторый абстрактный интерфейс -- когда мы используем сам модуль в целом, а не запрятанный в нём код.

Задание 3.
Расскажите, как в выбранном вами языке программирования поддерживается концепция "класс как модуль".
Пока мы говорим именно про "классы" в смысле модули -- пространство имен, сборки, пакеты, библиотеки -- все что содержит готовый код и что можно импортировать в свою программу. 


Наследование, композиция и полиморфизм

Решения задания 3

Python

В Python можно классы хранить в модулях, а модули организовывать в пакеты в виде иерархии каталогов.
Можно импортировать, соответственно, класс, модуль и пакет, и работать с ними как с отдельными сущностями.
При этом модуль имеет "конструктор" -- код, который однократно запускается при его первом импорте.

Java

Концепция "класс как модуль" в Java поддерживается например через иерархию каталогов.
Корневой узел такой иерархии называется пакетом (по сути модулем).
Для подключения пакета используется синтаксис
package *name1.name2....*
для импорта
import *name1.name2....* 


4. Реализация расширяемости модулей

Одна из классических проблем расширяемости -- это форма её реализации. Можно либо наследовать функциональность, создавая новые модули, либо настраивать её с помощью различных конфигурационных схем (включая, например, скриптовые языки).

Тут надо отметить некоторую ошибочность классического понятия паттернов проектирования, которые обычно воспринимаются как просто полезные механические конструкции для решения конкретных задач. Однако их реальная ценность прежде всего в возможности повторного использования неких универсальных структур данных, которые мы наследуем и реализовываем, дополнительно расширяем применительно к своему проекту. Это, в частности, упоминавшиеся на прошлом курсе классы поведения, в которых открытый интерфейс описывается с помощью низкоуровневых методов, как правило, отложенных, что обеспечивает высокую гибкость. Если паттерн достаточно крупный, может получиться целый фреймворк, набор модулей, хорошо расширяемый каркас. 


5. Основополагающий принцип открытости-закрытости модуля

Это первый из пяти фундаментальных принципов объектно-ориентированного программирования и проектирования, известный как The Open Closed Principle (OCP). Сами принципы в нынешней форме были собраны в начале 2000-х годов Робертом Мартином ( автором легендарных книг "Чистый код", "Чистая архитектура", "Идеальный программист" и др.) и получили общее название SOLID (от первых букв названий принципов).

Модуль считается открытым, если его можно продолжать расширять.

Модуль считается закрытым, когда он выложен в продакшен, и им можно только пользоваться.

На практике мы получаем парадоксальное требование, что модуль должен быть закрытым, чтобы он поступил в эксплуатацию, но он должен быть открытым для дальнейшей модификации в процессе развития проекта. Представим, что у нас имеется закрытый модуль, и потребовалось что-то расширить в его функциональности, так как никогда не будет гарантии, что мы заранее учли все проектные особенности. Ужасный способ сделать это -- создать полную копию закрытого модуля, и что-то в нём начать менять. Правильно решается эта проблема именно наследованием.

Задание 4.
Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми. 

Решения задания 4

Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Фактически все базовые классы любой стандартной библиотеки не могут быть изменены, чтобы не произошли непредвиденные изменения в системе, поэтому они "закрытые". Но от них можно наследовать конкретные прикладные "открытые" классы, доступные для модификации программисту, которые расширяют или специализируют базовый функционал родительских "закрытых" классов.
Часто такой подход применяется при создании графического интерфейса: например, если требуется кнопка с оригинальным поведением или изображением, она наследуется от стандартного класса Button, после чего в ней переопределяется, например, метод отрисовки.

Хорошей причиной для открытости модуля будет потенциальная польза от его расширения.
Например, сделав модуль "Анализатор логов" открытым, мы даем возможность клиентам самим доопределять изначальнай алгоритм, добавляя нужное им поведение.

Если модуль делает что-то конкретное, без потенциального разнообразия, то это кандидат на закрытость. Например, модуль занимающийся отправкой документов внешнему провайдеру документооборота нужно делать закрытым, так как он делает вполне определенное действие, и расширять его стандартное поведение нет необходимости. 


6. Принципы повторного использования модуля

Полноценный механизм добавления в проект нового модуля, подразумевающего повторное использование кода, должен отвечать всем пяти нижеприведённым принципам.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля;

4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра;

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

На практике выдерживать все эти правила не удаётся. Например, если попробовать использовать механизм стандартных библиотек для реализации модулей, то окажется, что он подходит только для достаточно простых проектов, когда имеются чёткие разграничения между спецификациями, отсутствуют смысловые взаимосвязи, и все функции различаются и синтаксически, и семантически. В лучшем случае удастся выполнить требования принципов 2, 3 и 5.

В некоторых языках поддерживаются пакеты со своими оригинальными именами, раздельной компиляцией, публичным интерфейсом и скрытой реализацией. Пакеты в таком случае выступают как абстрактные модули без реализации, однако тоже они не отвечают, в частности, принципу 4 -- конкретную реализацию придётся выбирать самому программисту.

Возможность переопределения имён в модулях (и в частности, перегрузки операторов для разных типов аргументов) частично хороша, но в целом плохо читабельна, не поддерживает обобщённые типы, и главное, если у некоторых функций имеются различия в семантике, то эти различия должны наглядно отражаться и на уровне синтаксиса, что перегрузка не позволяет по своей сути.

В ООП различаются термины "переопределение" (overridde) и "перегрузка" (overload). Переопределение -- это перезапись логики родительского метода с точно такой же сигнатурой в классе-потомке. Перегрузка -- когда в нескольких реализациях метода внутри одного класса его имя одно и то же, а список аргументов различается.
Хотя в разных языках эти схемы могут и различаться.

Если же мы попробуем использовать шаблоны модулей, параметризованные типами (когда одна и та же реализация применяется к различным видам объектов), то получится фактически, что у нас имеется параметризованный типами открытый универсальный модуль, но напрямую не применимый (потому что это шаблон), и имеется условный набор его конкретных реализаций, закрытых для изменений (так как поддержка параметризации встроена в язык). Это нарушает ключевой принцип открытости-закрытости -- непонятно, как расширять такие шаблоны, не меняя уже использующий их код.

Задание 5.
Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?
(напомню, что пока речь идёт именно о модулях как базовой синтаксической единице, а не о классах) 

Решения задания 5

Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?

Python и Java

1) В обоих языках нет возможности параметрировать модуль типом.

2) Поддерживается создание модуля, объединяющего несколько активно обращающихся друг к другу функций.

3) Поддерживается возможность объединения модулей в пакеты/сборки.

4) На уровне модулей в обоих языках нет "автоматического" полиморфизма. Можно вручную импортировать только нужные функции из модуля "родителя" и переопределить оставшиеся.

5) С помощью композиции можно интегрировать несколько модулей с небольшими отличиями в поведении в один. При этом модуль имеет "конструктор" (код, который однократно запускается при его первом импорте). 


7. Разбираемся с модульным противоречием

Выход из противоречивой модели модуля находится в парадигме ООП. Классические попытки совместить все пять принципов с помощью модулей, компонентов, пакетов, терпят неудачу.

Тема декомпозиции проекта на небольшие автономные сущности изучается в программной инженерии не менее полувека. Идея модулей строится вокруг набора функций, вокруг парадигмы так называемого структурного программирования, а ООП -- вокруг объекта. Это вечные попытки как-то более-менее эффективно разрешить конфликт между данными и функциями/методами их обработки. Подробно тему декомпозиции, построения модели предметной области, проектирования качественной иерархии классов, изучаем на следующем курсе. Пока мы приближаемся к идее, что класс (с использованием наследования и полиморфизма) представляется наиболее оптимальной формой модуля. Только надо всегда помнить, когда мы выполняем декомпозицию, то выделяем классы таким образом, что они представляют собой не просто наборы функций, а прежде всего некоторые структуры данных, которые хоть и описываются только операциями, однако все эти операции имеют семантическое отношение именно к своей структуре данных.

Основа объектно-ориентированного подхода -- это приоритет типов данных над описывающими их операциями. То есть в списке методов класса, который всегда задаёт некоторую структуру данных, не должно быть методов, не имеющих прямого отношения к этой структуре данных.

Задание 6.
Существуют ли ситуации, когда связи между модулями должны делаться публичными?
Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам? 

Решения задания 6

Существуют ли ситуации, когда связи между модулями должны делаться публичными?

В общем случае это нарушение инкапсуляции и принципа единственной ответственности SRP (The Single Responsibility Principle, изучаем далее).
На практике допускаются технические исключения, когда проще и выразительнее сделать общедоступными некоторые связи модуля, которые используются во множестве других модулей. Например, это может быть модуль, содержащий инфраструктурный код (логирование, метрики, ...).
И надо также учитывать, что наличие множества неявных связей (зависимостей) приводит к трудноконтролируемому проекту. Большое количество таких связей -- признак плохого проектирования.

Какие метрики вы бы предложили для количественной оценки принципов организации модулей?

Например, количество семантических единиц в программе, так называемых "сущностей". Хотя слепо минимизировать их тоже будет некорректным.

Формально, между модулями нужно выдерживать как можно меньшую связность, т.е. делать модули независимыми. Поэтому для количественной оценки можно использовать количество связей, исходящих из модуля (модули, от которых зависит данный модуль), и количество связей, входящих в модуль (модули, зависящие от этого модуля).

Соответственно, надо стремиться делать максимально автономные модули (минимизируя исходящие связи). Если у автономного модуля всего одна входящая стрелка, то, возможно, он используется всего один раз, и разбиение на модули было некорректным. Также будет плохим случай, когда связей слишком много, например "все зависят от всех", или когда задействуется слишком много контекста, а используется из него далеко не всё.

Если вы разрабатывали программы, в которых было хотя бы 3-5 классов,как бы вы оценили их модульность по этим метрикам?

Пример 1.
Есть абстрактный класс Pizza и много-много классов, реализующих конкретные виды пицц.
Есть абстрактный класс Coffee и также много-много классов, реализующих конкретные виды кофе.
Есть абстрактный класс Restaurant и классы, реализующие конкретные рестораны, где продается пицца и кофе.
Добавим абстрактный класс Courier и классы, реализующие конкретные типы доставки.
Получаются три семантические единицы: еда, заведение, доставка, которые можно представить в виде разных модулей. Это вполне хороший показатель для проекта, где классов могут насчитываться сотни и тысячи.

Пример 2.
Из 6 классов один был "закрытым". Он был очень перегруженным как публичными, так и условно скрытыми методами. Они в остальных 5 дочерних классах переопределялись (override) в разных комбинациях. Принципы открытости-закрытости и повторного использования нарушались повсеместно, что быстро похоронило программу. 


8. Класс как тип

Во взгляде на класс как на тип мы пытаемся совместить принцип повторного использования кода с расширяемостью, которой не удалось полноценно достичь с помощью модулей. И ключевым в таком подходе к наследованию становится полиморфизм и динамическое связывание.

Посмотрим на отношение класс как тип относительно связываемых значений (объектов) как на отношение включения множеств. Например, множество всех объектов "Двухсвязный список" во время работы программы является подмножеством множества всех объектов "Универсальный список". Причём эти два типа не обязательно наследуются напрямую, между ними может быть цепочка промежуточных типов.

Если же посмотреть на это отношение относительно операций над соответствующими типами (по сути, как на отношение между АТД), то отношение "каждый двухсвязный список является универсальным списком" означает, что любая операция, применимая к родительскому универсальному списку, применима также и к дочернему двухсвязному списку (с учётом того, что эти операции могут быть переопределены в двухсвязном списке), но не наоборот.

То есть в случае "класс как тип" мы получаем не расширение родительского класса, а специализацию, что прямо противоположно подходу "класс как модуль".

В результате на практике появляются подобные частые ошибки: "двухсвязный список my_list_007 в моём коде является универсальным списком". Тут используется отношение между значением и категорией, что неверно. Отношение "является" всегда выражает отношение только между категориями (типами, классами). Например, всякий АТД "Двухсвязный список" является АТД "Универсальный список".

Какой из этих подходов более правильный для понимания принципа наследования? Как может быть разрешён парадокс расширения-специализации? Фактически получается, что чем больше у нас различных типов в цепочке наследования, тем к меньшему количеству объектов они могут применяться, так как мы движемся вниз по иерархии в направлении специализации.

Поэтому в частности, некорректно применение массово распространённого термина "подкласс" и в смысле подмножества, и в смысле наследования. Правильно использовать только такие термины: наследник и родитель, потомок и предок, прямой/собственный потомок и предок. 


9. Динамическое связывание

Наиболее глубокая и при этом достаточно абстрактная (универсальная) форма реализации отношения наследования (в общем случае повторного использования) -- это динамическое связывание. Программисту не требуется постоянно уточнять, метод какого конкретно типа (класса) должен быть вызван, он будет определён автоматически. Это очень важная возможность, которую мы никак не сможем получить, оставаясь в парадигме модулей -- ни универсализм, ни перегрузка операторов, и ничто иное.

Чем плохо статическое связывание? Если можно заранее, анализируя исходные тексты, автоматически определить, какой конкретно тип будет у полиморфного объекта в некотором случае, то эту работу должен выполнить компилятор, и только с целью оптимизации вызовов. Если же программист в такое связывание вкладывает другой смысл, нежели подразумевает компилятор, то это надо считать ошибкой. Так, если программист может выбирать политику статического связывания сам, то легко нарушить принцип открытости-закрытости: может потребоваться модификация класса, закрытого для изменений, которую заранее нельзя было предвидеть. Это можно решить переопределением нужного метода в классе-наследнике, однако если политика статического связывания возложена на программиста, то в таком случае вполне возможна ситуация, когда в предке не задана виртуальность соответствующего изменяемого метода, что потребует внесения правки в вышестоящий класс (уточнение сигнатуры метода), который уже закрыт для изменений. В разных языках эта проблема может проявляться по разному, например в Java все функции по умолчанию считаются виртуальными, а в С++ наоборот, невиртуальными.

В общем случае наследование позволяет создавать новые классы, которые и расширяют, и специализируют уже существующие классы. Это достигается с помощью трёх механизмов: переопределения в классе реализации методов его прямого предка, использования полиморфных объектов и динамического связывания.

При этом правильно спроектированный класс с точки зрения пользователя-программиста в идеале вообще не должен демонстрировать схему своего наследования. Наследование -- это внутренний механизм, и если полиморфизм в отношении класса не подразумевается, то и всю логику наследования для этого класса по возможности желательно скрыть. Такой класс, в отношении которого с точки зрения его пользователя наследование не применяется, называется плоским.

Во всех остальных случаях наследование требуется ровно в тех границах, которые обеспечивают необходимую логику полиморфизма и динамического связывания в проекте.

Задание 7.
Приведите пример кода с комментариями, где применяется динамическое связывание. 

Решения задания 7

Приведите пример кода с комментариями, где применяется динамическое связывание.

Java

class Expression {
    @Override
    public String toString() {
        return "some expression";
    }
}

class SimpleExpression extends Expression {
    @Override
    public String toString() {
        return "some simple expression";
    }
}

class ComplexExpression extends SimpleExpression {
    @Override
    public String toString() {
        return "some complex expression";
    }
}

...

Expression expression = new ComplexExpression();
System.out.println(expression); // "some complex expression"

Python

# вычисление хэш-функции
class IHasher(ABC):
    @abstractmethod
    def hash_fun(self, key: str) -> int:
        pass

class SumHasher(IHasher):
    def hash_fun(self, key: str) -> int:
        acc = 0
        for c in key:
            code = ord(c)
            acc = acc + code
        return acc

class DJB2Hasher(IHasher):
    def hash_fun(self, key: str) -> int:
        # djb2
        acc = 5381
        for c in key:
            code = ord(c)
            acc = (acc << 5) + acc + code
        return acc % 4294967296

hasher: IHasher = SumHasher()
h = hasher.hash_fun("skillsmart") # 1094
print(h)
hasher = DJB2Hasher()
h = hasher.hash_fun("skillsmart") # 458085675
print(h)



10. Пример динамического связывания и полиморфизма

Например, у нас имеется иерархия из трёх классов (Универсальный список ParentList, связный список LinkedList и двухсвязный список TwoWayList), которую мы делали на первом курсе.

Объект p имеет тип ParentList, объект l -- тип LinkedList, и объект t -- тип TwoWayList. Тогда в программе разрешены так называемые полиморфные присваивания:

p = l
p = t

В переменную родительского класса записывается объект (ссылка на объект) дочернего класса.

Так как все объекты передаются по ссылке, в таком случае "изменение" типа объекта по своему смыслу подразумевает подмену некоторых методов, которые реально будут вызываться. Например, если переменная p хранит указатель на объект типа LinkedList, то при обращении p.right() будет вызван метод right() класса LinkedList, о чём разработчик заранее не знает. Объекты из данного и подобных примеров называются полиморфные -- их реальный тип может не совпадать с типом переменной, в которой они хранятся (фактически, в которую записана ссылка на соответствующий объект).

При этом надо иметь в виду возможную потерю информации: несмотря на то, что p хранит ссылку на объект типа TwoWayList, обращаться к методам класса TwoWayList напрямую мы не можем (если только не использовать явное приведение типов, что настоятельно не рекомендуется -- об этом будет рассказано далее). Однако такая потеря компенсируется динамическим связыванием, подразумевающим, что нужный метод полиморфного объекта будет определён динамически -- в зависимости от его реального типа в ходе работы программы.

Аналогичную семантику имеет и полиморфизм при передаче аргументов. Если конкретный язык программирования такое допускает, то в классе могут быть методы с одинаковыми именами, отличающиеся друг от друга типами каких-то аргументов. В таком случае выбор подходящего метода в процессе работы программы тоже происходит динамически и полиморфно. 


11. Ковариантность и контравариантность

Уточняющие комментарии про расширение и специализацию в ходе наследования.

Когда мы смотрим на класс как на тип, то при спуске по иерархии наследования мы получаем всё более специализированные типы, так как всё чаще не можем использовать оригинальные методы предков из-за их переопределения. Например, не имеет смысла двухсвязному списку наследовать методы из однонаправленного списка -- большинство их придётся переопределять. Причём ряд этих методов придётся переопределять только потому, что внутри, в реализации они работают с разными типами (например, с разными типами узлов в списке), а сам алгоритм остаётся по сути оригинальным. Мы просто его копируем, лишь модифицируя объекты некоторых типов. Не возникает никаких конфликтов с системой типов, однако эта система типов и никак нам не помогает в избегании дублирования кода (или как минимум, дублирования семантики).

Проблема в подобных случаях по сути единственная: нам надо сохранить родительскую логику, "параметризуя" её типами. Тут надо исходить из возможностей конкретного языка программирования, позволяет ли он автоматически связывать, по мере спуска по иерархии, типы атрибутов класса с типом текущего объекта без явного переопределения логики (определения типов полей мы задаём относительные, а не абсолютные -- относительно текущего типа). Это так называемая ковариантная типизация. Чаще всего она реализуется в форме обобщённых типов: если мы определяем контейнер, параметризованный типом Кот (который есть потомок типа Животное), то естественно, что этот тип "контейнер котов" автоматически будет потомком (частным случаем) типа "контейнер животных" (ковариантность типу-параметру Кот), и ему будут доступны все соответствующие методы типа-предка.

Другая схема ковариантности: переопределённый метод родительского класса может возвращать значение типа, который есть потомок типа значения, возвращаемого родительским методом.

Противоположный подход -- контравариантность, когда схема наследования переворачивается. Тут классический пример -- это делегаты (объекты, указывающие на функции). Есть обобщённый (параметризованный типом "Универсальный список") делегат "действие A над универсальным списком", который считается уже потомком делегата "действие А над связным списком" (при том, что связный список -- потомок универсального списка). В таком случае, подразумевая действия над универсальными списками, мы корректно сохраняем допустимость для них лишь ограниченного набора операций для связных списков, и не более. Потому что некоторое действие, специфичное именно для связного списка, нельзя применять к его предку, универсальному списку, такое действие не поддерживающему.

Это более простой формальный подход, так называемый subtyping, в чём-то более элегантный, однако на практике рекомендуется всегда ориентироваться на более практичные ковариантные подходы, подразумевающие специализацию кода, более естественно отражающую иерархию наследования.

Задание 8.

Приведите примеры кода с ковариантностью и контравариантностью, если ваш язык программирования это позволяет. 

Решения задания 8

Приведите примеры кода с ковариантностью и контравариантностью.

Python

Пример 1

#ковариантность

from typing import Generic, TypeVar, Callable

animal = TypeVar('animal', covariant=True)

class Animal(): pass
class Cat(Animal): pass

# Контейнер на вход принимает любой объект типа Anuimal
class Box(Generic[animal]):
    def __init__(self, content: animal) -> None:
        self._content = content

# Можно проверить контейнер с животным, 
# а значит, и с котом, как частным случаем животного
def check_box(box: Box[Animal]):
    pass

box = Box(Cat())
check_box(box)

#контравариантность

class Person(): pass
class Sportsman(Person): pass
class Policeman(Person): pass

def person_run(person: Person) -> None:
    print('Person running')

# Спортсмен и полисмен могут бегать: 
def sportsman_run(sportsman: Sportsman) -> None:
    print('Sportsman running. So fast!')
def policeman_run(policeman: Policeman) -> None:
    print('The policemen don\'t run. He shoots.')

# ковариантным типом по документации считается Callable
def make_sportsman_run(sportsman: Sportsman, run_func: Callable[[Sportsman], None]):
    print('Shoot in the air with gun!')
    run_func(sportsman)

# подойдёт даже обычный Person
make_sportsman_run(Sportsman(), person_run)

# а вот на типе Policeman будет ошибка
make_sportsman_run(Sportsman(), policeman_run)

Пример 2

# ковариантность

class Sword: pass
class FuryBlade(Sword): pass

class Knight:
    def get_melee_weapon(self):
        return Sword()
class Paladin(Knight):
    def get_melee_weapon(self):
        return FuryBlade()

knigt, paladin = Knight(), Paladin()
s, fb = knigt.get_melee_weapon(), paladin.get_melee_weapon()

isinstance(s, Sword), isinstance(s, FuryBlade)
# (True, False)

isinstance(fb, Sword), isinstance(fb, FuryBlade)
# (True, True)

# контравариантность

from typing import TypeVar, Generic

T_contra = TypeVar('T_contra', contravariant=True)

class _T(Generic[T_contra]):
    def __init__(self, item: T_contra) -> None: ...

class BladedWeapon: pass
class Sword(BladedWeapon): pass
class Broadsword(Sword): pass
class Cutlass(Broadsword): pass
class Shuriken(BladedWeapon): pass

def sharpen_melee_weapon(weapon: _T[Broadsword]) -> None: pass

sword1, sword2 = _T(Broadsword()), _T(Sword())
sharpen_melee_weapon(sword1)  # OK
sharpen_melee_weapon(sword2)  # OK

shuriken = _T(Shuriken()) 
# error: "sharpen_melee_weapon" has incompatible type _T[Shuriken]
sharpen_melee_weapon(shuriken) # error

cutlass = _T(Cutlass()) # error ...
sharpen_melee_weapon(cutlass) # error

Java

// Ковариантность:
List<Integer> l1 = new ArrayList<>();
l1.add(42);
List<? extends Number> l2 = l1; // read-only список. 
// Безопасное приведение потомка(Integer) к родителю (Number)


// Контравариантность:
List<Number> l3 = new ArrayList<>();

List<? super Double> l4 = l3; // write-only список. 
// Безопасное приведение родителя (Number) к потомку (Double)

// Такой механизм позволяет обходить небезопасное приведение типов,
// когда в List<Double> могут оказаться значения типа Integer, 
// если сначала List<Double> привести к List<Number>



12. Общая структура иерархии классов в проекте

Несмотря на то, что для пользователей прикладной системы типов в проекте каждый класс в идеале должен быть плоским, внутри проекта все классы, также в идеале, надо объединять в одну иерархию.

Во главе этой иерархии располагается самый базовый, абстрактный (не допускающий создания экземпляров) класс (например, General), содержащий фундаментальный набор операций:
-- копирование объекта (копирование содержимого одного объекта в другой существующий, включая DeepCopy -- глубокое рекурсивное дублирование, подразумевающее также копирование содержимого объектов, вложенных в копируемый объект через его поля, атрибуты);
-- клонирование объекта (создание нового объекта и глубокое копирование в него исходного объекта);
-- сравнение объектов (включая глубокий вариант);
-- сериализация/десериализация (перевод в формат, подходящий для удобного ввода-вывода, как правило в строковый тип, и восстановление из него);
-- печать (наглядное представление содержимого объекта в текстовом формате);
-- проверка типа (является ли тип текущего объекта указанным типом);
-- получение реального типа объекта (непосредственного класса, экземпляром которого он был создан).

Когда мы добавляем в проект новый класс, не имеющий явного предка в текущей прикладной иерархии, он должен получить предком универсальный класс General (точнее, Any -- см. следующий абзац). Во многих языках программирования стандартная система классов уже предлагает подобный универсальный класс (например, Object в C# и Java), и любой прикладной класс в программе по умолчанию считается его потомком.

Однако рекомендуется оформить верхушку иерархии в виде двух классов. Самый верхний класс General содержит упомянутый набор операций, и полностью закрыт для изменений. Его прямой потомок (например, Any) ничего нового по умолчанию не вносит, но открыт для модификации, и все новые классы в проекте, не имеющие предка в прикладной иерархии, наследуются от Any. Архитектор проекта при необходимости вносит какие-то общие компоненты именно в класс Any.

Сформулируем попутно важный прикладной принцип повторного использования: каждый АТД/класс надо стараться передвигать как можно выше в иерархии наследования (повышать уровень абстракции), чтобы у него появлялось как можно большее количество классов-потомков, а сам он концентрировал в себе как можно больше общих черт.

Задание 9.

Постройте в вашем языке программирования базовую иерархию из двух классов General и Any. Унаследуйте General от универсального базового класса, если таковой имеется в языке или стандартной библиотеке/фреймворке, и реализуйте семь фундаментальных операций для него, используя для этого по возможности возможности стандартных библиотек. 

Решения задания 9

Постройте в вашем языке программирования базовую иерархию из двух классов General и Any.

Python

_T = TypeVar('_T')


class General(object):

    COPY_NIL = 0       # copy_to() not called yet
    COPY_OK = 1        # last copy_to() call completed successfully
    COPY_ATTR_ERR = 2  # other object have no attribute copied from this object

    def __get_status_fields(self) -> set:
        fields = set(attr for attr in dir(self)
                     if attr.endswith('status'))
        return fields

    def __init__(self, *args, **kwargs):
        self._copy_status = self.COPY_NIL

    # commands:
    @final
    def copy_to(self, other: _T) -> None:
        """Deep-copy of attributes of **self** to **other** with
        ignoring status-attributes."""
        status_fields = self.__get_status_fields()
        copy_attrs = filter(lambda a: a not in status_fields,
                            dir(self))

        if not all((hasattr(other, a) for a in copy_attrs)):
            self._copy_status = self.COPY_ATTR_ERR
            return

        for attr in copy_attrs:
            value = deepcopy(getattr(self, attr))
            setattr(other, attr, value)

        self._copy_status = self.COPY_OK

    # requests:
    @final
    def __eq__(self, other: _T) -> bool:
        return self.__dict__ == other.__dict__

    @final
    def __repr__(self) -> str:
        s = f'<"{self.__class__.__name__}" instance' \
            f' (id={id(self)})>'
        return s

    @final
    def clone(self) -> _T:
        clone = deepcopy(self)
        return clone

    @final
    def serialize(self) -> bytes:
        bs = pickle.dumps(self)
        return bs
    @final
    @classmethod
    def deserialize(cls, bs: bytes) -> _T:
        instance = pickle.loads(bs)
        return instance

    # method statuses requests:
    @final
    def get_copy_status(self) -> int:
        """Return status of last copy_to() call:
        one of the COPY_* constants."""
        return self._copy_status


class Any(General):
    """
    >>> a = Any()
    >>> isinstance(a, Any), isinstance(a, General)
    (True, True)
    >>> type(a) == Any, type(a) == General
    (True, False)
    >>> b = Any()
    >>> a.copy_to(b)
    >>> a.get_copy_status() == a.COPY_OK
    True
    >>> a == b, a is b  # different because of _copy_status
    (False, False)
    >>> bs = a.serialize()
    >>> deser_a = Any.deserialize(bs)
    >>> a == deser_a, a is deser_a
    (True, False)
    >>> a_clone = a.clone()
    >>> a == a_clone, a is a_clone
    (True, False)
    >>> class A(Any):
    ...     def __init__(self, nested_dict: dict, **kwargs):
    ...         super().__init__(nested_dict, **kwargs)
    ...         self.d = nested_dict
    >>> nested1 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: None}}}})
    >>> nested2 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: None}}}})
    >>> nested1 == nested2
    True
    >>> nested3 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: ''}}}})
    >>> nested1 == nested3
    False
    """

Java

class General implements Serializable {
    public <T> void deepCopy(T target) throws Exception {
        try {
            target = getCopy();
        } catch (Exception e) {
            throw e;
        }
    }

    public <T> T deepClone() throws Exception {
        try {
            return getCopy();
        } catch (Exception e) {
            throw e;
        }
    }

    @Override
    public boolean equals(Object obj) {
        return super.equals(obj);
    }

    public <T> String serialize() throws JsonProcessingException {
        var mapper = new ObjectMapper();
        return mapper.writeValueAsString((T)this);
    }

    public static <T> T deserialize(
                        String json, 
                        Class<T> clazz) throws JsonProcessingException {
        var mapper = new ObjectMapper();
        return mapper.readValue(json, clazz);
    }

    @Override
    public String toString() {
        return super.toString();
    }

    @JsonIgnore
    public final Class<?> getType() {
        return this.getClass();
    }

    private <T> T getCopy() throws Exception  {
        try {
            var byteArrayOutputStream = new ByteArrayOutputStream();
            var objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject((T)this);
            var bais = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            var objectInputStream = new ObjectInputStream(bais);

            return (T) objectInputStream.readObject();
        }
        catch (Exception e) {
            throw e;
        }
    }
}

/*public*/ class Any extends General {

}


13. Принцип Открыт/Закрыт применительно к иерархии классов

Если позволяет конкретный язык программирования, для ряда классов желательно полностью запретить возможность переопределения ряда их методов (например если так требует спецификация и мы хотим, чтобы реализация гарантированно с ней совпадала). В таком случае, во-первых, мы формально поддерживаем принцип открытости-закрытости, и во-вторых, всегда нежелательно переопределять универсальные операции, входящие в General.

В крайнем случае можно создать например две версии операций копирования -- одну закрытую, и другую открытую для переопределений (возможно, как абстрактный метод, или по умолчанию вызывающую закрытую версию). Только при создании таких открытых версий желательно добавлять подобные открытые версии и для схожих по смыслу операций (например, разрешая переопределять копирование, надо создать также и две операции клонирования) -- из соображений единой семантики. Однако, по умолчанию такие пары методов должны быть закрыты, если открытость для них по спецификации не требуется.

Задание 10.

Выясните, имеется ли в вашем языке программирования возможность запрета переопределения методов в потомках, и приведите пример кода. 

Решения задания 10

Запрещаем переопределение методов в потомках.

Python

"""
Возможность запрета и для методов, и для классов, 
появилась в Python 3.8 -- 
с помощью декоратора @final
"""

class Base:
    @final
    def do_not_override_this(self) -> None: ...

class A(Base):
    # error: Cannot override final attribute "do_not_override_this"
    # (previously declared in base class "Base")
    def do_not_override_this(self) -> None: ...


@final
class FinalBase: ...

class B(FinalBase): ...
# error: Cannot inherit from final class "FinalBase"

Java

Для этого используется ключевое слово final.

public final Class getType() 
{ return this.getClass(); } 


14. Замыкание иерархии

Если система классов конкретного языка допускает множественное наследование, проектную иерархию желательно замкнуть также и снизу: добавить пустой закрытый класс None, потомок всех классов. Все классы-листья (не имеющие потомков) становятся прямыми предками None, и в итоге вся иерархия получается замкнутой снизу в форме математической решётки.

В таком случае класс None начинает играть роль пустой ссылки void, которая эмулируется в некоторых языках значением null/none. Добавлением класса None, который выступает аналогом отсутствия значения, мы остаёмся полностью в рамках чистой объектной прикладной системы типов нашего проекта. Так как None потомок всех классов, можно без ограничений использовать значение Void типа None в качестве значения переменной любого типа (класса), добавив его в проект как стандартный глобальный объект.

Однако далеко не все современные языки поддерживают множественное наследование, поэтому, хотя подход с использованием null заслуженно считается порочным, так как сильно ослабляет всю систему типов, вводя некоторую непонятную сущность полностью за пределами этой системы, к использованию null всё же приходится прибегать.

К сожалению, это серьёзная уязвимость модели ООП, потому что даже наличие в проекте значения Void никак не страхует от некорректной последовательности команд:

x = Void;
...
x.foo();

что приведёт к исключительной ситуации. В частных случаях можно добавлять проверки вида

if x == Void then ...

Однако общим решением будет только контроль исключительных ситуаций. Ответственность за правильную работу со значениями Void/null в ООП полностью возлагается на программиста, система статической проверки типов тут никак не поможет.

Задание 11.

Если используемый вами язык программирования допускает множественное наследование, постройте небольшую иерархию, используя уже готовые General и Any, и замкните её снизу классом None. Приведите пример полиморфного использования Void. 

 Python

В Python нету проверок типов, поэтому можно создать любой класс без предков/потомков, не входящий в нашу систему типов, унаследованную от General.

Java

class General implements Serializable {
   ...
}

class Any extends General { }

...

final class None extends Any /*A, B, ....*/ { }

//

class Test {
    public static Any getSome() {
        return new None();
    }

    public static void setSome(Any any) {
        if (any instanceof None) {
            System.out.println("wrong value!!!");
        }
    }
}


15. Попытка присваивания

Довольно массовая проблема в проектировании иерархии классов связана с необходимостью проверять реальный тип полиморфного объекта и выполнять те или иные действия в зависимости от его типа, с помощью цепочки условных конструкций. Например, в предыдущем разделе мы делали условную проверку, по сути, типа объекта на его "пустотность" -- сравнивали с единственным значением Void типа None. Ещё одна частая ситуация, приводящая к таким цепочкам, возникает, когда некоторые данные поступают в программу в сыром формате, и если подразумевается, что они должны десериализоваться в объект типа T, на практике тип (структура этих данных) может быть совсем другим (например, по ошибке пришли не те данные, или они испортились).

Наличие в программе проверок наподобие

if type(object) is LinkedList then ...
else if type(object) is TwoWayList then ...

верный признак плохого проектирования. Во-первых, подобные цепочки могут расплодиться по всему проекту, и при добавлении нового типа придётся каждый раз править их все. Во-вторых, само по себе сравнение типов в рамках формальной модели ООП крайне плохая идея -- в идеале, в ООП не должно быть вообще никаких динамических операций работы с типами, соответствующая логика проверок корректности типов должна выполняться статически, компилятором. То есть ни при каких условиях мы не должны делать дополнительных проверок типа, если код успешно прошёл проверку компилятором (тайп-чекинг).

Ситуация облегчается тем, что на практике мы обычно представляем, какой примерно тип объекта ожидается. Поэтому все цепочки проверок типов из кода полностью исключаются, а инструкции обычного присваивания некоторой переменной типа T полиморфного объекта (присваивания ссылки на этот другой объект, предположительно, одного из типов-потомков, совместимых с T) заменяются на свою более ограниченную версию.

Формальная модель ООП предлагает для всех подобных случаев так называемую попытку присваивания, которую можно оформить как команду:

assignment_attempt(target, source)

Если тип source совместим с типом target, то присваивание выполняется успешно, в противном случае переменной target присваивается значение Void. Принципиальный момент, что такой случай не расценивается как ошибочный -- в отличии от многих популярных языков, где в таком случае возникает исключение. При желании можно выдавать особый статус такой команды, однако не следует его трактовать как ошибку -- причина такой ситуации будет прежде всего в неверных архитектурных подходах.

Задание 12.

Добавьте в классы General и Any попытку присваивания и её реализацию. 

Решения задания 12

Добавьте в классы General и Any попытку присваивания и её реализацию.

Python

class Any(General):

    @classmethod
    def assignment_attempt(cls, target, source):
        if isinstance(target, cls) and isinstance(source, cls):
            target.value = source.value
            return target
        return Void

Java

class General implements Serializable {

    public static <TFrom extends Any, TTo extends Any>
            TTo assignmentAttempt(TFrom from, TTo to) {

        var classFrom = from.getType();
        var classTo = to.getType();
        if (classTo.isAssignableFrom(classFrom)) {
            return (TTo) from;
        }
        return None;
    }


16. Политика скрытия методов при наследовании

Насколько наследование методов и видимость методов -- схожие по смыслу понятия? Эти понятия ортогональные, по сути, непересекающиеся.

Наследование -- это про отношение между классами внутри иерархии классов,
а видимость методов -- про отношение между классом и его внешним пользователем-программистом (пользователем публичного интерфейса, множества операций соответствующего АТД).

На курсе по проектированию классов на основе АТД мы договаривались, что все поля класса всегда скрыты от внешнего пользователя класса -- ему доступен только публичный интерфейс операций (методов), набор команд и запросов. Поэтому при обсуждении технических деталей наследования мы говорим только о возможном изменении видимости методов, а поля считаем всегда приватными.
К сожалению, в ряде языков это может вызвать проблемы с их наследованием (если приватные поля наследовать не разрешается). В таких случаях надо придерживаться как минимум рекомендательной системы: оформлять компоненты классов, которые нельзя скрыть физически, но желательно скрыть от внешнего мира, исходя из принципов проектирования, как рекомендательно скрытые. В Python например это делается указанием в названии поля или метода префикса из одного символа "_".

Всего существует четыре варианта скрытия метода:
1. метод публичен в родительском классе А и публичен в его потомке B;
2. метод публичен в родительском классе А и скрыт в его потомке B;
3. метод скрыт в родительском классе А и публичен в его потомке B;
4. метод скрыт в родительском классе А и скрыт в его потомке B.

Варианты 1 и 4 поддерживают практически все языки (наследование видимости по умолчанию), вариант 2 также часто возможен, а вот вариант 3 встречается уже весьма редко.

Однако принцип наследования должен иметь под собой прежде всего не техническую специфику, а правильную теорию, методологическую, формальную основу. Так как мы проектируем классы на основе АТД, то и принцип скрытия простой: в каждом классе публичны только те методы, которые входят в спецификацию соответствующего АТД.

Задание 13.

Разберитесь, какие из четырёх вариантов скрытия методов доступны в используемом вами языке программирования. Приведите примеры кода для каждого из доступных вариантов. 


17. Наследование, полиморфизм и обобщённые типы

Наследование с полиморфизмом объединяются в полиморфных структурах данных, которые мы можем дополнительно параметризовать отдельным типом T (например, MyType<T>). При этом подразумевается, что реальным параметром при создании конкретного объекта типа MyType<T> можно задавать не только тип T, но и любой его потомок.

В ряде случаев желательно, чтобы над типом T можно было выполнять некоторые операции, которые семантически присущи типу MyType. Если мы определяем некоторую операцию над типом MyType (например, сложение), то естественно было бы уметь складывать и значения типа T. Если MyType -- это скалярный массив, и T -- целый тип, то сложение двух массивов целых чисел естественно было бы описать как сложение их соответствующих элементов (целых значений). Но для этого требуется, чтобы сложение допускалось и для значений типа T. Другие стандартные виды таких операций, которые хотелось бы переносить и на тип-параметр T -- это например сортировка (проверка отношения порядка), вычисление хэш-ключа, и т. д.

Но по умолчанию о типе T мы ничего не знаем. Максимум, что о нём известно -- это то, что тип T есть потомок типа Any. Поэтому решение здесь достаточно простое и называется ограниченной универсальностью: так как мы всегда остаёмся в рамках нашей системы типов, используем только классы из иерархии, то для соответствующих нужд определяем промежуточные классы, которые поддерживают требуемое множество операций. Эффективнее всего этот момент решается с помощью множественного наследования, но если таких разных наборов операций много, и наследовать их друг от друга некорректно (они совсем разные по смыслу), приходится изобретать "кривые" решения наподобие интерфейсов, композиции и т. д.

При использовании ограниченной универсальности надо учитывать, что тип-параметр T должен быть потомком класса с подходящим набором операций. Например, если мы захотим определить список списков целых чисел, LinkedList<LinkedList<Integer>>, над которым допустима операция сложения списков (когда каждый результирующий элемент списка будет представлять собой связный список, равный сумме связных списков соответствующих аргументов), то в идеале требуется, чтобы и Integer, и LinkedList были потомками некоторого класса, допускающего операции сложения. Если множественное наследование в языке отсутствует, реализовать это можно, например, добавив операцию сложения в класс Any, раз уж она так актуальна для всей системы типов.

Задание 14.

Сформируйте тип (класс) Vector<T> (линейный массив значений типа T, наследуемого от General), над которым допустима операция сложения, реализуемая как сложение соответствующих значений типа T двух векторов одинаковой длины. Если длины векторов различны, возвращайте Void/null в качестве результата работы операции сложения.
Выясните, как в используемом вами языке программирования элегантнее всего реализовать поддержку сложения элементов произвольных типов.
Проверьте, насколько корректно будет работать сложение объектов типа Vector<Vector<Vector<T>>>. 

Решения задания 14

Сформируйте тип (класс) Vector<T> , над которым допустима операция сложения.
Cложите объекты типа Vector<Vector<Vector<T>>>

Python

class Any(General):

    ... 

    def __add__(self, other):
        """Summation"""
        raise NotImplementedError()

class Vector(Any):
    """
    >>> v1 = Vector(0, 1, 2)
    >>> v2 = Vector(7, 10, 15)
    >>> (v1 + v2).get_sequence_representation()
    (7, 11, 17)
    >>> v3 = Vector(3)
    >>> (v1 + v3) is Void
    True
    >>> v4 = Vector(6)
    >>> nested_v1 = Vector(Vector(v1), Vector(v3))
    >>> nested_v2 = Vector(Vector(v2), Vector(v4))
    >>> nested_v1.get_sequence_representation()
    (((0, 1, 2),), ((3,),))
    >>> nested_v2.get_sequence_representation()
    (((7, 10, 15),), ((6,),))
    >>> (nested_v1 + nested_v2).get_sequence_representation()
    (((7, 11, 17),), ((9,),))
    """

    def __init__(self, *args: t_Any, **kwargs):
        super().__init__(*args, **kwargs)
        self.sequence = args
        self._size = len(args)

    def __add__(self, other: 'Vector') -> Union['Vector', Void]:
        try:
            assert self._size == other._size
        except AssertionError:
            sum_vector = Void
        else:
            sum_vector = self._sum_vectors(other)
        return sum_vector

    def _sum_vectors(self, other: 'Vector') -> 'Vector':
        sequence_items = starmap(operator.add, zip(self.sequence, other.sequence))
        sum_vector = Vector(*sequence_items)
        return sum_vector

    def get_sequence_representation(self) -> tuple:
        """Get representation of all nested sequence (recursive)"""
        this_func_name = self.get_sequence_representation.__name__
        representation = tuple(
                getattr(item, this_func_name, lambda: item)()
                for item in self.sequence)
return representation

Java

public class Adder<T> extends Any {

    public T sum(T first, T second){

        T ans = null;

        if(first instanceof String){
            ans = sumString(first, second);
        }

        if(first instanceof Integer){
            ans = sumInteger(first, second);
        }

        if (first instanceof Double){
            ans = sumDouble(first, second);
        }

        return ans;
    }

    private T sumString(T first, T second){
        return (T)(first + (String)second);
    }

    private T sumInteger(T first, T second){
        Integer sum = (Integer)first + (Integer)second;
        T value = (T)sum;
        return value;
    }

    private T sumDouble(T first, T second){
        return (T)((Double)((Double)(first) + (Double)second));
    }
}

public class Vector<T> extends Adder {

    public static int ADD_NIL = 0;
    public static int ADD_OK = 1;
    public static int ADD_ERR = 2;

    private int length;
    private T[] arr;
    private int add_status;

    public Vector(T[] arr){
        this.arr = arr;
        length = arr.length;
        add_status = ADD_NIL;
    }

    public Vector(int length){
        arr = (T[])new Object[length];
        this.length = length;
        add_status = ADD_NIL;
    }

    public void add(Vector<? extends T> v){
        Vector<String> temp = new Vector<String>(1);
        if (v.getLength() == length){
            T[] arr2 = v.getArr();

            for (int i = 0; i < length; i++){
                if(arr2[i].getClass().isInstance(temp)){ 
                // проверяем типы. Если это Vector, то:
                    ((Vector<T>)arr[i]).add(((Vector<T>)arr2[i]));
                }
                else { // иначе - это Number или String
                    add_v((Vector<T>) v);
                    add_status = ADD_OK;
                    break;
                }
            }

            add_status = ADD_OK;
        }
        else{
            add_status = ADD_ERR;
        }
    }

    private void add_v(Vector<T> v){
        T[] arr2 = v.getArr();
        for(int i = 0; i < length; i++){
            arr[i] = (T) sum(arr[i], arr2[i]);
        }
    }

    public static Vector addVectors(Vector v1, Vector v2){
        Vector ans = (Vector)v1.deepCopy();

        ans.add(v2);

        return ans;
    }

    public int getLength(){
        return length;
    }

    public int get_add_status(){
        return add_status;
    }

    public T[] getArr(){
        return arr;
    }
}



18. Как расширять иерархию новыми классами

В каких случаях надо расширять иерархию классов, как правильно это делать?

Добавление нового класса как потомка некоторого класса имеет смысл, если этот потомок либо переопределяет какие-либо наследуемые методы, либо расширяет его новыми методами.

Но это правило связано с реализацией, а главный принцип остаётся прежним -- любой класс это всегда реализация соответствующей спецификации АТД (полная или частичная). Любой класс в иерархии реализует свой АТД, и каждый АТД представляет собой оригинальную конкретную структуру данных со своим набором операций, и добавляется он прежде всего в техническое задание, в общую модель системы. В частности, если в проекте потребовалась сущность, для которой надо изменить пред- и постусловия некоторого АТД, значит, надо добавить потомок этого АТД с переопределением соответствующих запросов или команд.

Существует, пожалуй, единственное исключение, когда можно включать новый класс, не добавляющий ничего нового -- когда иерархия точно отражает некоторую предметную область, и в ней приняты соответствующие частные случаи как самостоятельные сущности, однако отдельные АТД им не нужны, достаточно добавить класс лишь как новый синтаксический элемент. И всё равно такой практике надо максимально сопротивляться.

Классический пример конфликта таксономии (теории классификации), встречающийся сегодня очень часто -- это расширение класса, описывающего какой-то аспект человека (например, Human или Sportsman), его полом. Обычно такое расширение выполняется добавлением булева атрибута female, после чего во многих местах кода начинают появляться проверки if female then ...

Это, как уже говорилось, верный признак плохого проектирования. Как только такие цепочки проверок начинают размазываться по всему проекту, возникает риск забыть исправить одну из них в случае модификации соответствующей логики -- например, когда количество вариантов существенно увеличится. Сегодня в некоторых странах допускается больше чем два значения пола, а всего их насчитывается уже более пятидесяти, и эта проблема схожа с проблемой Y2K, когда под хранение года в 20-м веке отводилось не четыре цифры, а только две последние. 


19. Решение конфликта таксономии

В случаях, когда некоторая характеристика нужна в основном для статистики, или для поддержки специфической логики, её можно оформить в виде атрибута. Однако если такая характеристика подразумевает различную логику в зависимости от её значения (условные цепочки if else), лучше создавать под каждое значение отдельный класс (в нашем случае Male и Female).

Это позволяет, во-первых, избежать ограничения типа -- в данном случае при добавлении третьего значения пола придётся расширять не только все условные цепочки, но и тип поля female (что, возможно, потребует модификации таблиц в базе данных), и вдобавок название этого поля female станет ненаглядным. А наследование подразумевает всего лишь добавление нового класса с ясным названием и одним-двумя переопределёнными методами.

Во-вторых, все различия в логике обработки разных полов удобно инкапсулируются в одном месте, внутри конкретного класса.

И в-третьих, все условные цепочки заменяются на единственный полиморфный вызов нужного метода.

Задание 15.

Приведите пример небольшой иерархии, где вместо некоторого поля родительского класса с набором предопределённых значений (как в случае с полем female) применяется наследование.

Решения задания 15

Приведите пример иерархии, где вместо некоторого поля родительского класса с набором предопределённых значений применяется наследование.

Python

class _ClassificationDataInput(Any):
    def get_prepared(self, *args, **kwargs) -> t_Any:
        """Request method, must return acceptable
        object as input for classification model."""
        raise NotImplementedError()

class YesNoQuestionnaire(_ClassificationDataInput):
    """
    >>> q = YesNoQuestionnaire()
    >>> q.get_prepared(True, False, True)
    (1, 0, 1)
    """
    def get_prepared(self, *user_answers: bool, **kwargs) -> Tuple[int, ...]:
        prepared = tuple(map(int, user_answers))
        return prepared

class MovementTest(_ClassificationDataInput):
    """
    >>> BAD, AVERAGE, GOOD = range(3)
    >>> m = MovementTest()
    >>> m.get_prepared(BAD, GOOD, AVERAGE)
    (0, 2, 1)
    """
    def get_prepared(self, *test_result_enums: int, **kwargs) -> Tuple[int, ...]:
        prepared = test_result_enums
        return prepared

Java

public abstract class Developer {
}

// Так делать плохо:
public class Worker extends Developer {
    public int skill; // -1 junior, 0 middle, 1 senior

    public Worker(int skill){
        this.skill = skill;
    }
}


// Лучше делать так:
public class Senior extends Developer {
}

public class Middle extends Developer {
}

public class Junior extends Developer {
}

// Теперь наш код открыт для расширений, но закрыт для изменений, 
// и с точки зрения семантики так куда лучше :)


20. Формальная модель ООП

Для объектно-ориентированного программирования в начале 1990-х годов была разработана формальная, математическая модель (Лука Карделли, сигма-исчисление). Немного более подробно мы познакомимся с ней на следующих курсах. В чём главная сила таких строгих, формальных подходов? В том, что они предлагают самый необходимый, очень ясный и прозрачный минимум абстракций, отбрасывающий кучу ненужных технических деталей и позволяющий гибко, мощно и очень компактно выражать весьма сложные концепции, что тем самым существенно снижает общую сложность создаваемой системы. При этом появляется возможность создания хорошо расширяемых и полностью децентрализованных архитектур, которые например реализуются моделью акторов, однако подход ООП, предлагаемый на данном курсе, потенциально как минимум не менее мощен.

В общем случае, вся проектная логика основывается только на одном базовом объектно-ориентированном синтаксисе:

x.f( arg )

x -- это объект (экземпляр конкретного типа);
f -- это либо оригинальный метод базового класса в иерархии, либо переопределённый метод в прямом классе объекта x, либо в одном из его предков;
arg -- это список аргументов метода f (возможно, пустой).

Статическая система типов автоматически проверяет корректность таких вызовов. Единственное исключение, если x -- полиморфный объект, и по каким-то причинам либо недопустим вызов самого метода f(), либо некорректен данный список аргументов для метода f() этого конкретного объекта, на который ссылается переменная x. Такое может случиться, например, если в коде ранее выполнялось полиморфное присваивание с явным приведением типа объекта к некоторому другому типу, что компилятор обычно допускает, перекладывая ответственность за последствия на программиста. Другой упоминавшийся случай -- использование "пустого" объекта Void. 


21. Ограничения ООП

Глобальная проблема ООП в том, что крайне сложно создать язык с разумными прикладными возможностями, в котором любая синтаксически корректная конструкция будет автоматически корректной и в рамках статической системы типов такого языка. Поэтому приходится вводить правила, договорённости, ограничивающие синтаксическую свободу кодирования ради сохранения корректности системы в целом.

Одно из таких правил -- полный отказ от явного приведения типов в программе, как минимум в отношении пользовательской иерархии классов.

Ещё более строгое правило -- определить допустимый набор, множество типов, с которыми полиморфному объекту некоторого класса разрешается связываться во время работы программы. Такое множество может быть строже, нежели допускает полиморфизм -- например, это могут быть не все классы-предки, а только некоторые.

Стандартное полиморфное присваивание

x = y

подразумевает, что класс объекта y принадлежит множеству допустимых типов для переменной x (начиная с её класса, и ниже по иерархии), и очень хорошо, если язык программирования позволяет накладывать на такое присваивание (на содержимое допустимого множества типов) дополнительные ограничения.

Компилятор это может выполнить, например, изучив все полиморфные присваивания в исходном коде, составив списки конкретных типов объектов из правой части для типа переменной из левой части, и разрешив в процессе работы программы только соответствующие полиморфные преобразования. По аналогичной схеме учитывают также полиморфные вызовы методов, у которых типы формальных и фактических параметров могут отличаться.

В конечном итоге такой алгоритм -- процесс выделения связанных множеств типов в конечном коде -- обязательно заканчивается, и называется он метод неподвижной точки. Его реализация может быть весьма трудоёмкой, потому что содержимое множеств типов начинает зависеть от порядка встречаемых полиморфных вызовов, и в общем случае требуется несколько проходов, более глубокий анализ кода, и сложность алгоритма быстро растёт. На практике используются более простые пессимистичные подходы, не допускающие излишней полиморфной гибкости, если она не выводится из кода достаточно просто. 


22. Добавим ещё больше строгости

Добавим к этой пессимистичной практике ещё больше формальной строгости. Проблема в том, что ковариантность ("автоматическая" параметризация кода типами по мере спуска по иерархии наследования без необходимости модификации логики) и полиморфизм могут вступать в конфликт друг с другом, поэтому в популярных языках программирования на ковариантность накладываются весьма сильные ограничения. В C# например она допускается только для интерфейсов и делегатов. В Java ковариантность поддерживается относительно типа результата переопределяемого метода.

В частности, ООП допускает две потенциально конфликтные операции: полиморфное присваивание
x = y
и ковариантный вызов
x.foo(z)
(который следует отличать, конечно, от динамического связывания с аналогичным синтаксисом). Классический конфликт возникает, когда мы начинаем использовать x одновременно и как полиморфный объект, и как объект, вызывающий ковариантный метод foo(). Эффект от такой комбинации может быть далеко не всегда предсказуемым: программист может, сам того не желая, "перехитрить" систему типов, и получить совсем другой результат.

Ковариантность -- это в некотором смысле тоже полиморфизм, только с другим механизмом.
Классический полиморфизм подразумевает в частности вызов foo(T z), где в качестве z может использоваться полиморфный параметр (в реальных вызовах можно задавать потомки класса T).
Ковариантность в частности подразумевает вызов foo<T>(T z), где уже сам тип T выступает параметром метода, и сама логика, обработка объекта z параметризуется типом T. На практике это реализуется передачей в качестве аргумента не просто типа T, а обобщённого типа, например List<T>, когда включается ковариантная типизация.
В таких случаях, когда параметр метода -- обобщённый тип, а вызывается этот метод полиморфным объектом, нередко и возникают неоднозначности.

Строгое решение запрещает использовать некую сущность в программе одновременно и как полиморфную, и как ковариантную.

Простое синтаксическое правило выявления полиморфных сущностей в программе таково:

Сущность x полиморфна, если

1) она участвует в полиморфном присваивании

x = y

или

2) x -- формальный параметр любого метода.

В потенциально подозрительных случаях рекомендуется выполнять полиморфное присваивание не напрямую, а с помощью упоминавшейся ранее попытки присваивания.

В таком случае применять ковариантный вызов метода к переменной x не разрешается.

Задание 16.

Если используемый вами язык программирования это допускает, напишите примеры полиморфного и ковариантного вызовов метода. 


Решение

Python

# Полиморфный вызов.

class Person():
    def walk(self):
        print('Yes, i can walk...')

# Наследник расширяет класса-предок
# новым методом:
class Baker(Person):
    def bake(self):
        print('and bake!')

somebody = Baker()

# Тип Baker ведет себя как тип Person
# при вызове этого метода:
somebody.walk()

# Ковариантный вызов.

from typing import Generic, TypeVar, Callable

animal = TypeVar('animal', covariant=True)

class Animal():
    def make_sound(self):
        raise NotImplementedError

class Cat(Animal):
    def make_sound(self):
        print('Meow!')

class Dog(Animal):
    def make_sound(self):
        print('Woof!')

# ящик на вход принимает любой объект типа Animal
class Box(Generic[animal]):
    def __init__(self, content: animal) -> None:
        self._content = content

    def make_sound(self):
        self._content.make_sound()

# Ковариантный вызов:
def shake_box(box: Box[Animal]):
    box.make_sound()

some_animal = Cat()
box = Box(some_animal)
shake_box(box)



23. Проектирование отношения между классами через наследование и композицию

При создании иерархии классов методологически верно начинать с того, что делать не следует, чтобы отбросить большое количество потенциально негодных элементов. Тогда понимание, как делать хорошо, появится естественным образом.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

В русском языке глагол "является" очень часто используется именно в том смысле, как это происходит сейчас. Однако уже на первом курсе Литературного института учат, что "является лишь тень отца Гамлета", в остальных случаях надо либо менять форму предложения, либо использовать слова "есть" или "суть". Например, не "велосипедист является спортсменом", а "велосипедист есть спортсмен" или "велосипедист -- это спортсмен". Однако в технической литературе "является" в данном контексте стало к сожалению стандартным.

Композиция -- это клиентское отношение "содержит" (has-a), когда один объект содержит объект другого класса (класс включает поле другого типа/класса).

Правило отказа от наследования: не надо делать класс B наследником класса A, если не найдены хорошие аргументы в защиту такого отношения наследования.

Это правило само по себе слабое, потому что надо как-то оценивать "хорошесть" аргументов в защиту наследования, но как это делать? На практике эти аргументы учитывают конкретный контекст, основываются на опыте разработчика, на качестве технического задания, на адекватной информации от заказчика, и т. д. Полезно также попытаться найти контраргументы, опровергающие возможность потенциального наследования.

Нередко возникают проблемы в выборе отношения "является" или "содержит", когда между классами явно имеется связь, только непонятно, как её формализовать. Сложность тут в том, что "содержит" очень редко означает также и "является", но "является" довольно часто означает и "содержит".

Каждая программа является кодом.
Каждая программа содержит код. 

Каждый гоночный автомобиль содержит двигатель. 
но не
Каждый гоночный автомобиль является двигателем. 

Чаще всего на практике подходит отношение композиции "содержит", и как правило когда о некотором отношении можно сказать "является", то часто из этого "является" можно вывести и "содержит", это лишь два разных взгляда на одно и то же. И только если совсем явно не удаётся вывести отношение "содержит", следует использовать "является". Это универсальный принцип, дополним его более формальными правилами. 


24. Изменяемость отношения is-a

Отношение "является" -- это всегда отношение между классами, между спецификациями, и никогда между объектами. "Является" может быть отношением только между абстрактными сущностями, между типами данных.

"Каждый гоночный автомобиль является обычным автомобилем" означает, что класс "гоночный автомобиль" наследуется от класса "обычный автомобиль". Это отношение задаётся статически на уровне системы типов программы, и его невозможно изменить в процессе её работы.

В случае отношения "содержит" утверждение "каждый гоночный автомобиль содержит двигатель" подразумевает, что объект "гоночный автомобиль А" содержит объект "двигатель Б" (например, в полиморфном поле в классе "гоночный автомобиль"), но во время работы программы вполне допускается, что "двигатель Б" будет динамически заменён на "двигатель В" допустимого типа.

Таким образом, первое правило выбора между "является" и "содержит" подразумевает, что если отношение похоже на "является", но тип наследуемого объекта по логике работы программы может меняться, то правильным отношением будет "содержит".

Например, "каждый гоночный автомобиль является обычным автомобилем" вполне корректно оформить как наследование, однако надо учитывать весь контекст проекта. В частности, могут добавляться принципиально новые классы "электрический автомобиль" или "летающий автомобиль", которые напрашивается сделать потомками класса "обычный автомобиль".
Однако от какого из них наследовать "гоночный автомобиль", если мы хотим сделать возможными гонки и для электромобилей, и для летающих машин, а множественное наследование в конкретном языке программирования запрещено? Наконец, если мы хотим оснастить гоночный автомобиль возможностями и электромобиля, и летающего автомобиля, как быть?

Можно расширять сам класс длинными списками атрибутов, и затем их интерпретировать в разных методах длинными цепочками проверок "если значение атрибута XYZ такое-то то ..." , но уже отмечалось, что это потребует модификации множества мест в коде при любом изменении логики таких проверок. Это верный признак ошибочного проектирования. Важно такие проверки выполнять статически на этапе компиляции, например через наследование или полиморфизм. Система типов в идеале не должна допускать ошибочных попыток использования сущностей на уровне синтаксиса программы.

В нашем случае "гоночный автомобиль" может наследоваться от общего класса "средство передвижения" с самыми универсальными характеристиками. Однако попытка смешения в иерархии понятий "электромобиль" и "летающий автомобиль" скорее всего ошибочна, и если даже летающий автомобиль имеет смысл делать потомком базового средства передвижения, непонятно, куда девать в такой иерархии "гоночный автомобиль". Такой проблемый вид наследования рассматривается далее, скорее всего возможность езды на электричестве стоит отнести к типу двигателя (сам двигатель как полиморфное поле включён в класс "средство передвижения"), а возможность полётов -- к некоторой технической специфике (ездить, летать, плавать).

Не исключено даже, что сам класс "гоночный автомобиль" стоит выделить в отдельную иерархию, независимую от "средства передвижения", которое включается в этот класс через отношение "содержит".

В целом, в таких случаях надо исходить из видения проекта в целом, и понимания, какие конкретно АТД будут требоваться. Тут стандартная рекомендация -- думать о классе всегда как о конкретной структуре данных со своим набором допустимых операций над ней, а внутренняя реализация полностью скрывается внутри класса.

Задание 17.

Приведите два словесных примера отношения "содержит" между классами, которое похоже на "является", но по вышеупомянутому правилу таковым не является. 

Решения задания 17

Приведите словесные примеры отношения "содержит" между классами, которое похоже на "является", но таковым не является.

Организация "содержит" помещение (юридический адрес). Кажется, что организация "является" юридическим адресом, но адрес вполне может смениться. Адрес должен быть атрибутом организации.

Вино "содержит" алкоголь. Кажется, что вино "является" алкоголем, но атрибут "алкоголь" может измениться (например, увеличиться или уменьшиться в каком-то соотношении) отдельно от самого вина. Это отношение has-a.

Есть класс Text и имеется необходимость применения к нему форматирования (подчеркивание, жирность, курсив). Создание отдельных классов, соответствующих каждому виду форматирования, на первый взгляд подходит под отношение "есть", так как "курсивный текст" есть "текст", однако разновидностей форматирования существуют множество, поэтому, возможно, правильней будет создать отдельный класс, задающий характеристики форматирования, и включать его как атрибут в класс Text.
Однако, это пример с определённой неоднозначностью. Если перечень стилей форматирования невелик и чётко предопределён, не исключено, что как раз лучше создавать классы UnderLineText и BoldText, а не выискивать в коде все обращения к атрибуту форматирования при каждой его модификации.

Модератор есть человек? Модератор фактически не использует интерфейс человека, а занимается специализированной деятельностью, поэтому правильное отношение человек has-a модератор (содержит роль/права).
Хотя, опять-таки, когда количество ролей невелико, а человек -- это например абстрактный класс, и стоит задача смоделировать человека исключительно в конкретной профессиональной среде (модератор, администратор, ...), то лучше реализовать иерархию классов через отношение is-a.

Класс Волшебник правильно считать наследником класса Герой.
Волшебника отличает наличие маны и умение использовать заклинания.
Однако непосредственно "магические умения" можно выделить в отдельную систему классов-типов, которую использовать через композицию.
Например, это полезно при создании монстров или NPC-персонажей с магическими возможностями, которые (классы монстров/NPC) лучше наследовать от своих предков, а не от Героя.

Аналогично, есть классы оружия "ядовитый клинок" и "огненный клинок" -- разные наследники класса "клинок".
Оба этих оружия накладывают статус на урон ('яд', 'огонь') и, возможно, на цель ('отравлен', 'обожжён').
Свойства яда или огня могут также применяться и к другим видам оружия (стрелы или мечи), поэтому стоит сформировать отдельную иерархию классов характеристик оружия, которые задают не только статусы уровна, но и содержат оригинальную логику (действие огня или яда), которую конечно удобнее инкапсулировать внутри отдельных классов.
Тогда классы "ядовитый клинок" и "огненный клинок" превратятся в один класс "клинок со статусом", содержащий атрибут класса статуса.

Видно, что даже в таких совсем простых случаях уже возникает неопределённость, которую надо учитывать, исходя из конкретных условий конкретного проекта. 


25. Учёт полиморфизма

Распознавание отношения "является" лучше всего делать через выявление явной необходимости применения полиморфизма в проекте. Этот принцип приближен к техническим моментам реализации, когда становится понятно, где в проекте будут требоваться полиморфные присваивания.

Итог:

1) Если объекты класса А могут содержать (включать) объекты класса B, и эти объекты класса B могут меняться на объекты других типов, используйте отношение has-a "класс А содержит атрибут класса B" (приоритетное правило).

При этом, в частности, объект класса B, включаемый в класс А (атрибут типа B, входящий в класс А) будет полиморфным -- он может хранить как объекты класса B, так и различные его потомки, и отношение между ними будет is-a.

2) Если в программе сущности (переменные) типа (класса) А в различных местах проекта могут содержать как объекты класса А, так и объекты класса B, используйте отношение is-a "класс B является потомком класса А". 


26. Пример

Данная схема выбора комбинации has-a и is-a на практике нередко представляется весьма распространённым паттерном проектирования Мост/Bridge. Классический пример его применения -- кросс-платформная библиотека компонентов пользовательского интерфейса.

Любой визуальный компонент (например, кнопка) наследуется от класса Window (графическое окно). Окно в свою очередь наследуется от двух классов GeneralWindow (универсальные свойства любого окна) и PlatformWindow (свойства, зависящие от конкретной платформы). Универсальные операции, наследуемые от GeneralWindow, класс Window реализует с помощью операций, наследуемых от PlatformWindow.
Поддержка каждой конкретной платформы реализуется классами-потомками PlatformWindow, по одному на каждую платформу.

Проблема такой схемы в том, что во-первых, множественное наследование поддерживается далеко не во всех современных языках (оно подчас умышленно запрещено). И во-вторых, самое главное, что даже внутри конкретной платформы (например, Windows или Web) графическое представление визуального компонента может меняться в зависимости от контекста его использования (например, в рамках Windows мы хотим представлять некоторый документ в форматах PDF или HTML).

В таком случае мы сохраняем наследование класса Window от класса GeneralWindow (отношение "является"), а связь с конкретной реализацией оформляем в виде отношения "содержит". Включаем в состав класса Window полиморфный атрибут класса PlatformTooklit. В свою очередь для класса PlatformTooklit создаётся набор потомков, реализующих нужный набор операций для конкретного визуального представления.

Универсальные операции GeneralWindow в его потомке -- классе Window переопределяются, и в этих переопределениях выполняются обращения к подходящим операциям потомка класса PlatformTooklit. И вдобавок, в частности, мы получаем такую сильную возможность, как динамическая смена (непосредственно в процессе работы программы) реализации визуального представления для компонентов не только в рамках одной платформы, но и вообще между любыми платформами -- просто изменением содержимого атрибута PlatformTooklit (что, впрочем, на практике не очень актуально).

В данном примере успешно комбинируются все три ключевых механизма ООП: наследование (для обоих классов Window и PlatformTooklit), полиморфизм (для атрибута класса PlatformTooklit) и динамическое связывание (переопределённые методы GeneralWindow).

Самые распространённые ошибки, связанные с некорректным применением наследования:
- путаница между наследованием ("является") и композицией ("содержит");
- в качестве критерия применения наследования выступает некоторое поле-классификатор (пол человека или любой другой перечень из фиксированных значений), которое используется в программе только в статистических целях (отсутствует специфичная логика, связанная с обработкой конкретных значений поля);
- наследование применяется, чтобы получить доступ к удачной реализации класса-предка, который закрыт для изменений (ошибка тут в плохой проработке АТД класса-предка).

Задание 18.

Приведите два словесных примера отношения "является" между классами, которое однозначно таковым является и не может быть переведено в отношение "содержит". 

Решения задания 18

Приведите два словесных примера отношения "является" между классами, которое однозначно таковым является.

Иерархии овощь - томат и животное - заяц.

Яблоко "является" фруктом. Яблоко никак не может "содержать" фрукт.
Глаз "является" органом. Глаз не может "содержать" орган внутри себя.

Металлическая дверь IS-A дверь, т.к. мы можем свободно заменять одну дверь на другую в силу идентичного интерфейса.

В проекте встречалась реализация адаптера авторизации, сценарии которой могут быть различны: логин-пароль, по реферальной ссылке, через токен.
Вся реализация класса адаптера была представлена в виде нескольких методов с множеством условных конструкций для поддержки разных сценариев.
Более удачным было бы наследование от базового адаптера с изменением логики авторизации предка, или с помощью динамического связывания.


27. Классификация категорий наследования

В модели ООП известно около десятка различных видов наследования, различающихся своей семантикой. Например, один из них -- это ранее упомянутое правило, когда новый класс добавляется, только если он переопределяет наследуемые методы предка или расширяет его новыми методами. В разных методиках ООАП предлагаются свои комбинации различных видов наследований и, соответственно, серьёзно различающиеся походы к моделированию предметной области и формированию иерархий классов.

Основной принцип, что в каждом случае надо сознательно применять один конкретный вид наследования, решающий одну конкретную проблему. Возможны случаи, когда наследование подходит под несколько категорий, но хорошего формализма для такого случая в ООП не известно, поэтому если удаётся подобрать схему наследования, относящуюся только к одной категории, то предпочесть следует именно её. А если ни один из известных видов наследования не подходит, значит и самого наследования нужно избегать. В частности, в вышеупомянутом случае правило наследования подразумевает, что новый класс-потомок должен вносить какое-то явное изменение в класс-предок (специализацию, переопределение или расширение).

В общем случае этот принцип затрагивает сразу два принципа SOLID, которые в данном цикле курсов "автоматически", естественно реализуются концепцией АТД, подразумевающей, что каждый класс создаётся на основе спецификации АТД, которая в свою очередь описывает конкретную структуру данных со своим набором операций над ней.

1) принцип единственной ответственности (The Single Responsibility Principle, SRP), подразумевающий, что класс должен иметь единственную ответственность, только одну причину для изменений. Всё поведение класса направлено исключительно на обеспечение этой ответственности. В частности, при выборе вида наследования мы как раз и преследуем решение одной конкретной проблемы, одну причину для добавления нового класса.

2) принцип разделения интерфейса (Interface Segregation Principle, ISP), предлагающий создание небольших специфических интерфейсов. Именно концепция АТД наиболее полно отвечает ISP, или точнее, принцип ISP -- это просто прикладная рекомендация, основывающаяся на более строгом формализме абстрактных типов данных.

Рассмотрим основные виды, категории наследования. Выбором одной конкретной категории всегда надо руководствоваться при добавлении нового класса в иерархию наследования. 


28. Категории наследования

1) Наследование подтипов (subtype inheritance)

Это классическая форма наследования, когда некоторая родительская категория естественно разделяется на достаточно очевидные и независимые подкатегории. Например, "Гоночный автомобиль", который будет применяться только в гонках, и "Такси", которое будет использоваться только для перевоза пассажиров в городе, удобно представить потомками класса "Автомобиль". Часто наследование подтипов напрямую отражает классические иерархии в естественных науках.

Однако даже в такой простой форме наследования практически всегда присутствует неопределённость: по каким критериям разделять классы-потомки? Эта тема более подробно рассматривается на следующем курсе по проектированию.

В данном виде наследования родительский АТД всегда представляется в форме либо абстрактного, либо частично реализованного класса.

Потомок всегда специализирует родительский тип какими-то уникальными характеристиками, и множество его экземпляров всегда будет подмножеством множества экземпляров предка. Кроме того, все потомки задают непересекающиеся друг с другом подмножества экземпляров.

2) Наследование с ограничением (restriction inheritance)

В данном случае экземпляры класса-потомка представляют собой частный, но важный случай класса-предка. Этот частный случай вытекает из дополнительного ограничения, накладываемого на родительские характеристики. Например, "Такси" можно разделить на "Пассажирское такси" и "Грузовое такси". При этом, важно, родительский класс не расширяется новыми возможностями, а наоборот ограничивается -- например, вводится ограничение на допустимую область применения (что не исключает появления новых атрибутов класса, например, количество пассажирских мест или грузовых мест, которые однако остаются только необходимым следствием такого ограничения).

Этот вид наследования весьма схож с базовым видом subtyping. Как правило, семантически он относится не к классам, а к экземплярам, физическим объектам, на которые наложены определённые измеряемые ограничения.

3) Наследование с расширением (extension inheritance)

Данный вид наследования, в противоположность наследованию с ограничением, нацелен на расширение уже самого класса-предка новыми возможностями, никак не применимыми к объектам родительского класса. В результате, в частности, множество объектов класса-потомка B перестаёт быть подмножеством множества экземпляров класса-предка А, хотя такое отношение сохраняется в обратном порядке -- применительно к множеству А как подмножеству множества B.

Наследование с расширением может быть похожим на наследование с ограничением, когда мы вроде бы "расширяем" родительский класс Такси спецификой грузовой или пассажирской перевозок, хотя на самом деле это всё же специализация. В то же время класс "Беспилотный автомобиль" будет скорее полноценным расширением класса "Автомобиль" -- для него становятся допустимыми операции наподобие "смена прошивки робота-водителя", никак не применимые к родительскому классу "Автомобиль".

Кроме того, часто наследование с расширением применяется в математике и computer science -- например, специализированные списки могут расширять родительский класс List качественно новыми операциями.

Один из прикладных критериев выбора между специализацией и расширением -- это добавление нескольких схожих классов в специализации, и как правило добавление единственного, но семантический более общего класса при расширении.

Задание 19.

Приведите словесные примеры случаев наследования подтипов, с ограничением и с расширением. 

Решения задания 19

Приведите примеры случаев наследования подтипов, с ограничением и с расширением.

Наследование подтипов (subtype inheritance)

Имеется класс "эльф". В качестве подтипов можно выделить "эльф Нильфадиила" и "эльф Кронгурка", предполагая, что есть существенные различия в их поведении, а не только в cтатистических атрибутах вроде цвета кожи и размера ушной раковины.

Классы Worker, Hooligan и Businessman наследуются от класса People.
Worker, Businessman и Hooligan -- семантически не одно и то же, так как у них разные "назначения".

Наследование с ограничением (restriction inheritance)

На основе класса "гуманоид" мы решили создать разновидность "водный гуманоид". Экземпляры этого класса получают бонусы к характеристикам, но есть и ограничения -- они не могут покидать биом с типом "Водоем", например, иначе их жизненная сила стремительно угасает. Мы создали специализированный подтип для определенной игровой зоны.

Класс ApplePhone наследует класс SmartPhone.

Наследование с расширением (extension inheritance)

Предположим, что у нас появился новый вид существ "Големы". Они -- наследники класса "гуманоид", но ввиду их неживой природы они могут быть починены навыками "ремонт", а не только "лечению". Вдобавок они обладают возможностями "понимать суть механизмов" (это может быть навык-метод, наносящий сокрушительное повреждение механизмам). При этом стандартные навыки-методы класса гуманоид остаются им доступны.

Гидросамолет -- расширение Самолета возможностью взлетать и садиться на водную поверхность.

Класс SmartWatches наследует класс Watches, т.к. умные часы с точки зрения семантики "умеют" больше, чем часы в классическом понимании.
В АТД Watches достаточно определить только два метода: установка времени и чтение времени, которые, очевидно, присущи всем часам.

На мой взгляд специализация и расширение - это 2 стороны одной медали. Наследование - это по сути импликация a -> b. Специализация - это его экстенсиональная трактовка, а расширение - интенсиональная. Действительно, в экстенсиональном смысле в множество Фигур входят все фигуры, в том числе и Окружности. В интенсиональном смысле понятие Автомобиля с автопилотом содержит поведение как обычного Автомобиля, так и Автомобиля с автопилотом. 


29. Категории наследования-2

4) Наследования вариаций

Это семейство категорий наследования подразумевает переопределение методов родительских классов без добавления новых компонентов (если они только не будут обязательным следствием такого переопределения).

Наследование с функциональной вариацией (functional variation inheritance) подразумевает переопределение родительского метода без изменения его сигнатуры (переопределяется только логика работы).

Наследование с вариацией типа (type variation inheritance) подразумевает переопределение сигнатуры родительского метода (так называемая перегрузка метода).

Как правило, данная категория наследования применяется, когда требуется для каких-то операций реализовать логику, явно отличающуюся от логики класса-предка. Это например рассмотренный выше случай, когда мы создавали два дополнительных класса Male и Female, в каждом из которых реализовывалась особая логика некоторых методов класса-родителя Human в зависимости от конкретного пола человека. Кроме того, такие подходы могут потребоваться, когда родительский класс закрыт для изменений.

Как правило, эти виды наследования в конкретных языках программирования подразумевают указание дополнительных модификаторов для сигнатур методов, уточняющих схему их переопределения или перегрузки.

В целом, рекомендую вообще исключить практику переопределения родительских методов. Как правило, это просто кривая версия композиции. Вообще, переопределение существующих реализаций опасно всегда.

Например, в вашей структуре данных есть метод put(), у которого внутри меняется счётчик элементов. Если вы переопределите put(), добавив в свою версию увеличение счётчика (без вызова родительской версии), то счётчик также будет увеличен во время вызова дочернего метода.

А может, он будет увеличен например дважды, или size() выдаст абсурдный результат. Это деталь реализации, которая может измениться по прихоти (например, решили считать в родительском классе число внутренних элементов по-другому, удалив из него локальное изменение счётчика).

Композиция вместо этого работает только с интерфейсом внешнего класса и будет надёжной.

5) Наследование с конкретизацией (reification inheritance)

Это классическая схема "наследования кода", когда реализация общего родительского класса отложена (он абстрактный, например, или реализован частично), а конкретные законченные реализации выполнены в его классах-наследниках. Под конкретизацией здесь понимается "превращение абстракции в вещь".

6) Структурное наследование (structure inheritance)

Данный вид наследования нередко реализуется в языках программирования в виде интерфейсов. Структурное наследование подразумевает добавление типу данных некоторого нового, автономного, формального свойства. Например, класс SortedList, наследник класса List, которому дополнительно требуется учёт отношения порядка между строками, может также наследовать класс Comparable (или интерфейс, если множественное наследование запрещено).

Отличие данного вида наследования от конкретизации в том, что конкретизация семантически связана с родительским типом, а структурное наследование подразумевает добавление качественно новой абстракции.

Тут периодически возникает ошибка новичка, когда структурное наследование путают с отношением "является" is-a. Различие тут явное и формальное: если наследование структурное, то наследуемое свойство относится к классу как внешнему и единому целому. Например, отношение порядка применительно к классу Автомобиль подразумевает возможность сравнения самих автомобилей в целом. А отношение "является" подразумевает наследование свойств, непосредственно присущих родительскому объекту (например, наследование атрибута Двигатель). При этом само отношение между Автомобиль и Двигатель -- это не наследование, а has-a, "содержит".

Типичный пример структурного наследования -- это реализация итерирования, механизма перебора элементов массива или списка. Тут обычно предлагается большое множество различных полезных операций, например, переход к следующему элементу с сохранением текущей позиции в массиве, или поиск первого элемента, удовлетворяющего некоторому предикату, который может быть функцией (при том, что далеко не все языки позволяют передавать функцию как параметр).

Мы реализовали для списков простейшую схему итератора (концепция курсора) на первом курсе, однако стоит ли её встраивать в сами классы списков? Ведь у нас может быть много разных структур данных, которым полезна итерация (например, массивы, текстовые документы, и вообще любые структуры данных, для которых имеет смысл понятие следования элементов друг за другом). И в каждом таком случае реализовывать итераторы очень похожим кодом весьма нежелательно. Тут как раз хорошо работает ковариантность (автоматическая параметризация логики разными типами данных).

Более того, сами итераторы можно расширить и на более сложные структуры данных (например, деревья), что подразумевает их собственную организацию в иерархию классов. Насколько понятие "итератор" подходит для реализации в виде отдельного АТД, подразумевающего абстрактную, но вполне конкретную структуру данных? Один из видов классических структур данных -- это так называемая абстрактная вычислительная машина. Она представляет собой вполне конкретный объект, содержащий набор операций, которые можно применять к определённому типу данных. И в данном примере итератор как абстрактная машина вполне подлежит выделению в отдельный класс.

Задание 20.

Приведите примеры кода, реализующие наследование вариаций, наследование с конкретизацией и структурное наследование. 

 Приведите примеры кода, реализующие наследование вариаций, наследование с конкретизацией и структурное наследование.

Java

Наследование вариаций: иерархия "обычная газовая плита GasStove - газовая плита с электоподжигом ElectricGasStove", так как процесс её зажигания не требует спичек.

class GasStove {
    private boolean isGasTurnedOn;
    private boolean isGasFired;

    public void turnOn(Match match) {
        match.setFired();
        turnOnGas();
        isGasFired = true;
    }

    protected void turnOnGas() {
        isGasTurnedOn = true;
    }
}

class ElectricGasStove extends GasStove {
    //@Override
    public void turnOn() {
        turnOnGas();
        turnOnElectricIgnition();
    }

    private void turnOnElectricIgnition() {

    }
}

Наследование с функциональной вариацией: иерархия классов HttpRequest и HttpsRequest. HTTPS-запрос помимо перадачи данных требует предварительно создать ключ сессии, которым шифруются данныею

class HttpRequest {
    void doRequest(String body, Map<String, String> headers, String url) {
        dataInterchange(body, headers, url);
    }

    protected void dataInterchange(String body, Map<String, String> headers, String url) {
        System.out.println("");
    }
}

class HttpsRequest extends HttpRequest {
    protected String secretKey;

    @Override
    void doRequest(String body, Map<String, String> headers, String url) {
        handshake(url);
        var encryptedBody = encrypt(body, this.secretKey);
        super.doRequest(encryptedBody, headers, url);
    }

    private void handshake(String url) {
        var certificate = getServerCertificate(url);

        var canTrust = checkCertificateInCertificateAuthority(certificate);
        if (canTrust) {
            var publicKey = getPublicKeyFromCertificate(certificate);
            this.secretKey = createSecretKey();
            var encryptedSecretKey = encrypt(secretKey, publicKey);
            super.dataInterchange(encryptedSecretKey, null, url);
        }
    }

    private String createSecretKey() {
        return String.valueOf(ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE));
    }

    private String encrypt(String text, String key) {
        return text; // ... дополнительные действия
    }

    private String getPublicKeyFromCertificate(String certificate) {
        return certificate.substring(0, 10);
    }

    private String getServerCertificate(String url) {
        // заглушка
        return "some certificate";
    }

    private boolean checkCertificateInCertificateAuthority(String certificate) {
        // более сложная логика
        return true;
    }
}

Структурное наследование: наследование класса от интерфейса Summable, который добавляет классу "возможность" суммирования. Это полезно при работе с разными математическими понятиями, поддерживающими операцию суммирования -- например для скаляров (MyInt) и векторов (Vector).

enum OperationResult {
    SUCCESS,
    FAILURE
}

abstract class Summable extends Any {
    abstract void sum(Summable number);
    abstract int getLength();
    abstract OperationResult getSumOperationResult();
    abstract List<Summable> getValues();
}

class MyInt extends Summable {
    private OperationResult addOperationResult;

    int value;

    public MyInt(int value) {
        this.value = value;
    }

    @Override
    void sum(Summable number) {
        if (number.getLength() != this.getLength()) {
            return ;
        }

        MyInt myInt = new MyInt(0);
        myInt = Any.assignmentAttempt(number, myInt);
        if (myInt == null) {
            addOperationResult = OperationResult.FAILURE;
            return;
        }

        this.value += myInt.value;
        addOperationResult = OperationResult.SUCCESS;
    }

    @Override
    int getLength() {
        return 1;
    }

    @Override
    OperationResult getSumOperationResult() {
        return this.addOperationResult;
    }

    @Override
    List<Summable> getValues() {
        var list = new ArrayList<Summable>();
        list.add(new MyInt(this.value));
        return list;
    }
}

Python

# 3. Structure inheritance
class SimpleResponse(TypedDict):
    content: bytes
    content_length: int
    status: HTTPStatus

class BaseAPI:
    def __init__(self, url: str):
        self.url = self.validate(url)

    def upload_content(self, content: bytes) -> SimpleResponse:
        response = ...
        return response

    def validate(self, url: str) -> str:
        raise NotImplementedError

class BaseView:
    ...

    def has_view_permission(self, request, user=None) -> bool:
        return True

class SecretView(BaseView):
    ...

    # 1.1. Functional variation inheritance
    def has_view_permission(self, request, user=None) -> bool:
        if user and user.is_admin:
            return True
        else:
            return False

class FileAPI(BaseAPI):
    # 1.2. Type variation inheritance
    @overload
    def upload_content(self, content: Union[str, Path]) -> SimpleResponse: ...

    def upload_content(self, content) -> SimpleResponse:
        with open(str(content), mode='rb') as file_obj:
            content = file_obj.read()
        response = super().upload_content(content)
        return response

    # 2. Reification inheritance
    def validate(self, url: str) -> str:
        valid_url = ...
        return valid_url



30. Категории наследования-3

7) Наследование реализации (implementation inheritance)

Это стандартный вид наследования, когда класс-потомок наследует полностью реализованный класс-предок (который, как правило, воплощает наследование с конкретизацией), добавляя свою уникальную абстракцию структуры данных.

В чём отличие этого вида наследования от наследования с ограничением/расширением? В последнем случае иерархия строится на основе анализа предметной области, в которой выделяются различные связанные друг с другом сущности. В случае наследования реализации речь идёт о наследовании именно программной реализации. На первом курсе по ООАП говорилось о трёх видах классов в проекте: классы анализа (наследование с ограничением/расширением относится именно к ним), и "внутренние" классы проектирования и реализации, к которым прежде всего и относится наследование реализации.

8) Льготное наследование (facility inheritance)

Это специфическая категория, когда класс-предок содержит некоторый стандартный набор компонентов, объединённых в одно целое для удобства. Его потомки реализуют конкретные частные случаи. Например, родительский класс Exception содержит наборы констант и базовые механизмы возбуждения и обработки исключительных ситуаций, а его наследники воплощают конкретные виды исключений. 


31. Специфика наследования реализаций

Проектирование иерархии АТД -- задача достаточно высокого уровня абстракции, но когда мы спускаемся на уровень реализации, возникают не менее важные технические моменты. В частности, как правильнее, в каких объёмах, наследовать реализацию родительского класса?

В рамках модели ООП, которую мы изучали на первом курсе, класс -- это (возможно, частичная) реализация АТД. Он включает и публичный интерфейс, заданный АТД, и различные скрытые поля и методы, обеспечивающие эффективную реализацию этого интерфейса. Поэтому, наследуя некоторый класс, практически всегда с наследованием спецификации АТД по умолчанию наследуется и вспомогательная реализация, которая никак не формализована, что обязательно надо учитывать.

Надо ли наследовать реализацию? Если она хорошая, если она гармонично встраивается в классы-потомки, можно её наследовать. Однако надо помнить, что оригинальная реализация в классах-предках со временем вполне может измениться, что приведёт к непредсказуемым последствиям.

Поэтому важно делать выбор сознательно. Если разрешаем в иерархии классов наследование реализаций, тогда надо изучать, как в конкретном языке программирования организовано наследование скрытых полей и методов, чтобы учитывать, насколько реализация может быть защищена от изменений.

Или же классы будут плоскими (программист-пользователь вообще не видит схему наследования) -- придерживаемся исключительно спецификации АТД, но это может потребовать приличной дополнительной работы и дублирования логики реализации. В иерархии повторно используются только интерфейсы-спецификации, вся дополнительная информация внутри класса не наследуется и закрыта для модификаций. В целом, первоначально лучше исходить из этой второй схемы, но не опасаться наследования качественных реализаций, что ООП позволяет организовывать красиво и корректно.

Задание 21.

Приведите пример кода, где выполняется наследование реализации и льготное наследование. 

 Java

Наследование реализации: класс "диаграмма классов" наследует реализацию класса "дерево", так как для хранения дерева иерархии классоа не требуется особая структура данных. Достаточно использовать стандартное дерево, возможно, расширив его небольшим числом специфичных операций.

class Tree<T> {

    public Tree(T rootData) { ... }
    public void add(T parent, T value) { ... }
    private Node<T> searchNode(Node<T> currentNode, T value) { ... }
   }
}

class ClassDiagram extends Tree<Class> {

    public ClassDiagram(Class rootData) {
        super(rootData);
    }
}

Льготное наследование: наследование класса FailedAmazonS3Response от класса HttpResponse. Ответ про сбой от хранилища Amazon S3 -- по сути, обычный ответ на http-запрос, который внутри себя содержит как стандарные сведения, так и дополнительную уточняющую информацию.

class HttpResponse {
    private int statusCode;
    private byte[] body;

    public HttpResponse(int statusCode, byte[] body) {
        this.statusCode = statusCode;
        this.body = body;
    }
}

class FailedAmazonS3Response extends HttpResponse {
    private String key;
    private String bucketName;
    private String region;

    public FailedAmazonS3Response(String key, String bucketName, 
            String region, int statusCode, byte[] body) {
        super(statusCode, body);
        this.key = key;
        this.bucketName = bucketName;
        this.region = region;
    }
}

Python

Наследование реализации: Имеется класс Creature, и потребовалось добавить расу, которая накапливает статусы состояния, и не расходует их по мере течения игрового времени. При этом такой режим можно включать и выключать.
Данный пример похож на наследование с расширением. Разница прежде всего в акцентах: в случае наследования с расширением мы вообще не задумываемся о реализации, а только расширяем набор операций. В случае наследования реализации по каким-то причинам решено было её учитывать, и в целом этого желательно всегда избегать, хотя на практике удаётся далеко не всегда.

class Creature():
    def __init__(self, hp):
        self.hp = hp
        self.resistances = {}
        self.statuses = []

    def end_turn(self):
        for status in self.statuses.copy():
            status.tick(self)
            if status.duration <= 0:
                self.statuses.remove(status)

class AnotherCreature(Creature):
    def __init__(self, hp):
        super().__init__(hp)
        self.suppress = True

    def end_turn(self):
        if not self.suppress:
            super().end_turn

Льготное наследование: Класс-концовка игры. Мы создаем класс-событие, выполняющее нужные действия при завершении игры, и наследуемся от него, задавая новое описание. Например, если в игре потребуется создать тупиковую ветку, приводящую к концу игры, мы просто создадим наследника корневого завершения с новым описанием.

class GameOver():
    same_text = ''

    def __init__(self):
        print(self.same_text)
        print('Game Over!')


class HappyEnding(GameOver):
    same_text = 'And they lived happily ever after'


class BadEnding(GameOver):
    same_text = 'And died on the same day. Today.'



32. Наследование вида

Существует ещё один вид наследования -- наследование вида, который применяется в сложных и неоднозначных ситуациях. Ранее упоминался важный принцип, по которому надо стараться максимально избегать цепочек условных конструкций (проверок состояния некоторого идентификатора во время работы программы) в пользу наследования (введения отдельных классов для каждого состояния с поддержкой статических проверок типов). Однако часто возникает ситуация, когда таких сущностей в классе несколько, и надо их все как-то учесть совместно в одной иерархии, и при этом желательно избежать множественного наследования.

Например, класс Сотрудник может характеризоваться как своей должностью из фиксированного перечня (Программист, Инженер, Менеджер), так и формой рабочего соглашения (Постоянный сотрудник, Контрактник, ...). Можно создать по классу на каждую из таких сущностей, и все их сделать прямыми наследниками Сотрудника, но это неверный подход, так как две разные семантические категории будут полностью перемешаны. Можно создать две иерархии, одна из которых, например, Должность, будет объединять должности, а другая (Соглашение) формы рабочих соглашений, и унаследовать конкретные классы уже от них. Такой подход называется наследование видов (наследуются способы классификации класса-предка). Главный его недостаток, что он требует множественного наследования, и кроме того, это достаточно сложный способ проектирования иерархий.

Если множественное наследование не поддерживается, обычно выделяют один признак как первичный -- на его основе и формируется иерархия. Однако задавать остальные признаки с помощью перечислимых полей класса всё равно будет неверным. Например, мы выбрали Должность как ключевой признак, и сделали Программиста, Инженера, Менеджера наследниками Сотрудника, добавив в него целочисленное поле Contract, которое кодирует форму контракта. Это плохой способ, нарушающий многие принципы ООП, потому что мы предполагаем необходимость цепочек условных проверок значения этого поля и постоянной модификации кода многих классов в случае расширения диапазона значений Contract. 



33. Наследование вида и полиморфизм

На помощь приходит полиморфизм. Класс Соглашение с подклассами Постоянный сотрудник, Контрактник, ... мы реализуем отдельной, независимой иерархией, и поле Contract в классе Сотрудник будет иметь тип Соглашение (отношение has-a). Возможно, для реализации иерархии Соглашения хорошо подойдёт льготное наследование, так как скорее всего наследовать потребуется лишь константы. Другой хороший подход -- выделить в Соглашении набор операций, специфических именно для него. Более того, очень возможно, что и иерархию классов Должности как потомков Сотрудника тоже лучше вынести в свою отдельную автономную иерархию, как и Соглашение, с отношением "содержит" для класса Сотрудник (сотрудник "содержит" и конкретное соглашение, и конкретную должность).

Наследование вида полезно в следующих случаях:
-- подразумевается несколько критериев классификации некоторой родительской сущности, и выделить из них единственный самый главный не удаётся;
-- подразумевается активное комбинирование этих критериев (разные значения должностей и рабочих соглашений);
-- родительская сущность каждой иерархии играет в проекте весьма серьёзную роль, и качественно продумать её спецификацию АТД очень важно.

Задание 22.

Приведите пример иерархии, которая реализует наследование вида, и объясните, почему. 

 Приведите пример иерархии, которая реализует наследование вида, и объясните, почему.

Java

interface Material {
     // материал для шитья
    void sew();
}

class Wool implements Material {
    @Override
    public void sew() {}
}

class Cotton implements Material {
    @Override
    public void sew() {}
}

interface Clothes {
    // материалы, из которых изготовлена вещь
    Material[] getMaterials();

    // надеть одежду
    void putOn();
    int getSize();
    String getBrand();
}

class Blouses implements Clothes {
    private final Material[] materials;
    private final String brand;
    private final int size;

    public Blouses(Material[] materials, String brand, int size) {
        this.materials = materials;
        this.brand = brand;
        this.size = size;
    }

    @Override
    public Material[] getMaterials() {
        return new Material[0];
    }

    @Override
    public void putOn() {}

    @Override
    public int getSize() {
      return this.size;
    }

    @Override
    public String getBrand() {
        return this.brand;
    }
}

class Trousers implements Clothes {

    private final Material[] materials;
    private final String brand;
    private final int size;

    public Trousers(Material[] materials, String brand, int size) {
        this.materials = materials;
        this.brand = brand;
        this.size = size;
    }

    @Override
    public Material[] getMaterials() {
        return new Material[0];
    }

    @Override
    public void putOn() {}

    @Override
    public int getSize() {
        return this.size;
    }

    @Override
    public String getBrand() {
        return this.brand;
    }
}

Имеется класс "Одежда", от которого наследуются классы "Брюки" и "Блузки".
Одежда предполагает несколько связанных сущностей, определяющих состояние вещи.
В частности, одежда характеризуется формой и материалом, из которого она сделана. Оба этих признака часто используются вместе.
Признак формы логично выделить основным: клиента интересует различие прежде всего между брюками и блузками, а не между материалами, из которых они сделаны.
Поэтому признак материала выделен в отдельную иерархию -- он находится в отношении композиции с классом одежда (одежда содержит материал).

Python

class Race():
    race_name = ''
    motherland = ''

class Elf(Race):
    race_name = 'elf'
    motherland = 'Nilfadiil'

class Orc(Race):
    race_name = 'orc'
    motherland = 'Grocks mountain'

#

class GameClass():
    def battle_method(self, target):
        raise NotImplementedError

class Wizard(GameClass):
    def battle_method(self, target):
        print(f'Phew-phew. Magick missle flying to {target}')

class Barbarian(GameClass):
    def battle_method(self, target):
        print(f'GRAAAA. My axe want to crack {target}\'s head!')

#

class Hero():
    def __init__(self, race, game_class):
        self.race = race
        self.game_class = game_class

Имеется класс Hero (Герой), у которого есть своя раса (бонусы к характеристикам и т.п.).
У героя также имеется один из игровых классов (боеввые навыки и т.п.).
Сперва напрашивается создать класс Wizard как наследник класса Hero, и дополнить атрибутом расы.
Однако на курсе уже не раз отмечалось, что в подобной ситуации атрибуты будут плодить лишние условные цепочки.
Поэтому создадим иерархию классов для характеристики расы и применим льготное наследование.

Так же применим наследование реализации и создадим иерархию классов для другой важной характеристики -- игрового класса.

Итог -- отдельный класс Hero, экземпляры которого содержат в себе классы Race и GameClass как атрибуты. Часто в игровых системах стартовые раса и класс определяют существенные бонусы и ограничения, накладываемые на игровой процесс, так что мы имеем несколько критериев классификации, как минимум одна из которых может меняться в течение игры (игровой класс). Race и GameClass в принципе равнозначны, и лучше добавлять их обоих композицией.



34. Типичные проблемные особенности наследования

Наследование пред- и постусловий
Каждый класс реализует свой АТД: задаёт некоторое множество объектов, набор операций над ними, и семантику (пред- и постусловия). В ходе наследования предусловия могут ослабляться -- то есть любой пред-ослабленный метод в классе-потомке допускает применение в большем количестве случаев, нежели родительский. Усиливать же предусловия, соответственно, нельзя, иначе не будет соблюдаться спецификация родительского класса.

Например, если бы мы ошибочно сделали АТД BoundedStack (стек с ограниченым размером) наследником АТД Stack, то нам пришлось бы усилить предусловие операции push() в BoundedStack требованием учёта размера стека. Оригинальной версией push() мы пользоваться не смогли, и пришлось бы переопределить её реализацию. Но полиморфный объёкт S типа Stack может хранить объект класса BoundedStack, и при любом вызове S.push() подразумевается, что push() должен срабатывать всегда, но из-за усиления предусловия push() в классе-наследнике BoundedStack теперь вполне может возникнуть логическая ошибка вследствие неявного в данном случае ограничения на размер стека.
Это классический пример контринтуитивности правильного проектирования: хотя естественным выглядит наследование ограниченного стека от универсального стека, можно сделать наоборот, наследовать с расширением универсальный стек от ограниченного стека. Новая версия push() работает более универсально, нежели родительская, применима ко всем ситуациям, в которых применима и родительская push(), а также к ряду дополнительных.

Впрочем, возможен и другой вариант: добавить в АТД Stack запрос full() (так называемое абстрактное предусловие), который сигнализирует, полный ли стек. В Stack этот запрос всегда будет возвращать false, а АТД BoundedStack как наследник Stack переопределяет этот запрос уже с учётом реального размера.

Но в общем случае универсального решения для организации наследования между Stack и BoundedStack не находится, что показывает ограничение модели ООП.

Постусловия наоборот могут усиливаться -- то есть любой пост-усиленный метод, удовлетворяющий требованиям потомка, будет корректно применяться к объектам классов-предков. Он фактически предоставляет некоторый улучшенный результат. Но мы не можем ослаблять постусловия, иначе такое ослабление приведёт к существенному изменению (ухудшению) результата или состояния объекта, которое не специфицировано для родительского класса.

Например, постусловие для операции clear() в исходной версии стека с ограниченным количеством элементов (удалить N элементов) усиливается до удаления "всех" элементов (возможно, N, возможно, N*1000) в его потомке (универсальном стеке), и в этот усиленный, улучшенный вариант гарантированно входит и случай с удалением N элементов.

Это так называемый принцип подстановки Барбары Лисков из SOLID (Liskov Substitution Principle, LSP): потомки не должны "ломать" базовую логику, предоставляемую предками, но при этом должны обеспечивать полноценный интерфейс к этой базовой логике.

Задание 23.

Приведите словесный пример иерархии классов, и объясните, почему в ней нельзя ослаблять постусловия и усиливать предусловия. 


