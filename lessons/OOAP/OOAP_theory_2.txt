
Наследование, композиция и полиморфизм

1. Что такое наследование, композиция и полиморфизм

Наследование -- это прежде всего про повторное использование кода. Это гибкий, мощный и компактный механизм снижения проектной сложности.

Наследование даёт возможность использования уже готовых компонентов, предлагая уточнение (иногда расширение, иногда ограничение) класса-предка и спецификации АТД.

Наследование также подразумевает возможность переопределения реализации метода класса-предка, типов аргументов, типа (результата) работы метода.

Наследование -- это одно из двух фундаментальных видов отношений между классами в ООП.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

Композиция -- это отношение "содержит" (has-a), когда один объект содержит объект другого класса (как поле соответствующего типа).

Наследование может быть единичным и множественным (когда класс наследует возможности сразу нескольких классов).

Наследование тесно связано с полиморфизмом. В общем случае под полиморфизмом понимается способность различных сущностей в программе менять свою "форму" -- становиться объектами разных типов по цепочке иерархии наследования.

Задание 1.
Напишите небольшой пример кода с комментариями, где применяются наследование, композиция и полиморфизм. 


2. Введение

В первом цикле, посвящённом проектированию классов, мы видели, что даже простой подход к правильному проектированию классов на основе АТД как автономных сущностей предоставляет отличные возможности для формирования библиотек классов под конкретную предметную область, которые удобно использовать и модифицировать. Интерфейсы полностью отделены от реализаций; универсальный подход АТД (набор операций, отделённых от состояний) обеспечивает высокую гибкость; предусловия и постусловия позволяют достаточно строго контролировать корректность семантики классов и их целостность. В программировании вообще популярен и хорошо работает принцип Keep it simple, stupid (KISS), предполагающий, что большинство систем работают тем лучше, чем они проще.

Однако когда мы задумываемся о расширении нашего набора автономных классов, оказывается, что для этого требуются более мощные механизмы. В частности, наследование как концепция повторного использования кода позволила нам создать иерархию классов, где никакие методы практически не дублировались, а её структура довольно легко расширялась новыми идеологически схожими классами (различные виды списков). Это соответствие принципу You aren't gonna need it (YAGNI) -- избегание любой избыточной функциональности.

Формальный подход к наследованию подразумевает три принципиально разные возможности:
-- расширение класса-родителя (наследник задаёт более общий случай родителя);
-- специализация класса-родителя (наследник задаёт более специализированный случай родителя);
-- комбинация нескольких родительских классов.

Далеко не все языки поддерживают все эти виды отношений, мы рассмотрим универсальную, не зависящую от языков, концепцию наследования, из которой на практике вы можете применять наиболее подходящие вам приёмы.

Задание 2.
Напишите небольшой пример кода с комментариями, где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя. 

Решения задания 2

Python

class Bicycle: // велосипед
    def __init__(self, wheel_count: int = 2):
        self.wheels = [Wheel() for _ in range(wheel_count)]

class Engine: // электромотор
    def __init__(self, power: float):
        self.power = power
        print('engine power is', power)

# Специализация: шоссейный велосипед -- подтип велосипеда
# Расширение: электровелосипед, дополнен мотором
class ElectricRoadBicycle(Bicycle):
    def __init__(self, power: float):
        super().__init__()
        self.engine = Engine(power)

Java

public class Human{
    // -- voice()
    // -- walk()
    // -- run()
}

public class Worker extends Human{ 
    // специализация класса-родителя, 
    // т.к. рабочий - более частный случай,
    // т.к. все работники - люди, но не все люди - работники
    // -- work()
}

public class Car{
    // -- drive()
    // -- park()
    // -- startEngine()
}

public class AutonomousCar extends Car{ 
    // расширение класса-родителя, 
    // т.к. все самоуправляемые машины
    // являются машинами, но не все машины - самоуправляемы

    // -- autoDrive()
    // -- autoPark()
}



3. Класс как модуль и класс как тип

Класс -- это, как говорилось на первом курсе, и модуль (синтаксическая единица проекта) и тип данных (семантическая единица проекта). Наследование в каждом из этих двух случаев играет разные роли.

1) Класс как модуль.

Класс как модуль означает, что класс выступает базовой синтаксической единицей, и в виде отдельного файла, и в виде автономно компилируемой сущности. Наследование в таком случае выступает прежде всего как механизм повторного использования кода. Когда мы думаем в этой парадигме, то сосредотачиваемся в первую очередь на том, как эффективнее всего избавляться от деталей, как использовать наиболее общие подходы. В программировании это широко известный принцип Don’t repeat yourself (DRY).

Создавая новый модуль, мы опираемся на уже существующий модуль, из которого заимствуем существенную часть базовой функциональности, и дополняем его новой. В таком случае класс рассматривается как поставщик определённых служб, некоторого интерфейса. Модуль, наследующий родительский модуль, расширяет его дополнительными службами.

Реализуя в модуле (классе) "Двухсвязный список" метод left(), отсутствующий в родительском модуле "Универсальный список", мы создаём множество сущностей, к которым применим набор операции универсального списка, и дополнительно набор операций двухсвязного списка. То есть множество наборов операций, применимых к универсальному списку, будет подмножеством множества операций, применимых к двусвязному списку.

В настоящем курсе этот подход через расширение возможностей модуля-предка предлагается считать единственным способом добавления новых модулей в проект.

Когда проект большой, взаимосвязи между модулями неочевидны, поэтому каждый модуль надо стремиться делать легко расширяемым, и при этом максимально автономным -- все его связи с другими модулями должны быть строго (формально) ограничены. Модуль по сути предоставляет некоторый абстрактный интерфейс -- когда мы используем сам модуль в целом, а не запрятанный в нём код.

Задание 3.
Расскажите, как в выбранном вами языке программирования поддерживается концепция "класс как модуль".
Пока мы говорим именно про "классы" в смысле модули -- пространство имен, сборки, пакеты, библиотеки -- все что содержит готовый код и что можно импортировать в свою программу. 

