
Наследование, композиция и полиморфизм

1. Что такое наследование, композиция и полиморфизм

Наследование -- это прежде всего про повторное использование кода. Это гибкий, мощный и компактный механизм снижения проектной сложности.

Наследование даёт возможность использования уже готовых компонентов, предлагая уточнение (иногда расширение, иногда ограничение) класса-предка и спецификации АТД.

Наследование также подразумевает возможность переопределения реализации метода класса-предка, типов аргументов, типа (результата) работы метода.

Наследование -- это одно из двух фундаментальных видов отношений между классами в ООП.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

Композиция -- это отношение "содержит" (has-a), когда один объект содержит объект другого класса (как поле соответствующего типа).

Наследование может быть единичным и множественным (когда класс наследует возможности сразу нескольких классов).

Наследование тесно связано с полиморфизмом. В общем случае под полиморфизмом понимается способность различных сущностей в программе менять свою "форму" -- становиться объектами разных типов по цепочке иерархии наследования.

Задание 1.
Напишите небольшой пример кода с комментариями, где применяются наследование, композиция и полиморфизм. 


2. Введение

В первом цикле, посвящённом проектированию классов, мы видели, что даже простой подход к правильному проектированию классов на основе АТД как автономных сущностей предоставляет отличные возможности для формирования библиотек классов под конкретную предметную область, которые удобно использовать и модифицировать. Интерфейсы полностью отделены от реализаций; универсальный подход АТД (набор операций, отделённых от состояний) обеспечивает высокую гибкость; предусловия и постусловия позволяют достаточно строго контролировать корректность семантики классов и их целостность. В программировании вообще популярен и хорошо работает принцип Keep it simple, stupid (KISS), предполагающий, что большинство систем работают тем лучше, чем они проще.

Однако когда мы задумываемся о расширении нашего набора автономных классов, оказывается, что для этого требуются более мощные механизмы. В частности, наследование как концепция повторного использования кода позволила нам создать иерархию классов, где никакие методы практически не дублировались, а её структура довольно легко расширялась новыми идеологически схожими классами (различные виды списков). Это соответствие принципу You aren't gonna need it (YAGNI) -- избегание любой избыточной функциональности.

Формальный подход к наследованию подразумевает три принципиально разные возможности:
-- расширение класса-родителя (наследник задаёт более общий случай родителя);
-- специализация класса-родителя (наследник задаёт более специализированный случай родителя);
-- комбинация нескольких родительских классов.

Далеко не все языки поддерживают все эти виды отношений, мы рассмотрим универсальную, не зависящую от языков, концепцию наследования, из которой на практике вы можете применять наиболее подходящие вам приёмы.

Задание 2.
Напишите небольшой пример кода с комментариями, где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя. 

Решения задания 2

Python

class Bicycle: // велосипед
    def __init__(self, wheel_count: int = 2):
        self.wheels = [Wheel() for _ in range(wheel_count)]

class Engine: // электромотор
    def __init__(self, power: float):
        self.power = power
        print('engine power is', power)

# Специализация: шоссейный велосипед -- подтип велосипеда
# Расширение: электровелосипед, дополнен мотором
class ElectricRoadBicycle(Bicycle):
    def __init__(self, power: float):
        super().__init__()
        self.engine = Engine(power)

Java

public class Human{
    // -- voice()
    // -- walk()
    // -- run()
}

public class Worker extends Human{ 
    // специализация класса-родителя, 
    // т.к. рабочий - более частный случай,
    // т.к. все работники - люди, но не все люди - работники
    // -- work()
}

public class Car{
    // -- drive()
    // -- park()
    // -- startEngine()
}

public class AutonomousCar extends Car{ 
    // расширение класса-родителя, 
    // т.к. все самоуправляемые машины
    // являются машинами, но не все машины - самоуправляемы

    // -- autoDrive()
    // -- autoPark()
}



3. Класс как модуль и класс как тип

Класс -- это, как говорилось на первом курсе, и модуль (синтаксическая единица проекта) и тип данных (семантическая единица проекта). Наследование в каждом из этих двух случаев играет разные роли.

1) Класс как модуль.

Класс как модуль означает, что класс выступает базовой синтаксической единицей, и в виде отдельного файла, и в виде автономно компилируемой сущности. Наследование в таком случае выступает прежде всего как механизм повторного использования кода. Когда мы думаем в этой парадигме, то сосредотачиваемся в первую очередь на том, как эффективнее всего избавляться от деталей, как использовать наиболее общие подходы. В программировании это широко известный принцип Don’t repeat yourself (DRY).

Создавая новый модуль, мы опираемся на уже существующий модуль, из которого заимствуем существенную часть базовой функциональности, и дополняем его новой. В таком случае класс рассматривается как поставщик определённых служб, некоторого интерфейса. Модуль, наследующий родительский модуль, расширяет его дополнительными службами.

Реализуя в модуле (классе) "Двухсвязный список" метод left(), отсутствующий в родительском модуле "Универсальный список", мы создаём множество сущностей, к которым применим набор операции универсального списка, и дополнительно набор операций двухсвязного списка. То есть множество наборов операций, применимых к универсальному списку, будет подмножеством множества операций, применимых к двусвязному списку.

В настоящем курсе этот подход через расширение возможностей модуля-предка предлагается считать единственным способом добавления новых модулей в проект.

Когда проект большой, взаимосвязи между модулями неочевидны, поэтому каждый модуль надо стремиться делать легко расширяемым, и при этом максимально автономным -- все его связи с другими модулями должны быть строго (формально) ограничены. Модуль по сути предоставляет некоторый абстрактный интерфейс -- когда мы используем сам модуль в целом, а не запрятанный в нём код.

Задание 3.
Расскажите, как в выбранном вами языке программирования поддерживается концепция "класс как модуль".
Пока мы говорим именно про "классы" в смысле модули -- пространство имен, сборки, пакеты, библиотеки -- все что содержит готовый код и что можно импортировать в свою программу. 


Наследование, композиция и полиморфизм

Решения задания 3

Python

В Python можно классы хранить в модулях, а модули организовывать в пакеты в виде иерархии каталогов.
Можно импортировать, соответственно, класс, модуль и пакет, и работать с ними как с отдельными сущностями.
При этом модуль имеет "конструктор" -- код, который однократно запускается при его первом импорте.

Java

Концепция "класс как модуль" в Java поддерживается например через иерархию каталогов.
Корневой узел такой иерархии называется пакетом (по сути модулем).
Для подключения пакета используется синтаксис
package *name1.name2....*
для импорта
import *name1.name2....* 


4. Реализация расширяемости модулей

Одна из классических проблем расширяемости -- это форма её реализации. Можно либо наследовать функциональность, создавая новые модули, либо настраивать её с помощью различных конфигурационных схем (включая, например, скриптовые языки).

Тут надо отметить некоторую ошибочность классического понятия паттернов проектирования, которые обычно воспринимаются как просто полезные механические конструкции для решения конкретных задач. Однако их реальная ценность прежде всего в возможности повторного использования неких универсальных структур данных, которые мы наследуем и реализовываем, дополнительно расширяем применительно к своему проекту. Это, в частности, упоминавшиеся на прошлом курсе классы поведения, в которых открытый интерфейс описывается с помощью низкоуровневых методов, как правило, отложенных, что обеспечивает высокую гибкость. Если паттерн достаточно крупный, может получиться целый фреймворк, набор модулей, хорошо расширяемый каркас. 


5. Основополагающий принцип открытости-закрытости модуля

Это первый из пяти фундаментальных принципов объектно-ориентированного программирования и проектирования, известный как The Open Closed Principle (OCP). Сами принципы в нынешней форме были собраны в начале 2000-х годов Робертом Мартином ( автором легендарных книг "Чистый код", "Чистая архитектура", "Идеальный программист" и др.) и получили общее название SOLID (от первых букв названий принципов).

Модуль считается открытым, если его можно продолжать расширять.

Модуль считается закрытым, когда он выложен в продакшен, и им можно только пользоваться.

На практике мы получаем парадоксальное требование, что модуль должен быть закрытым, чтобы он поступил в эксплуатацию, но он должен быть открытым для дальнейшей модификации в процессе развития проекта. Представим, что у нас имеется закрытый модуль, и потребовалось что-то расширить в его функциональности, так как никогда не будет гарантии, что мы заранее учли все проектные особенности. Ужасный способ сделать это -- создать полную копию закрытого модуля, и что-то в нём начать менять. Правильно решается эта проблема именно наследованием.

Задание 4.
Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми. 

Решения задания 4

Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Фактически все базовые классы любой стандартной библиотеки не могут быть изменены, чтобы не произошли непредвиденные изменения в системе, поэтому они "закрытые". Но от них можно наследовать конкретные прикладные "открытые" классы, доступные для модификации программисту, которые расширяют или специализируют базовый функционал родительских "закрытых" классов.
Часто такой подход применяется при создании графического интерфейса: например, если требуется кнопка с оригинальным поведением или изображением, она наследуется от стандартного класса Button, после чего в ней переопределяется, например, метод отрисовки.

Хорошей причиной для открытости модуля будет потенциальная польза от его расширения.
Например, сделав модуль "Анализатор логов" открытым, мы даем возможность клиентам самим доопределять изначальнай алгоритм, добавляя нужное им поведение.

Если модуль делает что-то конкретное, без потенциального разнообразия, то это кандидат на закрытость. Например, модуль занимающийся отправкой документов внешнему провайдеру документооборота нужно делать закрытым, так как он делает вполне определенное действие, и расширять его стандартное поведение нет необходимости. 


6. Принципы повторного использования модуля

Полноценный механизм добавления в проект нового модуля, подразумевающего повторное использование кода, должен отвечать всем пяти нижеприведённым принципам.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля;

4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра;

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

На практике выдерживать все эти правила не удаётся. Например, если попробовать использовать механизм стандартных библиотек для реализации модулей, то окажется, что он подходит только для достаточно простых проектов, когда имеются чёткие разграничения между спецификациями, отсутствуют смысловые взаимосвязи, и все функции различаются и синтаксически, и семантически. В лучшем случае удастся выполнить требования принципов 2, 3 и 5.

В некоторых языках поддерживаются пакеты со своими оригинальными именами, раздельной компиляцией, публичным интерфейсом и скрытой реализацией. Пакеты в таком случае выступают как абстрактные модули без реализации, однако тоже они не отвечают, в частности, принципу 4 -- конкретную реализацию придётся выбирать самому программисту.

Возможность переопределения имён в модулях (и в частности, перегрузки операторов для разных типов аргументов) частично хороша, но в целом плохо читабельна, не поддерживает обобщённые типы, и главное, если у некоторых функций имеются различия в семантике, то эти различия должны наглядно отражаться и на уровне синтаксиса, что перегрузка не позволяет по своей сути.

В ООП различаются термины "переопределение" (overridde) и "перегрузка" (overload). Переопределение -- это перезапись логики родительского метода с точно такой же сигнатурой в классе-потомке. Перегрузка -- когда в нескольких реализациях метода внутри одного класса его имя одно и то же, а список аргументов различается.
Хотя в разных языках эти схемы могут и различаться.

Если же мы попробуем использовать шаблоны модулей, параметризованные типами (когда одна и та же реализация применяется к различным видам объектов), то получится фактически, что у нас имеется параметризованный типами открытый универсальный модуль, но напрямую не применимый (потому что это шаблон), и имеется условный набор его конкретных реализаций, закрытых для изменений (так как поддержка параметризации встроена в язык). Это нарушает ключевой принцип открытости-закрытости -- непонятно, как расширять такие шаблоны, не меняя уже использующий их код.

Задание 5.
Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?
(напомню, что пока речь идёт именно о модулях как базовой синтаксической единице, а не о классах) 

Решения задания 5

Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?

Python и Java

1) В обоих языках нет возможности параметрировать модуль типом.

2) Поддерживается создание модуля, объединяющего несколько активно обращающихся друг к другу функций.

3) Поддерживается возможность объединения модулей в пакеты/сборки.

4) На уровне модулей в обоих языках нет "автоматического" полиморфизма. Можно вручную импортировать только нужные функции из модуля "родителя" и переопределить оставшиеся.

5) С помощью композиции можно интегрировать несколько модулей с небольшими отличиями в поведении в один. При этом модуль имеет "конструктор" (код, который однократно запускается при его первом импорте). 


7. Разбираемся с модульным противоречием

Выход из противоречивой модели модуля находится в парадигме ООП. Классические попытки совместить все пять принципов с помощью модулей, компонентов, пакетов, терпят неудачу.

Тема декомпозиции проекта на небольшие автономные сущности изучается в программной инженерии не менее полувека. Идея модулей строится вокруг набора функций, вокруг парадигмы так называемого структурного программирования, а ООП -- вокруг объекта. Это вечные попытки как-то более-менее эффективно разрешить конфликт между данными и функциями/методами их обработки. Подробно тему декомпозиции, построения модели предметной области, проектирования качественной иерархии классов, изучаем на следующем курсе. Пока мы приближаемся к идее, что класс (с использованием наследования и полиморфизма) представляется наиболее оптимальной формой модуля. Только надо всегда помнить, когда мы выполняем декомпозицию, то выделяем классы таким образом, что они представляют собой не просто наборы функций, а прежде всего некоторые структуры данных, которые хоть и описываются только операциями, однако все эти операции имеют семантическое отношение именно к своей структуре данных.

Основа объектно-ориентированного подхода -- это приоритет типов данных над описывающими их операциями. То есть в списке методов класса, который всегда задаёт некоторую структуру данных, не должно быть методов, не имеющих прямого отношения к этой структуре данных.

Задание 6.
Существуют ли ситуации, когда связи между модулями должны делаться публичными?
Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам? 

Решения задания 6

Существуют ли ситуации, когда связи между модулями должны делаться публичными?

В общем случае это нарушение инкапсуляции и принципа единственной ответственности SRP (The Single Responsibility Principle, изучаем далее).
На практике допускаются технические исключения, когда проще и выразительнее сделать общедоступными некоторые связи модуля, которые используются во множестве других модулей. Например, это может быть модуль, содержащий инфраструктурный код (логирование, метрики, ...).
И надо также учитывать, что наличие множества неявных связей (зависимостей) приводит к трудноконтролируемому проекту. Большое количество таких связей -- признак плохого проектирования.

Какие метрики вы бы предложили для количественной оценки принципов организации модулей?

Например, количество семантических единиц в программе, так называемых "сущностей". Хотя слепо минимизировать их тоже будет некорректным.

Формально, между модулями нужно выдерживать как можно меньшую связность, т.е. делать модули независимыми. Поэтому для количественной оценки можно использовать количество связей, исходящих из модуля (модули, от которых зависит данный модуль), и количество связей, входящих в модуль (модули, зависящие от этого модуля).

Соответственно, надо стремиться делать максимально автономные модули (минимизируя исходящие связи). Если у автономного модуля всего одна входящая стрелка, то, возможно, он используется всего один раз, и разбиение на модули было некорректным. Также будет плохим случай, когда связей слишком много, например "все зависят от всех", или когда задействуется слишком много контекста, а используется из него далеко не всё.

Если вы разрабатывали программы, в которых было хотя бы 3-5 классов,как бы вы оценили их модульность по этим метрикам?

Пример 1.
Есть абстрактный класс Pizza и много-много классов, реализующих конкретные виды пицц.
Есть абстрактный класс Coffee и также много-много классов, реализующих конкретные виды кофе.
Есть абстрактный класс Restaurant и классы, реализующие конкретные рестораны, где продается пицца и кофе.
Добавим абстрактный класс Courier и классы, реализующие конкретные типы доставки.
Получаются три семантические единицы: еда, заведение, доставка, которые можно представить в виде разных модулей. Это вполне хороший показатель для проекта, где классов могут насчитываться сотни и тысячи.

Пример 2.
Из 6 классов один был "закрытым". Он был очень перегруженным как публичными, так и условно скрытыми методами. Они в остальных 5 дочерних классах переопределялись (override) в разных комбинациях. Принципы открытости-закрытости и повторного использования нарушались повсеместно, что быстро похоронило программу. 


8. Класс как тип

Во взгляде на класс как на тип мы пытаемся совместить принцип повторного использования кода с расширяемостью, которой не удалось полноценно достичь с помощью модулей. И ключевым в таком подходе к наследованию становится полиморфизм и динамическое связывание.

Посмотрим на отношение класс как тип относительно связываемых значений (объектов) как на отношение включения множеств. Например, множество всех объектов "Двухсвязный список" во время работы программы является подмножеством множества всех объектов "Универсальный список". Причём эти два типа не обязательно наследуются напрямую, между ними может быть цепочка промежуточных типов.

Если же посмотреть на это отношение относительно операций над соответствующими типами (по сути, как на отношение между АТД), то отношение "каждый двухсвязный список является универсальным списком" означает, что любая операция, применимая к родительскому универсальному списку, применима также и к дочернему двухсвязному списку (с учётом того, что эти операции могут быть переопределены в двухсвязном списке), но не наоборот.

То есть в случае "класс как тип" мы получаем не расширение родительского класса, а специализацию, что прямо противоположно подходу "класс как модуль".

В результате на практике появляются подобные частые ошибки: "двухсвязный список my_list_007 в моём коде является универсальным списком". Тут используется отношение между значением и категорией, что неверно. Отношение "является" всегда выражает отношение только между категориями (типами, классами). Например, всякий АТД "Двухсвязный список" является АТД "Универсальный список".

Какой из этих подходов более правильный для понимания принципа наследования? Как может быть разрешён парадокс расширения-специализации? Фактически получается, что чем больше у нас различных типов в цепочке наследования, тем к меньшему количеству объектов они могут применяться, так как мы движемся вниз по иерархии в направлении специализации.

Поэтому в частности, некорректно применение массово распространённого термина "подкласс" и в смысле подмножества, и в смысле наследования. Правильно использовать только такие термины: наследник и родитель, потомок и предок, прямой/собственный потомок и предок. 


9. Динамическое связывание

Наиболее глубокая и при этом достаточно абстрактная (универсальная) форма реализации отношения наследования (в общем случае повторного использования) -- это динамическое связывание. Программисту не требуется постоянно уточнять, метод какого конкретно типа (класса) должен быть вызван, он будет определён автоматически. Это очень важная возможность, которую мы никак не сможем получить, оставаясь в парадигме модулей -- ни универсализм, ни перегрузка операторов, и ничто иное.

Чем плохо статическое связывание? Если можно заранее, анализируя исходные тексты, автоматически определить, какой конкретно тип будет у полиморфного объекта в некотором случае, то эту работу должен выполнить компилятор, и только с целью оптимизации вызовов. Если же программист в такое связывание вкладывает другой смысл, нежели подразумевает компилятор, то это надо считать ошибкой. Так, если программист может выбирать политику статического связывания сам, то легко нарушить принцип открытости-закрытости: может потребоваться модификация класса, закрытого для изменений, которую заранее нельзя было предвидеть. Это можно решить переопределением нужного метода в классе-наследнике, однако если политика статического связывания возложена на программиста, то в таком случае вполне возможна ситуация, когда в предке не задана виртуальность соответствующего изменяемого метода, что потребует внесения правки в вышестоящий класс (уточнение сигнатуры метода), который уже закрыт для изменений. В разных языках эта проблема может проявляться по разному, например в Java все функции по умолчанию считаются виртуальными, а в С++ наоборот, невиртуальными.

В общем случае наследование позволяет создавать новые классы, которые и расширяют, и специализируют уже существующие классы. Это достигается с помощью трёх механизмов: переопределения в классе реализации методов его прямого предка, использования полиморфных объектов и динамического связывания.

При этом правильно спроектированный класс с точки зрения пользователя-программиста в идеале вообще не должен демонстрировать схему своего наследования. Наследование -- это внутренний механизм, и если полиморфизм в отношении класса не подразумевается, то и всю логику наследования для этого класса по возможности желательно скрыть. Такой класс, в отношении которого с точки зрения его пользователя наследование не применяется, называется плоским.

Во всех остальных случаях наследование требуется ровно в тех границах, которые обеспечивают необходимую логику полиморфизма и динамического связывания в проекте.

Задание 7.
Приведите пример кода с комментариями, где применяется динамическое связывание. 

Решения задания 7

Приведите пример кода с комментариями, где применяется динамическое связывание.

Java

class Expression {
    @Override
    public String toString() {
        return "some expression";
    }
}

class SimpleExpression extends Expression {
    @Override
    public String toString() {
        return "some simple expression";
    }
}

class ComplexExpression extends SimpleExpression {
    @Override
    public String toString() {
        return "some complex expression";
    }
}

...

Expression expression = new ComplexExpression();
System.out.println(expression); // "some complex expression"

Python

# вычисление хэш-функции
class IHasher(ABC):
    @abstractmethod
    def hash_fun(self, key: str) -> int:
        pass

class SumHasher(IHasher):
    def hash_fun(self, key: str) -> int:
        acc = 0
        for c in key:
            code = ord(c)
            acc = acc + code
        return acc

class DJB2Hasher(IHasher):
    def hash_fun(self, key: str) -> int:
        # djb2
        acc = 5381
        for c in key:
            code = ord(c)
            acc = (acc << 5) + acc + code
        return acc % 4294967296

hasher: IHasher = SumHasher()
h = hasher.hash_fun("skillsmart") # 1094
print(h)
hasher = DJB2Hasher()
h = hasher.hash_fun("skillsmart") # 458085675
print(h)



10. Пример динамического связывания и полиморфизма

Например, у нас имеется иерархия из трёх классов (Универсальный список ParentList, связный список LinkedList и двухсвязный список TwoWayList), которую мы делали на первом курсе.

Объект p имеет тип ParentList, объект l -- тип LinkedList, и объект t -- тип TwoWayList. Тогда в программе разрешены так называемые полиморфные присваивания:

p = l
p = t

В переменную родительского класса записывается объект (ссылка на объект) дочернего класса.

Так как все объекты передаются по ссылке, в таком случае "изменение" типа объекта по своему смыслу подразумевает подмену некоторых методов, которые реально будут вызываться. Например, если переменная p хранит указатель на объект типа LinkedList, то при обращении p.right() будет вызван метод right() класса LinkedList, о чём разработчик заранее не знает. Объекты из данного и подобных примеров называются полиморфные -- их реальный тип может не совпадать с типом переменной, в которой они хранятся (фактически, в которую записана ссылка на соответствующий объект).

При этом надо иметь в виду возможную потерю информации: несмотря на то, что p хранит ссылку на объект типа TwoWayList, обращаться к методам класса TwoWayList напрямую мы не можем (если только не использовать явное приведение типов, что настоятельно не рекомендуется -- об этом будет рассказано далее). Однако такая потеря компенсируется динамическим связыванием, подразумевающим, что нужный метод полиморфного объекта будет определён динамически -- в зависимости от его реального типа в ходе работы программы.

Аналогичную семантику имеет и полиморфизм при передаче аргументов. Если конкретный язык программирования такое допускает, то в классе могут быть методы с одинаковыми именами, отличающиеся друг от друга типами каких-то аргументов. В таком случае выбор подходящего метода в процессе работы программы тоже происходит динамически и полиморфно. 


11. Ковариантность и контравариантность

Уточняющие комментарии про расширение и специализацию в ходе наследования.

Когда мы смотрим на класс как на тип, то при спуске по иерархии наследования мы получаем всё более специализированные типы, так как всё чаще не можем использовать оригинальные методы предков из-за их переопределения. Например, не имеет смысла двухсвязному списку наследовать методы из однонаправленного списка -- большинство их придётся переопределять. Причём ряд этих методов придётся переопределять только потому, что внутри, в реализации они работают с разными типами (например, с разными типами узлов в списке), а сам алгоритм остаётся по сути оригинальным. Мы просто его копируем, лишь модифицируя объекты некоторых типов. Не возникает никаких конфликтов с системой типов, однако эта система типов и никак нам не помогает в избегании дублирования кода (или как минимум, дублирования семантики).

Проблема в подобных случаях по сути единственная: нам надо сохранить родительскую логику, "параметризуя" её типами. Тут надо исходить из возможностей конкретного языка программирования, позволяет ли он автоматически связывать, по мере спуска по иерархии, типы атрибутов класса с типом текущего объекта без явного переопределения логики (определения типов полей мы задаём относительные, а не абсолютные -- относительно текущего типа). Это так называемая ковариантная типизация. Чаще всего она реализуется в форме обобщённых типов: если мы определяем контейнер, параметризованный типом Кот (который есть потомок типа Животное), то естественно, что этот тип "контейнер котов" автоматически будет потомком (частным случаем) типа "контейнер животных" (ковариантность типу-параметру Кот), и ему будут доступны все соответствующие методы типа-предка.

Другая схема ковариантности: переопределённый метод родительского класса может возвращать значение типа, который есть потомок типа значения, возвращаемого родительским методом.

Противоположный подход -- контравариантность, когда схема наследования переворачивается. Тут классический пример -- это делегаты (объекты, указывающие на функции). Есть обобщённый (параметризованный типом "Универсальный список") делегат "действие A над универсальным списком", который считается уже потомком делегата "действие А над связным списком" (при том, что связный список -- потомок универсального списка). В таком случае, подразумевая действия над универсальными списками, мы корректно сохраняем допустимость для них лишь ограниченного набора операций для связных списков, и не более. Потому что некоторое действие, специфичное именно для связного списка, нельзя применять к его предку, универсальному списку, такое действие не поддерживающему.

Это более простой формальный подход, так называемый subtyping, в чём-то более элегантный, однако на практике рекомендуется всегда ориентироваться на более практичные ковариантные подходы, подразумевающие специализацию кода, более естественно отражающую иерархию наследования.

Задание 8.

Приведите примеры кода с ковариантностью и контравариантностью, если ваш язык программирования это позволяет. 

Решения задания 8

Приведите примеры кода с ковариантностью и контравариантностью.

Python

Пример 1

#ковариантность

from typing import Generic, TypeVar, Callable

animal = TypeVar('animal', covariant=True)

class Animal(): pass
class Cat(Animal): pass

# Контейнер на вход принимает любой объект типа Anuimal
class Box(Generic[animal]):
    def __init__(self, content: animal) -> None:
        self._content = content

# Можно проверить контейнер с животным, 
# а значит, и с котом, как частным случаем животного
def check_box(box: Box[Animal]):
    pass

box = Box(Cat())
check_box(box)

#контравариантность

class Person(): pass
class Sportsman(Person): pass
class Policeman(Person): pass

def person_run(person: Person) -> None:
    print('Person running')

# Спортсмен и полисмен могут бегать: 
def sportsman_run(sportsman: Sportsman) -> None:
    print('Sportsman running. So fast!')
def policeman_run(policeman: Policeman) -> None:
    print('The policemen don\'t run. He shoots.')

# ковариантным типом по документации считается Callable
def make_sportsman_run(sportsman: Sportsman, run_func: Callable[[Sportsman], None]):
    print('Shoot in the air with gun!')
    run_func(sportsman)

# подойдёт даже обычный Person
make_sportsman_run(Sportsman(), person_run)

# а вот на типе Policeman будет ошибка
make_sportsman_run(Sportsman(), policeman_run)

Пример 2

# ковариантность

class Sword: pass
class FuryBlade(Sword): pass

class Knight:
    def get_melee_weapon(self):
        return Sword()
class Paladin(Knight):
    def get_melee_weapon(self):
        return FuryBlade()

knigt, paladin = Knight(), Paladin()
s, fb = knigt.get_melee_weapon(), paladin.get_melee_weapon()

isinstance(s, Sword), isinstance(s, FuryBlade)
# (True, False)

isinstance(fb, Sword), isinstance(fb, FuryBlade)
# (True, True)

# контравариантность

from typing import TypeVar, Generic

T_contra = TypeVar('T_contra', contravariant=True)

class _T(Generic[T_contra]):
    def __init__(self, item: T_contra) -> None: ...

class BladedWeapon: pass
class Sword(BladedWeapon): pass
class Broadsword(Sword): pass
class Cutlass(Broadsword): pass
class Shuriken(BladedWeapon): pass

def sharpen_melee_weapon(weapon: _T[Broadsword]) -> None: pass

sword1, sword2 = _T(Broadsword()), _T(Sword())
sharpen_melee_weapon(sword1)  # OK
sharpen_melee_weapon(sword2)  # OK

shuriken = _T(Shuriken()) 
# error: "sharpen_melee_weapon" has incompatible type _T[Shuriken]
sharpen_melee_weapon(shuriken) # error

cutlass = _T(Cutlass()) # error ...
sharpen_melee_weapon(cutlass) # error

Java

// Ковариантность:
List<Integer> l1 = new ArrayList<>();
l1.add(42);
List<? extends Number> l2 = l1; // read-only список. 
// Безопасное приведение потомка(Integer) к родителю (Number)


// Контравариантность:
List<Number> l3 = new ArrayList<>();

List<? super Double> l4 = l3; // write-only список. 
// Безопасное приведение родителя (Number) к потомку (Double)

// Такой механизм позволяет обходить небезопасное приведение типов,
// когда в List<Double> могут оказаться значения типа Integer, 
// если сначала List<Double> привести к List<Number>



12. Общая структура иерархии классов в проекте

Несмотря на то, что для пользователей прикладной системы типов в проекте каждый класс в идеале должен быть плоским, внутри проекта все классы, также в идеале, надо объединять в одну иерархию.

Во главе этой иерархии располагается самый базовый, абстрактный (не допускающий создания экземпляров) класс (например, General), содержащий фундаментальный набор операций:
-- копирование объекта (копирование содержимого одного объекта в другой существующий, включая DeepCopy -- глубокое рекурсивное дублирование, подразумевающее также копирование содержимого объектов, вложенных в копируемый объект через его поля, атрибуты);
-- клонирование объекта (создание нового объекта и глубокое копирование в него исходного объекта);
-- сравнение объектов (включая глубокий вариант);
-- сериализация/десериализация (перевод в формат, подходящий для удобного ввода-вывода, как правило в строковый тип, и восстановление из него);
-- печать (наглядное представление содержимого объекта в текстовом формате);
-- проверка типа (является ли тип текущего объекта указанным типом);
-- получение реального типа объекта (непосредственного класса, экземпляром которого он был создан).

Когда мы добавляем в проект новый класс, не имеющий явного предка в текущей прикладной иерархии, он должен получить предком универсальный класс General (точнее, Any -- см. следующий абзац). Во многих языках программирования стандартная система классов уже предлагает подобный универсальный класс (например, Object в C# и Java), и любой прикладной класс в программе по умолчанию считается его потомком.

Однако рекомендуется оформить верхушку иерархии в виде двух классов. Самый верхний класс General содержит упомянутый набор операций, и полностью закрыт для изменений. Его прямой потомок (например, Any) ничего нового по умолчанию не вносит, но открыт для модификации, и все новые классы в проекте, не имеющие предка в прикладной иерархии, наследуются от Any. Архитектор проекта при необходимости вносит какие-то общие компоненты именно в класс Any.

Сформулируем попутно важный прикладной принцип повторного использования: каждый АТД/класс надо стараться передвигать как можно выше в иерархии наследования (повышать уровень абстракции), чтобы у него появлялось как можно большее количество классов-потомков, а сам он концентрировал в себе как можно больше общих черт.

Задание 9.

Постройте в вашем языке программирования базовую иерархию из двух классов General и Any. Унаследуйте General от универсального базового класса, если таковой имеется в языке или стандартной библиотеке/фреймворке, и реализуйте семь фундаментальных операций для него, используя для этого по возможности возможности стандартных библиотек. 

Решения задания 9

Постройте в вашем языке программирования базовую иерархию из двух классов General и Any.

Python

_T = TypeVar('_T')


class General(object):

    COPY_NIL = 0       # copy_to() not called yet
    COPY_OK = 1        # last copy_to() call completed successfully
    COPY_ATTR_ERR = 2  # other object have no attribute copied from this object

    def __get_status_fields(self) -> set:
        fields = set(attr for attr in dir(self)
                     if attr.endswith('status'))
        return fields

    def __init__(self, *args, **kwargs):
        self._copy_status = self.COPY_NIL

    # commands:
    @final
    def copy_to(self, other: _T) -> None:
        """Deep-copy of attributes of **self** to **other** with
        ignoring status-attributes."""
        status_fields = self.__get_status_fields()
        copy_attrs = filter(lambda a: a not in status_fields,
                            dir(self))

        if not all((hasattr(other, a) for a in copy_attrs)):
            self._copy_status = self.COPY_ATTR_ERR
            return

        for attr in copy_attrs:
            value = deepcopy(getattr(self, attr))
            setattr(other, attr, value)

        self._copy_status = self.COPY_OK

    # requests:
    @final
    def __eq__(self, other: _T) -> bool:
        return self.__dict__ == other.__dict__

    @final
    def __repr__(self) -> str:
        s = f'<"{self.__class__.__name__}" instance' \
            f' (id={id(self)})>'
        return s

    @final
    def clone(self) -> _T:
        clone = deepcopy(self)
        return clone

    @final
    def serialize(self) -> bytes:
        bs = pickle.dumps(self)
        return bs
    @final
    @classmethod
    def deserialize(cls, bs: bytes) -> _T:
        instance = pickle.loads(bs)
        return instance

    # method statuses requests:
    @final
    def get_copy_status(self) -> int:
        """Return status of last copy_to() call:
        one of the COPY_* constants."""
        return self._copy_status


class Any(General):
    """
    >>> a = Any()
    >>> isinstance(a, Any), isinstance(a, General)
    (True, True)
    >>> type(a) == Any, type(a) == General
    (True, False)
    >>> b = Any()
    >>> a.copy_to(b)
    >>> a.get_copy_status() == a.COPY_OK
    True
    >>> a == b, a is b  # different because of _copy_status
    (False, False)
    >>> bs = a.serialize()
    >>> deser_a = Any.deserialize(bs)
    >>> a == deser_a, a is deser_a
    (True, False)
    >>> a_clone = a.clone()
    >>> a == a_clone, a is a_clone
    (True, False)
    >>> class A(Any):
    ...     def __init__(self, nested_dict: dict, **kwargs):
    ...         super().__init__(nested_dict, **kwargs)
    ...         self.d = nested_dict
    >>> nested1 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: None}}}})
    >>> nested2 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: None}}}})
    >>> nested1 == nested2
    True
    >>> nested3 = A({'d': {(4,56,3): {'f': 518, 'sdd9': {45: ''}}}})
    >>> nested1 == nested3
    False
    """

Java

class General implements Serializable {
    public <T> void deepCopy(T target) throws Exception {
        try {
            target = getCopy();
        } catch (Exception e) {
            throw e;
        }
    }

    public <T> T deepClone() throws Exception {
        try {
            return getCopy();
        } catch (Exception e) {
            throw e;
        }
    }

    @Override
    public boolean equals(Object obj) {
        return super.equals(obj);
    }

    public <T> String serialize() throws JsonProcessingException {
        var mapper = new ObjectMapper();
        return mapper.writeValueAsString((T)this);
    }

    public static <T> T deserialize(
                        String json, 
                        Class<T> clazz) throws JsonProcessingException {
        var mapper = new ObjectMapper();
        return mapper.readValue(json, clazz);
    }

    @Override
    public String toString() {
        return super.toString();
    }

    @JsonIgnore
    public final Class<?> getType() {
        return this.getClass();
    }

    private <T> T getCopy() throws Exception  {
        try {
            var byteArrayOutputStream = new ByteArrayOutputStream();
            var objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject((T)this);
            var bais = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            var objectInputStream = new ObjectInputStream(bais);

            return (T) objectInputStream.readObject();
        }
        catch (Exception e) {
            throw e;
        }
    }
}

/*public*/ class Any extends General {

}


13. Принцип Открыт/Закрыт применительно к иерархии классов

Если позволяет конкретный язык программирования, для ряда классов желательно полностью запретить возможность переопределения ряда их методов (например если так требует спецификация и мы хотим, чтобы реализация гарантированно с ней совпадала). В таком случае, во-первых, мы формально поддерживаем принцип открытости-закрытости, и во-вторых, всегда нежелательно переопределять универсальные операции, входящие в General.

В крайнем случае можно создать например две версии операций копирования -- одну закрытую, и другую открытую для переопределений (возможно, как абстрактный метод, или по умолчанию вызывающую закрытую версию). Только при создании таких открытых версий желательно добавлять подобные открытые версии и для схожих по смыслу операций (например, разрешая переопределять копирование, надо создать также и две операции клонирования) -- из соображений единой семантики. Однако, по умолчанию такие пары методов должны быть закрыты, если открытость для них по спецификации не требуется.

Задание 10.

Выясните, имеется ли в вашем языке программирования возможность запрета переопределения методов в потомках, и приведите пример кода. 

Решения задания 10

Запрещаем переопределение методов в потомках.

Python

"""
Возможность запрета и для методов, и для классов, 
появилась в Python 3.8 -- 
с помощью декоратора @final
"""

class Base:
    @final
    def do_not_override_this(self) -> None: ...

class A(Base):
    # error: Cannot override final attribute "do_not_override_this"
    # (previously declared in base class "Base")
    def do_not_override_this(self) -> None: ...


@final
class FinalBase: ...

class B(FinalBase): ...
# error: Cannot inherit from final class "FinalBase"

Java

Для этого используется ключевое слово final.

public final Class getType() 
{ return this.getClass(); } 


14. Замыкание иерархии

Если система классов конкретного языка допускает множественное наследование, проектную иерархию желательно замкнуть также и снизу: добавить пустой закрытый класс None, потомок всех классов. Все классы-листья (не имеющие потомков) становятся прямыми предками None, и в итоге вся иерархия получается замкнутой снизу в форме математической решётки.

В таком случае класс None начинает играть роль пустой ссылки void, которая эмулируется в некоторых языках значением null/none. Добавлением класса None, который выступает аналогом отсутствия значения, мы остаёмся полностью в рамках чистой объектной прикладной системы типов нашего проекта. Так как None потомок всех классов, можно без ограничений использовать значение Void типа None в качестве значения переменной любого типа (класса), добавив его в проект как стандартный глобальный объект.

Однако далеко не все современные языки поддерживают множественное наследование, поэтому, хотя подход с использованием null заслуженно считается порочным, так как сильно ослабляет всю систему типов, вводя некоторую непонятную сущность полностью за пределами этой системы, к использованию null всё же приходится прибегать.

К сожалению, это серьёзная уязвимость модели ООП, потому что даже наличие в проекте значения Void никак не страхует от некорректной последовательности команд:

x = Void;
...
x.foo();

что приведёт к исключительной ситуации. В частных случаях можно добавлять проверки вида

if x == Void then ...

Однако общим решением будет только контроль исключительных ситуаций. Ответственность за правильную работу со значениями Void/null в ООП полностью возлагается на программиста, система статической проверки типов тут никак не поможет.

Задание 11.

Если используемый вами язык программирования допускает множественное наследование, постройте небольшую иерархию, используя уже готовые General и Any, и замкните её снизу классом None. Приведите пример полиморфного использования Void. 

 Python

В Python нету проверок типов, поэтому можно создать любой класс без предков/потомков, не входящий в нашу систему типов, унаследованную от General.

Java

class General implements Serializable {
   ...
}

class Any extends General { }

...

final class None extends Any /*A, B, ....*/ { }

//

class Test {
    public static Any getSome() {
        return new None();
    }

    public static void setSome(Any any) {
        if (any instanceof None) {
            System.out.println("wrong value!!!");
        }
    }
}


