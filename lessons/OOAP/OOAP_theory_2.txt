
Наследование, композиция и полиморфизм

1. Что такое наследование, композиция и полиморфизм

Наследование -- это прежде всего про повторное использование кода. Это гибкий, мощный и компактный механизм снижения проектной сложности.

Наследование даёт возможность использования уже готовых компонентов, предлагая уточнение (иногда расширение, иногда ограничение) класса-предка и спецификации АТД.

Наследование также подразумевает возможность переопределения реализации метода класса-предка, типов аргументов, типа (результата) работы метода.

Наследование -- это одно из двух фундаментальных видов отношений между классами в ООП.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

Композиция -- это отношение "содержит" (has-a), когда один объект содержит объект другого класса (как поле соответствующего типа).

Наследование может быть единичным и множественным (когда класс наследует возможности сразу нескольких классов).

Наследование тесно связано с полиморфизмом. В общем случае под полиморфизмом понимается способность различных сущностей в программе менять свою "форму" -- становиться объектами разных типов по цепочке иерархии наследования.

Задание 1.
Напишите небольшой пример кода с комментариями, где применяются наследование, композиция и полиморфизм. 


2. Введение

В первом цикле, посвящённом проектированию классов, мы видели, что даже простой подход к правильному проектированию классов на основе АТД как автономных сущностей предоставляет отличные возможности для формирования библиотек классов под конкретную предметную область, которые удобно использовать и модифицировать. Интерфейсы полностью отделены от реализаций; универсальный подход АТД (набор операций, отделённых от состояний) обеспечивает высокую гибкость; предусловия и постусловия позволяют достаточно строго контролировать корректность семантики классов и их целостность. В программировании вообще популярен и хорошо работает принцип Keep it simple, stupid (KISS), предполагающий, что большинство систем работают тем лучше, чем они проще.

Однако когда мы задумываемся о расширении нашего набора автономных классов, оказывается, что для этого требуются более мощные механизмы. В частности, наследование как концепция повторного использования кода позволила нам создать иерархию классов, где никакие методы практически не дублировались, а её структура довольно легко расширялась новыми идеологически схожими классами (различные виды списков). Это соответствие принципу You aren't gonna need it (YAGNI) -- избегание любой избыточной функциональности.

Формальный подход к наследованию подразумевает три принципиально разные возможности:
-- расширение класса-родителя (наследник задаёт более общий случай родителя);
-- специализация класса-родителя (наследник задаёт более специализированный случай родителя);
-- комбинация нескольких родительских классов.

Далеко не все языки поддерживают все эти виды отношений, мы рассмотрим универсальную, не зависящую от языков, концепцию наследования, из которой на практике вы можете применять наиболее подходящие вам приёмы.

Задание 2.
Напишите небольшой пример кода с комментариями, где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя. 

Решения задания 2

Python

class Bicycle: // велосипед
    def __init__(self, wheel_count: int = 2):
        self.wheels = [Wheel() for _ in range(wheel_count)]

class Engine: // электромотор
    def __init__(self, power: float):
        self.power = power
        print('engine power is', power)

# Специализация: шоссейный велосипед -- подтип велосипеда
# Расширение: электровелосипед, дополнен мотором
class ElectricRoadBicycle(Bicycle):
    def __init__(self, power: float):
        super().__init__()
        self.engine = Engine(power)

Java

public class Human{
    // -- voice()
    // -- walk()
    // -- run()
}

public class Worker extends Human{ 
    // специализация класса-родителя, 
    // т.к. рабочий - более частный случай,
    // т.к. все работники - люди, но не все люди - работники
    // -- work()
}

public class Car{
    // -- drive()
    // -- park()
    // -- startEngine()
}

public class AutonomousCar extends Car{ 
    // расширение класса-родителя, 
    // т.к. все самоуправляемые машины
    // являются машинами, но не все машины - самоуправляемы

    // -- autoDrive()
    // -- autoPark()
}



3. Класс как модуль и класс как тип

Класс -- это, как говорилось на первом курсе, и модуль (синтаксическая единица проекта) и тип данных (семантическая единица проекта). Наследование в каждом из этих двух случаев играет разные роли.

1) Класс как модуль.

Класс как модуль означает, что класс выступает базовой синтаксической единицей, и в виде отдельного файла, и в виде автономно компилируемой сущности. Наследование в таком случае выступает прежде всего как механизм повторного использования кода. Когда мы думаем в этой парадигме, то сосредотачиваемся в первую очередь на том, как эффективнее всего избавляться от деталей, как использовать наиболее общие подходы. В программировании это широко известный принцип Don’t repeat yourself (DRY).

Создавая новый модуль, мы опираемся на уже существующий модуль, из которого заимствуем существенную часть базовой функциональности, и дополняем его новой. В таком случае класс рассматривается как поставщик определённых служб, некоторого интерфейса. Модуль, наследующий родительский модуль, расширяет его дополнительными службами.

Реализуя в модуле (классе) "Двухсвязный список" метод left(), отсутствующий в родительском модуле "Универсальный список", мы создаём множество сущностей, к которым применим набор операции универсального списка, и дополнительно набор операций двухсвязного списка. То есть множество наборов операций, применимых к универсальному списку, будет подмножеством множества операций, применимых к двусвязному списку.

В настоящем курсе этот подход через расширение возможностей модуля-предка предлагается считать единственным способом добавления новых модулей в проект.

Когда проект большой, взаимосвязи между модулями неочевидны, поэтому каждый модуль надо стремиться делать легко расширяемым, и при этом максимально автономным -- все его связи с другими модулями должны быть строго (формально) ограничены. Модуль по сути предоставляет некоторый абстрактный интерфейс -- когда мы используем сам модуль в целом, а не запрятанный в нём код.

Задание 3.
Расскажите, как в выбранном вами языке программирования поддерживается концепция "класс как модуль".
Пока мы говорим именно про "классы" в смысле модули -- пространство имен, сборки, пакеты, библиотеки -- все что содержит готовый код и что можно импортировать в свою программу. 


Наследование, композиция и полиморфизм

Решения задания 3

Python

В Python можно классы хранить в модулях, а модули организовывать в пакеты в виде иерархии каталогов.
Можно импортировать, соответственно, класс, модуль и пакет, и работать с ними как с отдельными сущностями.
При этом модуль имеет "конструктор" -- код, который однократно запускается при его первом импорте.

Java

Концепция "класс как модуль" в Java поддерживается например через иерархию каталогов.
Корневой узел такой иерархии называется пакетом (по сути модулем).
Для подключения пакета используется синтаксис
package *name1.name2....*
для импорта
import *name1.name2....* 


4. Реализация расширяемости модулей

Одна из классических проблем расширяемости -- это форма её реализации. Можно либо наследовать функциональность, создавая новые модули, либо настраивать её с помощью различных конфигурационных схем (включая, например, скриптовые языки).

Тут надо отметить некоторую ошибочность классического понятия паттернов проектирования, которые обычно воспринимаются как просто полезные механические конструкции для решения конкретных задач. Однако их реальная ценность прежде всего в возможности повторного использования неких универсальных структур данных, которые мы наследуем и реализовываем, дополнительно расширяем применительно к своему проекту. Это, в частности, упоминавшиеся на прошлом курсе классы поведения, в которых открытый интерфейс описывается с помощью низкоуровневых методов, как правило, отложенных, что обеспечивает высокую гибкость. Если паттерн достаточно крупный, может получиться целый фреймворк, набор модулей, хорошо расширяемый каркас. 


5. Основополагающий принцип открытости-закрытости модуля

Это первый из пяти фундаментальных принципов объектно-ориентированного программирования и проектирования, известный как The Open Closed Principle (OCP). Сами принципы в нынешней форме были собраны в начале 2000-х годов Робертом Мартином ( автором легендарных книг "Чистый код", "Чистая архитектура", "Идеальный программист" и др.) и получили общее название SOLID (от первых букв названий принципов).

Модуль считается открытым, если его можно продолжать расширять.

Модуль считается закрытым, когда он выложен в продакшен, и им можно только пользоваться.

На практике мы получаем парадоксальное требование, что модуль должен быть закрытым, чтобы он поступил в эксплуатацию, но он должен быть открытым для дальнейшей модификации в процессе развития проекта. Представим, что у нас имеется закрытый модуль, и потребовалось что-то расширить в его функциональности, так как никогда не будет гарантии, что мы заранее учли все проектные особенности. Ужасный способ сделать это -- создать полную копию закрытого модуля, и что-то в нём начать менять. Правильно решается эта проблема именно наследованием.

Задание 4.
Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми. 

Решения задания 4

Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Фактически все базовые классы любой стандартной библиотеки не могут быть изменены, чтобы не произошли непредвиденные изменения в системе, поэтому они "закрытые". Но от них можно наследовать конкретные прикладные "открытые" классы, доступные для модификации программисту, которые расширяют или специализируют базовый функционал родительских "закрытых" классов.
Часто такой подход применяется при создании графического интерфейса: например, если требуется кнопка с оригинальным поведением или изображением, она наследуется от стандартного класса Button, после чего в ней переопределяется, например, метод отрисовки.

Хорошей причиной для открытости модуля будет потенциальная польза от его расширения.
Например, сделав модуль "Анализатор логов" открытым, мы даем возможность клиентам самим доопределять изначальнай алгоритм, добавляя нужное им поведение.

Если модуль делает что-то конкретное, без потенциального разнообразия, то это кандидат на закрытость. Например, модуль занимающийся отправкой документов внешнему провайдеру документооборота нужно делать закрытым, так как он делает вполне определенное действие, и расширять его стандартное поведение нет необходимости. 


6. Принципы повторного использования модуля

Полноценный механизм добавления в проект нового модуля, подразумевающего повторное использование кода, должен отвечать всем пяти нижеприведённым принципам.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля;

4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра;

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

На практике выдерживать все эти правила не удаётся. Например, если попробовать использовать механизм стандартных библиотек для реализации модулей, то окажется, что он подходит только для достаточно простых проектов, когда имеются чёткие разграничения между спецификациями, отсутствуют смысловые взаимосвязи, и все функции различаются и синтаксически, и семантически. В лучшем случае удастся выполнить требования принципов 2, 3 и 5.

В некоторых языках поддерживаются пакеты со своими оригинальными именами, раздельной компиляцией, публичным интерфейсом и скрытой реализацией. Пакеты в таком случае выступают как абстрактные модули без реализации, однако тоже они не отвечают, в частности, принципу 4 -- конкретную реализацию придётся выбирать самому программисту.

Возможность переопределения имён в модулях (и в частности, перегрузки операторов для разных типов аргументов) частично хороша, но в целом плохо читабельна, не поддерживает обобщённые типы, и главное, если у некоторых функций имеются различия в семантике, то эти различия должны наглядно отражаться и на уровне синтаксиса, что перегрузка не позволяет по своей сути.

В ООП различаются термины "переопределение" (overridde) и "перегрузка" (overload). Переопределение -- это перезапись логики родительского метода с точно такой же сигнатурой в классе-потомке. Перегрузка -- когда в нескольких реализациях метода внутри одного класса его имя одно и то же, а список аргументов различается.
Хотя в разных языках эти схемы могут и различаться.

Если же мы попробуем использовать шаблоны модулей, параметризованные типами (когда одна и та же реализация применяется к различным видам объектов), то получится фактически, что у нас имеется параметризованный типами открытый универсальный модуль, но напрямую не применимый (потому что это шаблон), и имеется условный набор его конкретных реализаций, закрытых для изменений (так как поддержка параметризации встроена в язык). Это нарушает ключевой принцип открытости-закрытости -- непонятно, как расширять такие шаблоны, не меняя уже использующий их код.

Задание 5.
Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?
(напомню, что пока речь идёт именно о модулях как базовой синтаксической единице, а не о классах) 


