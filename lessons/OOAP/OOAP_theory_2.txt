
Наследование, композиция и полиморфизм

1. Что такое наследование, композиция и полиморфизм

Наследование -- это прежде всего про повторное использование кода. Это гибкий, мощный и компактный механизм снижения проектной сложности.

Наследование даёт возможность использования уже готовых компонентов, предлагая уточнение (иногда расширение, иногда ограничение) класса-предка и спецификации АТД.

Наследование также подразумевает возможность переопределения реализации метода класса-предка, типов аргументов, типа (результата) работы метода.

Наследование -- это одно из двух фундаментальных видов отношений между классами в ООП.

Наследование -- это отношение "является" (is-a), когда один класс является потомком другого класса.

Композиция -- это отношение "содержит" (has-a), когда один объект содержит объект другого класса (как поле соответствующего типа).

Наследование может быть единичным и множественным (когда класс наследует возможности сразу нескольких классов).

Наследование тесно связано с полиморфизмом. В общем случае под полиморфизмом понимается способность различных сущностей в программе менять свою "форму" -- становиться объектами разных типов по цепочке иерархии наследования.

Задание 1.
Напишите небольшой пример кода с комментариями, где применяются наследование, композиция и полиморфизм. 


2. Введение

В первом цикле, посвящённом проектированию классов, мы видели, что даже простой подход к правильному проектированию классов на основе АТД как автономных сущностей предоставляет отличные возможности для формирования библиотек классов под конкретную предметную область, которые удобно использовать и модифицировать. Интерфейсы полностью отделены от реализаций; универсальный подход АТД (набор операций, отделённых от состояний) обеспечивает высокую гибкость; предусловия и постусловия позволяют достаточно строго контролировать корректность семантики классов и их целостность. В программировании вообще популярен и хорошо работает принцип Keep it simple, stupid (KISS), предполагающий, что большинство систем работают тем лучше, чем они проще.

Однако когда мы задумываемся о расширении нашего набора автономных классов, оказывается, что для этого требуются более мощные механизмы. В частности, наследование как концепция повторного использования кода позволила нам создать иерархию классов, где никакие методы практически не дублировались, а её структура довольно легко расширялась новыми идеологически схожими классами (различные виды списков). Это соответствие принципу You aren't gonna need it (YAGNI) -- избегание любой избыточной функциональности.

Формальный подход к наследованию подразумевает три принципиально разные возможности:
-- расширение класса-родителя (наследник задаёт более общий случай родителя);
-- специализация класса-родителя (наследник задаёт более специализированный случай родителя);
-- комбинация нескольких родительских классов.

Далеко не все языки поддерживают все эти виды отношений, мы рассмотрим универсальную, не зависящую от языков, концепцию наследования, из которой на практике вы можете применять наиболее подходящие вам приёмы.

Задание 2.
Напишите небольшой пример кода с комментариями, где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя. 

Решения задания 2

Python

class Bicycle: // велосипед
    def __init__(self, wheel_count: int = 2):
        self.wheels = [Wheel() for _ in range(wheel_count)]

class Engine: // электромотор
    def __init__(self, power: float):
        self.power = power
        print('engine power is', power)

# Специализация: шоссейный велосипед -- подтип велосипеда
# Расширение: электровелосипед, дополнен мотором
class ElectricRoadBicycle(Bicycle):
    def __init__(self, power: float):
        super().__init__()
        self.engine = Engine(power)

Java

public class Human{
    // -- voice()
    // -- walk()
    // -- run()
}

public class Worker extends Human{ 
    // специализация класса-родителя, 
    // т.к. рабочий - более частный случай,
    // т.к. все работники - люди, но не все люди - работники
    // -- work()
}

public class Car{
    // -- drive()
    // -- park()
    // -- startEngine()
}

public class AutonomousCar extends Car{ 
    // расширение класса-родителя, 
    // т.к. все самоуправляемые машины
    // являются машинами, но не все машины - самоуправляемы

    // -- autoDrive()
    // -- autoPark()
}



3. Класс как модуль и класс как тип

Класс -- это, как говорилось на первом курсе, и модуль (синтаксическая единица проекта) и тип данных (семантическая единица проекта). Наследование в каждом из этих двух случаев играет разные роли.

1) Класс как модуль.

Класс как модуль означает, что класс выступает базовой синтаксической единицей, и в виде отдельного файла, и в виде автономно компилируемой сущности. Наследование в таком случае выступает прежде всего как механизм повторного использования кода. Когда мы думаем в этой парадигме, то сосредотачиваемся в первую очередь на том, как эффективнее всего избавляться от деталей, как использовать наиболее общие подходы. В программировании это широко известный принцип Don’t repeat yourself (DRY).

Создавая новый модуль, мы опираемся на уже существующий модуль, из которого заимствуем существенную часть базовой функциональности, и дополняем его новой. В таком случае класс рассматривается как поставщик определённых служб, некоторого интерфейса. Модуль, наследующий родительский модуль, расширяет его дополнительными службами.

Реализуя в модуле (классе) "Двухсвязный список" метод left(), отсутствующий в родительском модуле "Универсальный список", мы создаём множество сущностей, к которым применим набор операции универсального списка, и дополнительно набор операций двухсвязного списка. То есть множество наборов операций, применимых к универсальному списку, будет подмножеством множества операций, применимых к двусвязному списку.

В настоящем курсе этот подход через расширение возможностей модуля-предка предлагается считать единственным способом добавления новых модулей в проект.

Когда проект большой, взаимосвязи между модулями неочевидны, поэтому каждый модуль надо стремиться делать легко расширяемым, и при этом максимально автономным -- все его связи с другими модулями должны быть строго (формально) ограничены. Модуль по сути предоставляет некоторый абстрактный интерфейс -- когда мы используем сам модуль в целом, а не запрятанный в нём код.

Задание 3.
Расскажите, как в выбранном вами языке программирования поддерживается концепция "класс как модуль".
Пока мы говорим именно про "классы" в смысле модули -- пространство имен, сборки, пакеты, библиотеки -- все что содержит готовый код и что можно импортировать в свою программу. 


Наследование, композиция и полиморфизм

Решения задания 3

Python

В Python можно классы хранить в модулях, а модули организовывать в пакеты в виде иерархии каталогов.
Можно импортировать, соответственно, класс, модуль и пакет, и работать с ними как с отдельными сущностями.
При этом модуль имеет "конструктор" -- код, который однократно запускается при его первом импорте.

Java

Концепция "класс как модуль" в Java поддерживается например через иерархию каталогов.
Корневой узел такой иерархии называется пакетом (по сути модулем).
Для подключения пакета используется синтаксис
package *name1.name2....*
для импорта
import *name1.name2....* 


4. Реализация расширяемости модулей

Одна из классических проблем расширяемости -- это форма её реализации. Можно либо наследовать функциональность, создавая новые модули, либо настраивать её с помощью различных конфигурационных схем (включая, например, скриптовые языки).

Тут надо отметить некоторую ошибочность классического понятия паттернов проектирования, которые обычно воспринимаются как просто полезные механические конструкции для решения конкретных задач. Однако их реальная ценность прежде всего в возможности повторного использования неких универсальных структур данных, которые мы наследуем и реализовываем, дополнительно расширяем применительно к своему проекту. Это, в частности, упоминавшиеся на прошлом курсе классы поведения, в которых открытый интерфейс описывается с помощью низкоуровневых методов, как правило, отложенных, что обеспечивает высокую гибкость. Если паттерн достаточно крупный, может получиться целый фреймворк, набор модулей, хорошо расширяемый каркас. 


5. Основополагающий принцип открытости-закрытости модуля

Это первый из пяти фундаментальных принципов объектно-ориентированного программирования и проектирования, известный как The Open Closed Principle (OCP). Сами принципы в нынешней форме были собраны в начале 2000-х годов Робертом Мартином ( автором легендарных книг "Чистый код", "Чистая архитектура", "Идеальный программист" и др.) и получили общее название SOLID (от первых букв названий принципов).

Модуль считается открытым, если его можно продолжать расширять.

Модуль считается закрытым, когда он выложен в продакшен, и им можно только пользоваться.

На практике мы получаем парадоксальное требование, что модуль должен быть закрытым, чтобы он поступил в эксплуатацию, но он должен быть открытым для дальнейшей модификации в процессе развития проекта. Представим, что у нас имеется закрытый модуль, и потребовалось что-то расширить в его функциональности, так как никогда не будет гарантии, что мы заранее учли все проектные особенности. Ужасный способ сделать это -- создать полную копию закрытого модуля, и что-то в нём начать менять. Правильно решается эта проблема именно наследованием.

Задание 4.
Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми. 

Решения задания 4

Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Фактически все базовые классы любой стандартной библиотеки не могут быть изменены, чтобы не произошли непредвиденные изменения в системе, поэтому они "закрытые". Но от них можно наследовать конкретные прикладные "открытые" классы, доступные для модификации программисту, которые расширяют или специализируют базовый функционал родительских "закрытых" классов.
Часто такой подход применяется при создании графического интерфейса: например, если требуется кнопка с оригинальным поведением или изображением, она наследуется от стандартного класса Button, после чего в ней переопределяется, например, метод отрисовки.

Хорошей причиной для открытости модуля будет потенциальная польза от его расширения.
Например, сделав модуль "Анализатор логов" открытым, мы даем возможность клиентам самим доопределять изначальнай алгоритм, добавляя нужное им поведение.

Если модуль делает что-то конкретное, без потенциального разнообразия, то это кандидат на закрытость. Например, модуль занимающийся отправкой документов внешнему провайдеру документооборота нужно делать закрытым, так как он делает вполне определенное действие, и расширять его стандартное поведение нет необходимости. 


6. Принципы повторного использования модуля

Полноценный механизм добавления в проект нового модуля, подразумевающего повторное использование кода, должен отвечать всем пяти нижеприведённым принципам.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля;

4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра;

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

На практике выдерживать все эти правила не удаётся. Например, если попробовать использовать механизм стандартных библиотек для реализации модулей, то окажется, что он подходит только для достаточно простых проектов, когда имеются чёткие разграничения между спецификациями, отсутствуют смысловые взаимосвязи, и все функции различаются и синтаксически, и семантически. В лучшем случае удастся выполнить требования принципов 2, 3 и 5.

В некоторых языках поддерживаются пакеты со своими оригинальными именами, раздельной компиляцией, публичным интерфейсом и скрытой реализацией. Пакеты в таком случае выступают как абстрактные модули без реализации, однако тоже они не отвечают, в частности, принципу 4 -- конкретную реализацию придётся выбирать самому программисту.

Возможность переопределения имён в модулях (и в частности, перегрузки операторов для разных типов аргументов) частично хороша, но в целом плохо читабельна, не поддерживает обобщённые типы, и главное, если у некоторых функций имеются различия в семантике, то эти различия должны наглядно отражаться и на уровне синтаксиса, что перегрузка не позволяет по своей сути.

В ООП различаются термины "переопределение" (overridde) и "перегрузка" (overload). Переопределение -- это перезапись логики родительского метода с точно такой же сигнатурой в классе-потомке. Перегрузка -- когда в нескольких реализациях метода внутри одного класса его имя одно и то же, а список аргументов различается.
Хотя в разных языках эти схемы могут и различаться.

Если же мы попробуем использовать шаблоны модулей, параметризованные типами (когда одна и та же реализация применяется к различным видам объектов), то получится фактически, что у нас имеется параметризованный типами открытый универсальный модуль, но напрямую не применимый (потому что это шаблон), и имеется условный набор его конкретных реализаций, закрытых для изменений (так как поддержка параметризации встроена в язык). Это нарушает ключевой принцип открытости-закрытости -- непонятно, как расширять такие шаблоны, не меняя уже использующий их код.

Задание 5.
Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?
(напомню, что пока речь идёт именно о модулях как базовой синтаксической единице, а не о классах) 

Решения задания 5

Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования?

Python и Java

1) В обоих языках нет возможности параметрировать модуль типом.

2) Поддерживается создание модуля, объединяющего несколько активно обращающихся друг к другу функций.

3) Поддерживается возможность объединения модулей в пакеты/сборки.

4) На уровне модулей в обоих языках нет "автоматического" полиморфизма. Можно вручную импортировать только нужные функции из модуля "родителя" и переопределить оставшиеся.

5) С помощью композиции можно интегрировать несколько модулей с небольшими отличиями в поведении в один. При этом модуль имеет "конструктор" (код, который однократно запускается при его первом импорте). 


7. Разбираемся с модульным противоречием

Выход из противоречивой модели модуля находится в парадигме ООП. Классические попытки совместить все пять принципов с помощью модулей, компонентов, пакетов, терпят неудачу.

Тема декомпозиции проекта на небольшие автономные сущности изучается в программной инженерии не менее полувека. Идея модулей строится вокруг набора функций, вокруг парадигмы так называемого структурного программирования, а ООП -- вокруг объекта. Это вечные попытки как-то более-менее эффективно разрешить конфликт между данными и функциями/методами их обработки. Подробно тему декомпозиции, построения модели предметной области, проектирования качественной иерархии классов, изучаем на следующем курсе. Пока мы приближаемся к идее, что класс (с использованием наследования и полиморфизма) представляется наиболее оптимальной формой модуля. Только надо всегда помнить, когда мы выполняем декомпозицию, то выделяем классы таким образом, что они представляют собой не просто наборы функций, а прежде всего некоторые структуры данных, которые хоть и описываются только операциями, однако все эти операции имеют семантическое отношение именно к своей структуре данных.

Основа объектно-ориентированного подхода -- это приоритет типов данных над описывающими их операциями. То есть в списке методов класса, который всегда задаёт некоторую структуру данных, не должно быть методов, не имеющих прямого отношения к этой структуре данных.

Задание 6.
Существуют ли ситуации, когда связи между модулями должны делаться публичными?
Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам? 

Решения задания 6

Существуют ли ситуации, когда связи между модулями должны делаться публичными?

В общем случае это нарушение инкапсуляции и принципа единственной ответственности SRP (The Single Responsibility Principle, изучаем далее).
На практике допускаются технические исключения, когда проще и выразительнее сделать общедоступными некоторые связи модуля, которые используются во множестве других модулей. Например, это может быть модуль, содержащий инфраструктурный код (логирование, метрики, ...).
И надо также учитывать, что наличие множества неявных связей (зависимостей) приводит к трудноконтролируемому проекту. Большое количество таких связей -- признак плохого проектирования.

Какие метрики вы бы предложили для количественной оценки принципов организации модулей?

Например, количество семантических единиц в программе, так называемых "сущностей". Хотя слепо минимизировать их тоже будет некорректным.

Формально, между модулями нужно выдерживать как можно меньшую связность, т.е. делать модули независимыми. Поэтому для количественной оценки можно использовать количество связей, исходящих из модуля (модули, от которых зависит данный модуль), и количество связей, входящих в модуль (модули, зависящие от этого модуля).

Соответственно, надо стремиться делать максимально автономные модули (минимизируя исходящие связи). Если у автономного модуля всего одна входящая стрелка, то, возможно, он используется всего один раз, и разбиение на модули было некорректным. Также будет плохим случай, когда связей слишком много, например "все зависят от всех", или когда задействуется слишком много контекста, а используется из него далеко не всё.

Если вы разрабатывали программы, в которых было хотя бы 3-5 классов,как бы вы оценили их модульность по этим метрикам?

Пример 1.
Есть абстрактный класс Pizza и много-много классов, реализующих конкретные виды пицц.
Есть абстрактный класс Coffee и также много-много классов, реализующих конкретные виды кофе.
Есть абстрактный класс Restaurant и классы, реализующие конкретные рестораны, где продается пицца и кофе.
Добавим абстрактный класс Courier и классы, реализующие конкретные типы доставки.
Получаются три семантические единицы: еда, заведение, доставка, которые можно представить в виде разных модулей. Это вполне хороший показатель для проекта, где классов могут насчитываться сотни и тысячи.

Пример 2.
Из 6 классов один был "закрытым". Он был очень перегруженным как публичными, так и условно скрытыми методами. Они в остальных 5 дочерних классах переопределялись (override) в разных комбинациях. Принципы открытости-закрытости и повторного использования нарушались повсеместно, что быстро похоронило программу. 


8. Класс как тип

Во взгляде на класс как на тип мы пытаемся совместить принцип повторного использования кода с расширяемостью, которой не удалось полноценно достичь с помощью модулей. И ключевым в таком подходе к наследованию становится полиморфизм и динамическое связывание.

Посмотрим на отношение класс как тип относительно связываемых значений (объектов) как на отношение включения множеств. Например, множество всех объектов "Двухсвязный список" во время работы программы является подмножеством множества всех объектов "Универсальный список". Причём эти два типа не обязательно наследуются напрямую, между ними может быть цепочка промежуточных типов.

Если же посмотреть на это отношение относительно операций над соответствующими типами (по сути, как на отношение между АТД), то отношение "каждый двухсвязный список является универсальным списком" означает, что любая операция, применимая к родительскому универсальному списку, применима также и к дочернему двухсвязному списку (с учётом того, что эти операции могут быть переопределены в двухсвязном списке), но не наоборот.

То есть в случае "класс как тип" мы получаем не расширение родительского класса, а специализацию, что прямо противоположно подходу "класс как модуль".

В результате на практике появляются подобные частые ошибки: "двухсвязный список my_list_007 в моём коде является универсальным списком". Тут используется отношение между значением и категорией, что неверно. Отношение "является" всегда выражает отношение только между категориями (типами, классами). Например, всякий АТД "Двухсвязный список" является АТД "Универсальный список".

Какой из этих подходов более правильный для понимания принципа наследования? Как может быть разрешён парадокс расширения-специализации? Фактически получается, что чем больше у нас различных типов в цепочке наследования, тем к меньшему количеству объектов они могут применяться, так как мы движемся вниз по иерархии в направлении специализации.

Поэтому в частности, некорректно применение массово распространённого термина "подкласс" и в смысле подмножества, и в смысле наследования. Правильно использовать только такие термины: наследник и родитель, потомок и предок, прямой/собственный потомок и предок. 


9. Динамическое связывание

Наиболее глубокая и при этом достаточно абстрактная (универсальная) форма реализации отношения наследования (в общем случае повторного использования) -- это динамическое связывание. Программисту не требуется постоянно уточнять, метод какого конкретно типа (класса) должен быть вызван, он будет определён автоматически. Это очень важная возможность, которую мы никак не сможем получить, оставаясь в парадигме модулей -- ни универсализм, ни перегрузка операторов, и ничто иное.

Чем плохо статическое связывание? Если можно заранее, анализируя исходные тексты, автоматически определить, какой конкретно тип будет у полиморфного объекта в некотором случае, то эту работу должен выполнить компилятор, и только с целью оптимизации вызовов. Если же программист в такое связывание вкладывает другой смысл, нежели подразумевает компилятор, то это надо считать ошибкой. Так, если программист может выбирать политику статического связывания сам, то легко нарушить принцип открытости-закрытости: может потребоваться модификация класса, закрытого для изменений, которую заранее нельзя было предвидеть. Это можно решить переопределением нужного метода в классе-наследнике, однако если политика статического связывания возложена на программиста, то в таком случае вполне возможна ситуация, когда в предке не задана виртуальность соответствующего изменяемого метода, что потребует внесения правки в вышестоящий класс (уточнение сигнатуры метода), который уже закрыт для изменений. В разных языках эта проблема может проявляться по разному, например в Java все функции по умолчанию считаются виртуальными, а в С++ наоборот, невиртуальными.

В общем случае наследование позволяет создавать новые классы, которые и расширяют, и специализируют уже существующие классы. Это достигается с помощью трёх механизмов: переопределения в классе реализации методов его прямого предка, использования полиморфных объектов и динамического связывания.

При этом правильно спроектированный класс с точки зрения пользователя-программиста в идеале вообще не должен демонстрировать схему своего наследования. Наследование -- это внутренний механизм, и если полиморфизм в отношении класса не подразумевается, то и всю логику наследования для этого класса по возможности желательно скрыть. Такой класс, в отношении которого с точки зрения его пользователя наследование не применяется, называется плоским.

Во всех остальных случаях наследование требуется ровно в тех границах, которые обеспечивают необходимую логику полиморфизма и динамического связывания в проекте.

Задание 7.
Приведите пример кода с комментариями, где применяется динамическое связывание. 


