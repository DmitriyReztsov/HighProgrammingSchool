
Object Calisthenics
Девять простых но мощных формальных приёмов ООП,
существенно улучшающих и код, и его структуру,
и семантику, и проектный дизайн

Вступление, изучите предварительно пожалуйста! https://vk.com/wall-152484379_3403

Идея этой методики в том, что она предлагает набор из девяти простых правил, которые через простые формальные приёмы организации синтаксиса фактически принуждают разработчика к соблюдению важных семантических принципов (например, снижению цикломатической сложности). Кто проходил мой начальный курс с нуля, хорошо знает, сколько внимания и рефлексии мы уделяли подобным моментам с самых первых шагов. 


1. Пишите функции/методы так,
чтобы внутри них было не более одного отступа.

Семантически это означает: не допускайте никаких дополнительных вложений в циклы и условия кроме их непосредственных "тел".

В вашем коде не должно быть вложенных циклов и вложенных условий.

Главная идея: снижение цикломатической сложности и, соответственно, упрощение сопровождения кода. Кроме того, сильно возрастает выразительность и понимаемость кода и повторность использования методов. 

 Вы когда-нибудь смотрели на большую и плохо работающую легаси-функцию, не представляя не то что "с чего начать", а вообще, "как бы к ней вообще подступиться"? Большим функциям и методам сильно не хватает внутренней связности.

Про правильный размер функций/методов будет также пункт 7. В частности, есть такая чрезмерно формальная синтаксическая рекомендация -- ограничивать длину каждого метода пятью строками, (при этом у вас и не получится уместить вложенные инструкции управления в такой микро-объём), но если класс будет завален 500 короткими методами, такой переход будет пугающим.

Вместо этого постарайтесь сделать так, чтобы каждый метод выполнял ровно одно действие, решал ровно одну задачу. В идеале, включайте одну управляющую структуру или один условный блок на метод. В принципе, вполне допустима и линейная последовательность таких одноуровневых инструкций, эту фундаментиальную схему мы проходим на курсе по декларативной парадигме программирования.

Если у вас появляются вложенные управляющие структуры, это значит, что вы пытаетесь работать уже на нескольких уровнях абстракции, а это в свою очередь значит, что вы заставляете метод делать больше, чем одну вещь. 

 И поскольку вы работаете с методами, которые делают ровно одну вещь и реализованы внутри классов, тоже делающих ровно одну вещь (см. пункты 6 и 7), ваш код начинает магически менять свою структуру. По мере того, как каждая сущность в вашем проекте становится меньше, уровень их повторного использования начинает расти экспоненциально. Будет трудно обнаружить возможности для повторного использования метода, который имеет пять обязанностей и реализован в 256 строках, а вот метод из трёх строк, который управляет состоянием объекта в определенном контексте, обычно получается использовать и во многих других различных контекстах.

Каждый отдельный метод становится практически тривиальным, и его реализация становится полностью соответствующей его имени (см. пункт 6). Да и выявить ошибки в таких гораздо меньших фрагментах кода как правило намного проще. 


2. Не используйте else
и сокращенные формы else if (elif, ...)

Главная идея: отказ от else приводит к необходимости применения целой серии очень полезных best practices, которые в рядовых ситуациях используются к сожалению не так часто, как было бы желательно.

Тут засада в том, что, как я уже говорил про излишнюю свободу во введении, слишком легко просто добавить еще одну else-ветвь к существующему условию, вместо того, чтобы подумать и найти лучшее решение.

Условные выражения также постоянно становятся частым источником дублирования кода (использование флагов статуса тому классический пример). 

 Что делать, если else напрашивается?

- При проверке корректности входных параметров функции делайте немедленный return, если валидация не проходит. В целом, активнее применяйте return. Иногда приходится добавлять дополнительные переменные, но в данном случае это вполне оправдано;

- Применяйте map / reduce / filter;

- Формируйте иерархию классов и используйте полиморфизм вместо создания цепочек if else if ... (как, подробно разбираем на курсе по ООАП).
Изучите заметку "Как заменить условный оператор полиморфизмом". https://refactoring.guru/ru/replace-conditional-with-polymorphism

- Применяйте паттерны
Стратегия (Strategy)
Null object
Состояние (State)

- Максимально избегайте null / None / ... , которые порождают множество побочных веток в проверках. Ну и сама по себе это порочная практика, нарушающая консистентность системы типов.
Оборачивайте результаты в отдельный тип, содержащий значение результата и код ошибки (концепция монад).

Есть и более сильная версия данной рекомендации: отказываться также и от самих if-ов, от самих условных инструкций. Два важных мета-правила, как это правильно делать, даны в материале СильныхИдей "Как и зачем избавляться от if". 


3. Оборачивайте все стандартные примитивные и строковые типы
в прикладные типы/классы.

Главная идея: запретить прямую модификацию состояний (через свободный доступ к переменным), инкапсулировав их, в идеале, в абстрактные типы данных (АТД) c переходом к декларативной модели программирования.

Что понимать под примитивными типами данных? Ну, если придерживаться строгих методик проектирования вроде Domain-driven design (DDD), любой тип в вашей программе, который был написан не вами, считается примитивным, потому что он не входит в предметную область вашего проекта. 

 Например, в языках Java или Python тип int -- это примитив, а не реальный объект, поэтому он подчиняется другим правилам, нежели объекты. Для работы с ним применяется синтаксис, который не является объектно-ориентированным. Что ещё более важно в критическом плане, int сам по себе просто абстрактное скалярное значение. Когда метод получает int в качестве параметра, тело метода должно сделать всю работу по использованию int в правильной семантике проекта -- вложить в int тот смысл, который подразумевает программист.

Если же этот метод принимает в качестве параметра например объект пользовательского типа (класса) Hour, то гораздо проще понять, что происходит, а набор операций Hour не позволит выполнить над аргументом заведомо ошибочные логические манипуляции. Да и сам аргумент по определению всегда будет находиться в корректном состоянии, а не то что дата вдруг стала числом -1.

Кроме того, вы уже не сможете случайно передать такому методу параметр типа Year, вас сразу остановит компилятор. А при обычном использовании примитивных типов он никак не сможет вам помочь в написании семантически корректной программы. Фактически, вы предоставляете компилятору (и программистам) дополнительную информацию о том, что это за значение, и для чего оно используется, что обычно легко понимается через описание типа.

Кроме того, небольшие типы Hour или Money дают вам очевидное физическое место в проекте для размещения поведения, которое в противном случае было бы разбросано по другим классам. Этот подход становится особенно актуальным, когда вы доберётесь до правила 9. 

 Данное правило -- по сути, декомпозиция паттерна Value Object из DDD, который подразумевает создание прикладных типов для простых объектов в программе (деньги или диапазон дат), равенство которых в частности не основано на простой проверке идентичности значений. Например, деньги одной и той же величины могут быть в разных валютах, а даты -- в разных таймзонах, которые нельзя сравнивать в лоб, компилятор сообщит об ошибке. А если использовать примитивные типы для хранения денег в целых "штуках", или времени в секундах unix, не миновать беды.

Я ещё очень рекомендую добавить из Value Object такую фичу, как иммутабельность (неизменяемость) простых объектов. Например, если вы создали экземпляр класса Money с ярлыком "1000 рублей", вы не можете изменить его значение 1000 например на 500 :) Значения типа Money можно складывать или вычитать конечно, но аргументы этих операций неизменны, в результате мы получаем новый объект с итоговым значением. И если получается например отрицательное число -100 рублей, очень удобно контролировать корректность по флагу ошибки объекта.

Дополнительное понимание данного пункта может быть в форме способа обхода анти-паттерна Primitive Obsession. https://habr.com/ru/post/266937/

 Аналогичное правило применяется и к строкам, если программа непосредственно не занимается обработкой строк или их символов. Например, в коде используются повторяющиеся строки-сообщения -- как минимум, их надо оформить как константы, а если они представляют собой некоторые идентификаторы, то их надо представить в виде класса, где каждый идентификатор ограниченно доступен, например, по своему номеру. Этот подход, в частности, поможет избавиться от классических проблем, связанных с кодировкой текстовых сообщений, которые теперь аккуратно собираются в одном месте по смыслу, и в целом, с локализацией.

Разработка, управляемая типами (Type driven development) -- это и сегодня, и особенно в ближайшем будущем, по мере развития систем типов в языках программирования, абсолютный топ в информатике. Типы данных в вашем проекте (классы в ООП) -- это фактически и есть тот язык, на котором вы разговариваете с другими разработчиками и с заказчиками. 

Резюме пункта 3: если у вас в программе имеются любые вычисления, логически явно отличные от прямых арифметических расчётов с целыми или вещественными числами (частый пример -- использование целых для денежных расчётов) и прямых манипуляций с другими примитивными типами, то вместо чисел или строк надо использовать пользовательские типы (классы) с соответствующим набором операций и встроенным контролем корректности и допустимости действий. 


4. Оборачивайте коллекции первого класса
в пользовательские типы/классы.

В принципе, этот пункт изоморфен предыдущему, идея та же, только применительно к коллекциям (массивы, списки, словари... из стандартных библиотек). Отдельный пункт создан потому, что имеется некоторая техническая специфика.

Стандартные коллекции обычно предоставляют программисту излишнюю свободу (например, возможность одной командой удалить всё содержимое коллекции, или обратиться к ней с некорректными индексом, вызвав прерывание, и т. д.), поэтому их использование в конкретной задаче имеет смысл ограничить только компактным набором тех операций, которые действительно требуются, добавив что-то непосредственно по теме задачи (например, специфичные операции фильтрации или поиска). Для этого соответствующая коллекция погружается в АТД. 

 Как уже говорилось, мы избегаем использования в проекте любых стандартных, готовых типов "из коробки" стандартной библиотеки.

Например, классическая беда с доступом к индексированному массиву в том, что это по сути операция доступа к данным по указателю, который легко сделать ошибочным (-1 или за пределами диапазона массива).

Технически это реализуется таким правилом, что любой класс, использующий (содержащий) коллекцию объектов, не должен иметь никаких других полей. Тогда автоматически получается, что каждая коллекция в проекте оборачивается в свой собственный класс, и любое поведение, связанное с коллекцией, имеет своё конкретное местонахождение в проекте.

Вы можете например добавить операции фильтрации в такой класс, объединения двух коллекций вместе, применения функции к каждому элементу коллекции, различные команды агрегации значений и т. п. 


5. В одной строке кода не более одной "точки"
(префикса вызова метода).

Это формальная синтаксическая реализация известного закона Деметры (Law of Demeter, LoD), хорошо снижающего связанность модулей/классов.

LoD гласит: каждый программный модуль (класс) должен обращаться только к непосредственным друзьям -- знакомым ему модулям, при этом знать ему надо максимально возможный минимум о чём угодно во внешнем мире (в том числе и об используемых модулях), кроме своего прямого кода.

Речь тут не просто о конкретной строке кода, а о том, что мы вообще отказываемся от любых цепочек вызовов методов вроде

obj.get_obj2().method2().get_obj3().method3();

 LoD активно применяется в ООП, подразумевая в частности отказ от цепочек вызовов методов, но есть важный нюанс.

Существует концепция текучего интерфейса (Fluent interface https://ru.wikipedia.org/wiki/Fluent_interface), которая удобна для реализации объектно-ориентированного API, чтобы записывать код не в виде

obj.method1();
obj.method2();
obj.method3();
...

а в виде

obj.method1()
   .method2()
   .method3();
...

Каждый метод возвращает вызывающий его объект, поэтому такая цепочка возможна для записи в одной инструкции, а не в наборе команд (паттерн Method Chaining, на основе которого часто строятся сложные запросы и фильтры).

В данном случае LoD допускает подобную схему, так как мы используем в цепочке один и тот же объект, не обращаясь ни к каким сторонним сущностям.

Однако и в этом случае, в каждой строке кода всё равно должно быть записано не более одного вызова метода. 

 В чём сермяга данного правила? Дело в том, что в цепочках вызовов обычно трудно определить, какой именно объект берёт на себя ответственность за ту или иную операцию (за исключением случая Fluent interface). Практически всегда в цепочках вызовов, где несколько "точек" в одной инструкции, находится много неправильно распределенных обязанностей между разными классами.

Если в какой-то инструкции записано более одной точки, значит, объект становится посредником в цепочке вызовов, а это означает в свою очередь, что он знает слишком много о других объектах. Подумайте, чтобы перенести его некоторые активности в один из объектов, с которым он оказался связан в этой цепочке.

Несколько точек означают, что ваш объект слишком глубоко копается в другом объекте. Многочисленные точки указывают также, что вы нарушаете инкапсуляцию.

Думайте об этом так: вы можете играть со своими игрушками, игрушками, которые вы сделали сами, и игрушками, которые вам кто-то явно подарил и которые теперь ваши. Но вы никогда, никогда не можете играть с чужими игрушками. 


6. Не сокращайте имена.

Имена классов/методов/функций должны записываться 1-2 полными словами.

А если в именах методов регулярно встречается какое-то часто повторяемое слово, то его лучше вынести в имя класса.

Это, во-первых, одно из правил хорошего стиля кодирования, которых (правил) вообще насчитывается много. Если сжать курс ясного стиля кодирования до одного правила, то наверное именно это и будет основным.

Во-вторых, самое главное, если вы хотите сократить какое-то имя метода, спросите себя: почему? Скорее всего, ответ будет "потому что это имя приходится набирать часто и много". Но в таком случае возникает сильное подозрение, что вы занимаетесь копипастой кода -- фактически его дублированием; но для ликвидации дублирования в значительной степени собственно и предназначено ООП.

Ещё одна причина для сокращения -- когда имя метода записано многословно. Но в таком случае это уже признак нарушения принципа единственной ответственности SRP (The Single Responsibility Principle) из набора SOLID: класс должен иметь единственную ответственность, только одну причину для изменений. Скорее всего, имя приходится делать таким длинным, потому что класс занимается сразу многими вещами.

Ну и если вы вообще никак не можете придумать хорошее имя для метода, то это признак, что в самом проекте, в его дизайне, что-то пошло не так, и вам требуется его перепроектировать. 


7. Сохраняйте все сущности в проекте
(синтаксически) маленькими.

В классе должно быть не более 50 строк.

Ну, с поправкой на используемый язык программирования, хотя в любом случае предел будет 150 строк, а идеальный вариант, когда весь класс умещается на одном экране. Классы в 50 строк имеют дополнительное преимущество: они видны на одном экране без прокрутки, что облегчает их быстрое восприятие. Значение 50-150 вы можете подобрать индивидуально, но при условии, что вы как минимум на протяжении текущего проекта придерживаетесь одного разрешения экрана и одного размера шрифта.

В модуле/пакете должно быть не более 10 файлов.

Это тоже формальное принуждение к принципу единственной ответственности SRP. Всё поведение класса направляется исключительно на обеспечение этой ответственности и поэтому класс автоматически должен быть компактным, и модуль не должен быть большим. А если не получается уложиться в разумный лимит, значит, декомпозируйте ответственность класса/модуля на более мелкие. 


8. В классе должно быть не более двух полей (атрибутов).

Это действительно довольно суровое, в чём-то экстремальное на первый взгляд правило принуждает вас тщательно задумываться о композиции и наследовании и приводит в итоге к снижению внешней связанности (coupling), повышению внутренней связности (cohesion) и лучшей инкапсуляции.

Например, если вы хотите запихать в класс Customer три поля: Id, FirstName и LastName, то вполне логично будет объединить FirstName и LastName в отдельную логическую сущность (класс) Name из двух полей. Если составляющих в имени больше двух (например, три -- есть ещё отчество), явные именованные поля можно заменить на одно поле-коллекцию, внешний доступ к элементам которого будут выполнять наглядно именованные геттеры. В такой ситуации, кстати, мы автоматически применяем правило 4: создаём обёртку для стандартной коллекции, которая выступает единственным полем класса Name, предоставляя естественные операции именно для работы с ФИО пользователя. 

 Что интересно, тут чаще всего не жалуются на строгость данного правила, а спрашивают "почему не более двух, а не более трёх атрибутов"? Ответ: "а почему нет?" :)

Во-первых, два -- минимально возможное количество атрибутов, допускающее последующую декомпозицию (только один атрибут в классе, моделирующем сложную сущность, очевидно, бессмысленен). Из-за своей минимальности данное правило принуждает вас часто разделять классы.

Во-вторых, хорошая идея семантически разделять два вида классов: те, которым достаточно одного атрибута -- фактически это явная работа с конкретным состоянием, и те, которые координируют активность двух разных сущностей.

В-третьих, формировать и сопровождать классы с двумя полями гораздо проще, нежели с большим количеством атрибутов.

В-четвёртых, ограничение в два поля принуждает вас активнее применять методы функционального программирования и больше усилий вкладывать в чистую логику, нежели в манипуляции состояниями. 

 Иногда может казаться, что выделить в сущности только два ключевых атрибута примерно одного логического уровня часто будет невозможно, но на самом деле это почти всегда не так, за исключением совсем экзотических случаев. Даже в случае явной равноправности -- например, четыре точки в классе прямоугольника left, top, right, bottom вполне можно представить двумя left_top и right_bottom (вы спрашиваете, а если это пентагон? тогда используйте массив фиксированного размера, или список и смоделируйте обобщённый n-угольник).

Или, например, класс Автомобиль, в котором "содержится" руль, четыре колеса, несколько фар, двигатель, медиасистема, и ещё много всего другого? В данном случае вот так "напихивать" совсем разные смысловые сущности на один уровень как раз совсем плохо. Вы понимаете, почему?

Хороший приём -- делить класс на два по принципу "форма и содержание". В случае с автомобилем правильнее будет сгруппировать все эти сущности в два класса "Ходовая часть" и "Кузов" или во что-то другое подобное. Но сделать это можно практически всегда. 


9. В классе не должно быть геттеров/сеттеров,
а все поля обязательно приватно инкапсулируются.

Это крайне полезное заключительное правило, которому я учу ещё на самом первом курсе для начинающих, нацелено на объектное мышление на более высоком уровне абстракции -- АТД. Данное правило, в частности, запрещает использование публичных полей, что само по себе отличная идея.

Это уточнение закона Деметры, гласящее, что вы можете использовать геттеры/сеттеры только внутри класса, не позволяя им выходить наружу.

По сути, мы запрещаем любой внешний доступ к внутреннему состоянию объекта, что очень правильно соответствует подходу АТД, когда у сущности должны быть только те операции, которые относятся к этой сущности по смыслу предметной области. Например, если есть АТД Кот с операциями Бегать и Кушать, то с какой стати давать доступ к его внутреннему полю Масса, если в проекте требуются лишь эти две операции? Это нарушение и принципа единственной ответственности, и принципа Open/Close: создавая сеттеры например, мы открываем класс для модификаций, что совсем плохо -- он должен быть открыт лишь для расширения через наследование. 

 В этой связи отмечу, в дополнение к SOLID, ещё один очень полезный принцип: не спрашивайте класс о чём-то, а говорите ему, что делать -- отдавайте ему приказы. Этот принцип исключает геттеры, которые по сути отвечают на внешний вопрос. Можно конечно создавать геттеры в случаях, если от АТД явно это требуется: например, UI требует показывать массу кота. Но даже в таком случае это должен быть не стандартный геттер, а метод с именем, явно указывающим, что масса нужна именно (и только) для показа в интерфейсе пользователя.

Почти напрямую ведет к этому правилу, как ни парадоксально на первый взгляд, предыдущее правило (не более двух полей в классе). Если текущей конструкцией ваших классов всё ещё неудобно пользоваться, надо рассмотреть прямые нарушения инкапсуляции. Поведение не будет следовать за объектом, если можно просто запросить его внутреннее значение, текущее состояние.

Идея сильной инкапсуляции заключается в том, чтобы заставить программистов искать и находить некоторое единое по смыслу поведение и помещать его в одном конкретном месте в объектной модели. В результате же возникает множество полезных эффектов: от сокращения ошибок, связанных с дублированием кода, до удобной локализации вносимых в проект изменений при реализации новых возможностей. 

 Тут может возникнуть хороший вопрос. Поскольку мы обернули все примитивные типы в пользовательские классы (правило 3), и у нас нет геттеров, мы никогда не сможем выяснить их значения, их состояние. Так как же нам тогда создавать юнит-тесты, проверяющие состояние, ведь такие тесты очень полезны? Это действительно довольно сложный момент, и однозначного решения тут нет. Например, добавлять геттеры в рабочий класс только ради тестов, конечно, будет плохим решением.

Во-первых, надо понять, зачем вам вообще понадобилось проверять состояния внутренних полей? Если это требуется не только для тестов, значит, проблемы с проектированием, надо пересмотреть иерархию классов, насколько она отражает предметную область.

Во-вторых, если это требуется именно для тестов, можно добавить в класс операцию сравнения объектов по их внутренним значениям, что будет несложно, так как в классах теперь не более двух полей.

В-третьих, можно задействовать наследование, и создать классы-наследники тестируемых сущностей, специально для тестов -- только с геттерами.

Как правило, подобные отладочные расширения проекта можно регулировать различными инструкциями препроцессора, легко включая или отключая дополнительный код. 


Object Calisthenics (чек-лист)

1. Пишите функции/методы так, чтобы внутри них было не более одного отступа.
В вашем коде не должно быть вложенных циклов и вложенных условий.

2. Не используйте else и сокращенные формы else if (elif, ...).

3. Оборачивайте все стандартные примитивные и строковые типы в прикладные типы/классы.

4. Оборачивайте коллекции первого класса в пользовательские типы/классы.

5. В одной строке кода не более одной "точки" (отказ от цепочек вызовов методов).

6. Не сокращайте имена классов/методов/функций.

7. Сохраняйте все сущности в проекте (синтаксически) маленькими.

8. В классе должно быть не более двух полей (атрибутов).

9. В классе не должно быть геттеров/сеттеров, а все поля обязательно приватно инкапсулируются. 


Дополнительная информация по курсу

Семь из девяти правил по сути просто способы визуализации и реализации святого Грааля объектно-ориентированного программирования -- инкапсуляции данных.

Одно из основных понятий ООП -- абстракция: класс должен отражать одну и только одну ключевую абстракцию (SRP). Очевидно, что примитивные и встроенные типы лишены абстракции в контексте вашего проекта. "Обёртывание" примитивов (правило 3) и "обёртывание" коллекций (правила 4 и 8) подталкивает вас к созданию большего числа абстракций. А чтобы они не плодились бессмысленно, правило 6 помогает сфокусировать ваши абстракции на предметной области проекта.

Правильные классы (АТД) определяются тем, что они делают, а не тем, что они содержат. Все данные должны быть спрятаны внутри своего класса. Это и есть инкапсуляция. Правило 9 заставляет вас держаться подальше от доступа к полям за пределами класса.

Кроме того, ещё одно правило 2 управляет надлежащим использованием полиморфизма: не используем else и вообще сводим к минимуму всю условную логику, перекладывая её на компилятор и среду времени выполнения. И наконец правило 6 -- стратегия именования, поощряющая краткие и понятные стандарты для имён, без непоследовательного применения и труднопроизносимых сокращений.

Сермяга данной методики заключается в том, чтобы создать программу, в которой нет дублирования кода ни на уровне синтаксиса, ни на уровне семантики. Вы пишете код, который лаконично выражает простые и элегантные абстракции. 

 Довольно детская критика от "умельцев" мэйнстрима обычно сводится к весьма слабым утверждениям наподобие такого: каждый шаг, который вы делаете в направлении "истинного ОО" по данным правилам -- это очередной способ затушевать смысл вашего кода. Если вы разбиваете свой код на 10 различных методов, то это 10 различных мест, куда вам придётся заглянуть, чтобы понять, что происходит. Вы как бы пишете спагетти-код под другим названием. При этом авторы критики сами признают, что если вы создаете большой проект, то, возможно, дополнительная гибкость того стоит :)

Ну конечно, во-первых, если вы пишете маленький проект, утилиту или скрипт, наверное проще и быстрее написать линейный код. Мы же говорим прежде всего о взрослых серьёзных проектах.

Во-вторых, и это самое главное, я не раз объяснял в заметках в паблике, что как раз невозможно продуктивно мыслить о программе, о смысле кода, на уровне самого кода, на непосредственном уровне инструкций. Нам как раз нужны гораздо более сильные логические абстракции, которые можно вместе удерживать в голове, но языки программирования нам такой возможности не предоставляют. Методики вроде DDD нацелены именно на это. Девять правил как раз сильно упрощают процесс думания о проекте в терминах его предметной области. 

 Чтобы получить реальный эффект от Object Calisthenics, потратьте не менее 20 часов и напишите не менее 1000 строк кода, который на 100% соответствует этим правилам. Вы обнаружите, что вам придётся отказываться от немалого числа старых привычек и изменять правила кодирования, с которыми вы, возможно, жили всю свою жизнь разработчика. И это конечно будет дискомфортно :)
Но, стараясь постоянно следовать всем этим правилам без исключений, вы естественным образом измените в лучшую сторону ваш стиль кодирования и проектирования -- то, как вы пишете код и как формируете систему типов/классов.

Надо ли применять эти правила все вместе, или можно попытаться "улучшить" эту методику, подойти к ней "творчески", взять только некоторые пункты, а другие не брать, или внести в них правки на свой вкус?

Я настоятельно рекомендую применять эту методику целостно, не исключая ни один пункт, и ничего в них не меняя -- потому что вы наверняка будете отказываться прежде всего от тех пунктов, которые для вас наиболее трудны, и именно поэтому дадут вам наибольшую пользу. 

 Конечно, по мере практики вы скорее всего обнаружите, что эти правила противоречат друг другу в некоторых исключительных ситуациях, или их применение приводит к вырожденным результатам. Это совершенно нормально, это частные случаи, и я уверен, что со временем вы поймёте, как, оставаясь в рамках данной методики, их можно обойти.

Каждое из этих правил было выбрано таким образом, что если вы будете следовать ему без отклонений, вы начнёте добираться до ситуаций, которые обычно имеют простой но контринтуитивный ответ, который вам ранее был недоступен.

Чем больше вы практикуетесь в применении правил, тем больше преимуществ получаете. Ваши первые попытки реализовать проект в в предложенном здесь стиле окажутся неловкими и скорее всего не приведут к ощутимому выигрышу, но поверьте, это временно. Применение правил -- это искусство и дисциплина программирования, поднятые на другой уровень. 

 Дисциплинированное следование всем правилам Object Calisthenics принудит вас постепенно находить всё более сложные ответы, которые ведут к гораздо более глубокому пониманию объектно-ориентированного программирования. Если вы напишете тысячу строк, которые следуют всем этим правилам, вы обнаружите, что создали нечто совершенно иное, нежели вы ожидали исходно и нежели вы получили бы, вымучивая классическими навыками "сознательного" проектирования.

Просто следуйте правилам (я бы даже сказал -- следуйте механически, не слишком увязая в медленном мышлении -- делайте это легко), и посмотрите, к чему вы в итоге придёте. Если то, что получится, вас не устроит, отступите и посмотрите, что вы можете сделать более удобным. Скорее всего, если вы продолжите работать над проектом по этим правилам, вы найдете то, что нужно.

И в конечном итоге вы увидите, что код, который вы пишете, соответствует всем этим правилам без каких-либо сознательных усилий с вашей стороны.

Это будет ваша очередная победа в ООП и ОО-проектировании.

Перед третьим, прикладным курсом по ООАП:

1) Изучите материал СильныхИдей "94) ООП как средство повторного использования кода".

2) От курсанта:
"По ООП проектированию у меня затык насчёт ситуации, когда в условной игре пользователю нужно выполнить команду. Но команды бывают условно "высокоуровневые" - закончить игру, перезапустить и т.д. И "низкоуровневые" - например, манипуляции с элементами игрового поля. Если мы придерживаемся подхода с не больше 2-х полей в классе, и не допускаются "цепочки" вызовов, то как команде "дотянуться" одновременно до объекта сервиса игры и до конкретного элемента игрового поля. Здесь нужен либо какой-то паттерн (пока не уверен какой), либо разные иерархии классов на такие команды."

Да, предварительно изучите паттерны Фасад, Observer и Command. 

