Архитектура текущего проекта достаточно разветвленна, но типична (python-backend, Алхимия как ORM, REST/HTTP, JSON, DTO, большое количество интеграций и каналов).

Большинство критически важных структур данных в проекте присутствуют в коде в виде объектов доменных моделей.
Некоторые существуют в виде dict.

Запросы обрабатываются по айди, данные хранятся в кеше, в памяти, в виде словарей или объектов классов, откуда периодически через ОРМ выгружаются в базу.

Есть места (например, реализация интеграции с каналами общения), где доменная модель слабая (в виде АПИ и сервисов), классов, определяющих структуры данных нет, данные определяются АПИ сторонних сервисов, приходят и уходят как dict.



Вариант 1. Ресурс идентифицируется тем, чем он является в предметной области, а не айди из БД.

Пример REST API
GET /visitors/by-external-id/{crm_id}
GET /operators/by-login/{login}
GET /chats/by-channel/{channel_name}/by-start-time/{iso_timestamp}
GET /files/by-sha256/{hash}

Как хранить данные (без ORM):
Явные SQL-запросы.
Уникальные индексы по семантическим полям.
Репозитории уровня:
load_chat(channel, started_at)

Вариант 2. Ресурс не существует сам по себе, а только в рамках агрегата или контекста.

Нет:
глобальных message_id,
глобальных session_id.

Есть:
«сообщение в чате»,
«сессия пользователя в канале».

Пример REST API
GET /channels/{channel_name}/chats/{started_at}/messages/{seq_no}
POST /operators/{login}/sessions/current/messages
GET /visitors/{external_id}/active-chat


Просто, если отказаться от мышления через айди строки таблиц, то надо понять, как определить, на что мы сможем опереться в поиске ресурса для работы. Если абстрагироваться от реализации баз данных, где айди - самый универсальный индекс для моментального поиска строки или записи (если не реляционная БД), то выглядит так, что конкретое значение, имеющее смысловое значчение, будет лучше читаться в коде. В любом случае это должно быть такое поле, которое будет однозначно указывать на нужный ресурс. К тому же передача данных в ГЕТ запросах (опять же речь о текущей реализации http протокола), позволяет читать и получить доступ к лишней информации, когда айди не несет для стороннего наблюдателя никакого смысла. Если отходить от айди, то, видимо, нжно иметь какого-то кодировщика на стороне клиента и сервера, который бы переводил значимые ключи в зашифрованный формат.

С другой стороны, используя какие-то внутренние идентификаторы внутри какого-то более общего объекта (как например сообщение  чате по номеру этого сообщения именно в этом чате) можно также отойти от айдишников, оставаясь в безопасности по передаваемым данным. Чат можно определять по составу участников, времени (или диапазону времени). В целом этот подход читался бы естественнее в коде.

Но для этого надо сломать мышление в рамках реляционных моделей :) Но материал интересный, я долго думал.