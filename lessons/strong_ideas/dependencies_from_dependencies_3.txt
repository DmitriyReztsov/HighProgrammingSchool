1. Зависимость фреймворка.
Инцидент с непроходимостью очереди Селери, когда одна задача падала с ошибкой, но была написана таким образом, что генерировала тут же три новых (ретрай + назначение самой себя). Понятно, что Селери не может зависеть от своей таски. Поведение брокера определяется кодом задачи. В результате исправили таску, ввели дополнительное управленческое решение ограничивать явно количество выполнений тасок (где возможно) и для этого был написан декоратор, отслеживающий, сколько раз таска была уже выполнена.

2. Зависимость расшаренного формата.
Когда фронтенд падал на некоторых контрактах из-за того, что фронт ожидал в одном поле список, но когда оно оказывалось заполненным - там приходил словарь. Требуется согласованная спецификация для бэка и фронта.

3. Зависимость зависимости.
В описанном варианте я еще не сталкивался с проблемами, но можно предположить такую ситуацию. У нас есть сервис, который работает с документами типа .docx, которымии основной бэкенд оперирует. И если бы в результате каких-то действий в эти документы вносились бы изменения, которые не учитывались бы на основном бэкенде (изменение содержимого, изменение ссылки на хранимый файл, изменение версии документа), то это приводило бы к проблемам. В этом случае действительно необходима была бы суперспецификация, ограничивающая добавление методов работы с файлом, которые явно не инициализированы бэкендом.

4. Зависимость краша. Можно вернуться к пункту 1 - упавшая из-за одного сервиса очередь повиляла на то, что совершенно сторонний сервис, который просто использовал ту же самую очередь, тоже не смог выполнять свою работу. И решение то же, но под другим углом: декоратор, ограничивающий количество запущенных тасок, выступает как бы такой суперспецификацией, который говорит разработчику, что нужно проверить, чтоб новая таска не ломала рантайм.

5. Зависимость перебрасывания. У нас нет сейчас такого явного перебрасывания, какой описан в теории. Но есть функционал подписания документа электронной подписью, который использует два сервиса - по выбору пользователя. Получается, действительно, функционал подписания документа зависит от обоих сервисов, даже если второй не используется. Различия в сервисах уж отразились на обработке подписей и потребовали внесения изменений в подготовительную часть (когда документ и подписант готовятся к передаче на сервер стороннего сервиса - формируется пдф, собираются данные подписанта, проверяется наличие подписей другой стороны и пр.)

6. Зависимость инверсии. В Питоне в принципе нет статического связывания. Если не готворим уже о циклическом импорте, то сейчас активно используем аннотацию и проверку типов, в т.ч. mypy

7. Зависимость зацикливания. Снова про цикличные импорты. Если рассуждать о транзитивности зависимости, то нужно понять: при зависимости модуля А от модуля Б, а модуля Б от модуля С - где именно возникают такие зависимости и можно ли разорвать зависимости через вынос проблемного места в отдельный модуль таким образом, чтоб измененный модуль Б перестал зависеть от модуля С? Чаще всего решаем переносом импорта, который запускает цепочку вызовов зависимостей, в область определения функции, которая его использует. Иногда удается вынести в отдельный файл.

8. Зависимость высшего порядка. Писал тестовую библиотеку, которая должна считать площади разных геометрических фигур. Пока писал, понял, что библиотека не должна зависеть от того, что именно пытается передать в конструктор фигуры пользователь. Поэтому по заданным пред-условиям делал валидацию и просто не принимал данные, отличные от int или float. Но при переопределнии базовых классов самих фигур пользователь мог бы внести измененное поведение и получить на выходе неожидаемый результат. По-хорошему, как вывод, надо закрывать доступ к базовых классам, но это Питон, тут все построено на осознанности разработчика.

9. Зависимость большинства. Рефакторинг кода даже за самим собой годовой давности вызывает массу эмоций, а есть же еще коллеги и ревью, и споры о том, как лучше. Получается опять же, что конечная версия программы зависит от победившей версии кода и от предыдущих версий, которые важно не сломать.