1. Зависимость фреймворка.
Только что разбирали инцидент с непроходимостью очереди Селери. Одна задача падала с ошибкой, но была написана таким образом, что генерировала тут же три новых (ретрай + назначение самой себя). Решить смогли только через несколько итераций, через мониторинг и погружение в код чуть ли не каждой задачи. О том, что очередь может так зависеть от задачи мысль пришла сильно позже. Начиналось все просто с обнуления очереди, что, понятно, помогало не на долго.

2. Зависимость расшаренного формата.
Фронтенд начал падать на некоторых контрактах. Выяснилось, что фронт ожидал в одном поле список, но когда оно оказывалось заполненным - там приходил словарь. В похожих моих примерах, когда во время тестирования (не доводя до прода) случалось похожее - я обычно сразу проверяю форматы ответа бэка и ожидаемые форматы фронта. Но последнее время просто описываю форматы ответов в задаче для фронта.

3. Зависимость зависимости.
Это часто проявляется в циклических импортах Джанги, когда модуль А импортирует модуль Б, (тут может быть еще ряд промежуточных модулей) который импортирует что-то из модуля А, который таким образом оказывается не инициализованным. Сейчас с опытом я сразу такие ошибки исправляю осознанно, при возможности предупреждая их выносом общих переменных в другой модуль без зависимостей.

4. Зависимость краша. Можно вернуться к пункту 1 - упавшая из-за одного сервиса очередь повиляла на то, что совершенно сторонний сервис, который просто использовал ту же самую очередь, тоже не смог выполнять свою работу.

5. Зависимость перебрасывания. У нас нет сейчас такого явного перебрасывания, какой описан в теории. Но есть функционал подписания документа электронной подписью, который использует два сервиса - по выбору пользователя (на время плавного перехода от отдного сервиса на другой). Конечно, функционал подписания документа зависит от обоих сервисов, даже если второй не используется. Поскольку мы решаем задачи "в общем виде". Это вносит определенную неразбериху в отладку ошибок, на сейчас мы логируем такие ошибки и как минимум в состоянии локализовать проблему на том или ином сервисе. Необходимость логирования стала понятна на старом сервисе, который вроде как был уже отработан и отлажен ранее, но в рамках добавления нового сервиса код был переписан и перенесен в отдельный сервисный модуль - диспетчер.

6. Зависимость инверсии. В Питоне в принципе нет статического связывания. Программа может упасть во время запуска сервера, если возникнет циклический импорт - когда происходит инициализация всех классов. Все остальное происходит в рантайме. Часто для борьбы с циклическим импортом мы перемещаем импорт в область определения метода, тогда этот импорт не вызывается при запуске проекта, а потом, при вызове метода, все зависимости зависимостей уже загружены и модули полностью инициализированы.

7. Зависимость зацикливания. Снова про цикличные импорты. Получается, что программа, выполняя код сверху вниз натыкается на зависимость, которая приводит ее в тот же модуль, но на строчку ниже, до которой она еще не дошла и та зависимость еще не инициализирована. Решаем разрываением на каком-то этапе (чаще всего - на первом шаге, по возможности) цикла путем переноса импортов в методы / функции. Если есть четкое понимание, что именно вызывает начало такого цикла - то изолируем именно эту сущность. Как пример: сначала некая константа была прописана с конкретной модели:

class FinancialDocumentPeriodMixin(models.Model):
    UNDEFINED_PERIOD = -1  # <---

    financial_year = models.IntegerField(default=UNDEFINED_PERIOD, validators=[validate_int_as_year])
    financial_month = models.IntegerField(default=UNDEFINED_PERIOD, validators=[validate_int_as_month])
    financial_quarter = models.IntegerField(default=UNDEFINED_PERIOD, validators=[validate_int_as_quarter])
    date_of_month = models.IntegerField(default=UNDEFINED_PERIOD, validators=[validate_int_as_date_of_month_max])

При дальнейшей разработке потребовалось дописать валидатор как класс и менеджер объектов, которые бы учитывали в своей работе эту константу. Импорт класса только ради этой константы однозначно вызывал бы цикличный импорт, поэтому константа была вынесена в отдельный модуль констант, откуда уже импортировалась в модели, валидаторы и менеджеры

class FinancialDocumentPeriodMixin(models.Model):
    UNDEFINED_PERIOD = UNDEFINED_PERIOD_CONST


8. Зависимость высшего порядка. Я не уверен, что в этом пункте библиотека зависит от кода, ее использующего. Или все-таки имеет место некорректное использование библиотеки. Или это просто уязвимость в самой библиотеке. Но более высокая абстракция не должна знать и учитывать особенности реализации более конкретной абстракции и реализации этой абстракции. Реализация должна зависеть от абстракции и учитывать ее в своей реализации. Не уверен, в эту ли категорию отнести такой пример: создали модель (ту, что выше приведена), объекты которой надо было упорядочивать по датам. Но даты могли быть не полными. Из-за этого пришлось писать сложную конструкцию по аннотации кверисета, собирая ключ для сортировки. Сейчас переделываю на конкретные даты, которые будут выставляться по определенной логике, но это позволит сортироваться и фильтроваться по кверисетам стандартными способами Джанги.

9. Зависимость большинства. Мы, конечно, не пытались писать одну и ту же задачу несколькими разработчиками, но рефакторинг кода даже за самим собой годовой давности вызывает массу эмоций из разряда "да кто ж так пишет". И приходится учитывать все то, что написано до тебя текущего, чтоб не сломать. Так что да, программа зависит от каждой версии кода.