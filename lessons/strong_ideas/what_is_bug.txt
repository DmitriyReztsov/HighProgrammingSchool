1. Это не баг.
1.1. Натолкнулся на такой код в тестах:

self.assertEqual(response.data["id"], self.gencontractor.id + 1)

В этом тесте тестировался ответ с ендпойнта, возвращающего данные по subcontractor.
При этом код работал, тест проходил без ошибок. Но вот эта +1 меня очень заинтересовала. Оказалось, что в момент создания тестовых данных сущность сабконтрактора создавалась сразу за сущностью генкотрактора. Таки образом id саба был +1 к id генктонтрактора. Как бы все логично, код работает, в ассерт попадает нужная цифра, но по сути - это не правильно.

1.2. У нас на проекте есть две модели Company и Contractor, последняя наследуется от первой, обе представлены реальными таблицами в БД. По коду часто встречается конструкция типа company = ... и тут происходит присвоение (часто через метод или третью сущность) объекта модели Contractor. Работает все ровно до того момента, как кто-то не начинает модифицировать код и пытаться на этой переменной company вызвать методы, которые присущи только модели Company. Но пока такого не происходит и используется только id или еще какие-то общие аттрибуты - все ок.

2. Это не баг, а что-то другое.
2.1. встречался с АПИ сторонних сервисов для Питона, которые не следуют конвенции о именовании переменных и вот приходится импортировать что-то типа someStrangeAction и хорошо, если есть хорошая документация, объясняющая, что это переменная, метод или класс.

2.2. неиспользуемые ендпойнты (или в общем виде - неиспользуемый код). Он и тестируется, и при необходимости поддерживается, но он просто не нужен. Система работает и без него, и с ним, но приходится отвлекаться на него, учитывать его импорты, переменные, константы и пр.

3. Это сбивает людей с толку.
3.1. есть переменная, названная report_type. Изначально должна была ссылаться на тип отчета: годовой, месячный, квартальный. Но со временем суть этой переменной поменялась, хотя сами значения - нет. Она стала обозначать тот тип даты, который должен храниться с отчетом - годовой = только год, квартальный = год + квартал... К тому же на фронтовой части эта сущность названа именно по новому смыслу period_type. Стоит переименовать.

3.3. похожая проблема с переменной, названной new_files. В нее записывается кверисет, содержащий объекты финансовых документов. Каждый такой документ содержит ссылку на модель File (еще один пример неудачного нейминга - настолько древнее легаси, что никто его не трогает), которая содержит набор полей типа дат, имен, пользователей и поле собственно файла (django.core.files.File), который и нужен для загрузки в сторонний сервис.

def heron_upload(self, request) -> Response:
    queryset: QuerySet[FinancialDocument] = self.filter_queryset(self.get_queryset()).filter(
        document_type__in=HERON_ALLOWED_DOCUMENT_TYPES
    )
    new_files = queryset.filter(heron_upload_time__isnull=True)
    uploader = HeronUploaderService(
        heron_api_url=settings.HERON_API_URL,
        heron_username=settings.HERON_USERNAME,
        heron_password=settings.HERON_PASSWORD,
    )
    uploader.run(new_files)
    result = self.get_serializer(queryset, many=True)
    return Response(result.data)

т.е. по-хорошему это поле по своей сути надо переименовать, например, в non_uploaded_docs

4. Хрупкость.
4.1. при синхронизации справочников ролей пользователей с фронтом важно, чтоб фронт знал индексы бэка и наоборот. Была ситуация, когда бэк поменял сви справочники, а фронт продолжал слать старые индексы какое-то время. И костылями приходилось переводить одно в другое.

4.2. была создана модель FinancialDocument сначала без ограничений. Была протестирована, появились записи в базе. Потом добавили в эту модель достаточно строгие ограничения на уровне самой модели (т.е. базы данных). Но при этом не учли, что поля, включенные в эти ограничения, имеют дефолтное значение None, что не учитывалось при проверке ограничений. При исправлении этого пришлось делать миграции и это вызвало сложности при накатывании миграций.

5. Не соответствует требованиям OSHA.
5.1. была поставлен задача по расчету стоимости услуг, формула к которому включала работы с процентными ставками. Ставки в системе хранились как просто float поле, без описания того, хранится ли там процент или десятичная дробь. Первая реализация, соответственно, вызвала ошибку в расчетах.

5.2. по коду в разных моделях были использваны два имени для даты created_on и created_at. Приведение к одному имени потребовало многих миграций, исправлений в разных местах и много времени.