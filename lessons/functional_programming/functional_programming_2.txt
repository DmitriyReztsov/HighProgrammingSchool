
1. монада -- это моноид в категории эндофункторов

"Ещё один туториал по монадам" -- на эту тему есть классическая шутка Haskell-программистов. Дескать, это обязательный путь каждого хаскель-разработчика.

Как известно, "монада -- это моноид в категории эндофункторов". Этот легендарный мем можно найти на куче форумов. В оригинале он звучит так: "A Monad is just a monoid in the category of endofunctors", и получил массовость, будучи упомянут в 2009 г. в шутливой анти-истории программирования "Brief, Incomplete and Mostly Wrong History of Programming Languages" от JamesIry. Но эти темы на самом деле относятся к теории категорий и абстрактной алгебре.
Подробно для программистов я разбирал эту тему в сериале https://vk.com/wall-152484385_3687

В программировании же под монадой понимают не очень корректный в математическом плане шаблон: это некий контейнер (обёртка) для функций, который скрывает внутри себя любые побочные эффекты. За счёт этого из таких контейнеров можно выстраивать цепочки вычислений, не опасаясь, что она где-то прервётся с ошибкой. В худшем случае такая цепочка контейнеров (монад) вернёт признак отсутствия значения (например, None).
(На самом деле, обёртка/контейнер -- это тоже неверное определение монады, чрезмерно упрощённое ради понимания на уровне джуниоров; монада -- это скорее про вычисления)

В императивном программировании для реализации такого подхода всё содержимое каждой функции, претендующей на роль монады (точнее, аппликативного функтора (см. далее) -- более "слабой" в математическом смысле модели), надо охватить блоком try-catch. Также надо проверять, не вернула ли уже предыдущая функция некий условный код ошибки, чтобы сразу же передать его по цепочке дальше. В итоге код получается разбухшим и совсем не наглядным.

Подходящим монада-шаблоном, в принципе, достаточно считать функцию-контейнер, получающую на вход наш условный "монадический" тип данных, и возвращающую его же на выходе. Конкретные результаты вычислений извлекаются из такого типа особым образом. Тогда мы можем абсолютно безопасно выстраивать произвольные цепочки вычислений (ленивые, параллельные, асинхронные, …) из таких контейнеров, совершенно не опасаясь каких-либо побочных эффектов.

Например, при проектировании сложных систем такой подход (в частности, концепция монад состояний, state monads, рассматриваемая далее) позволяет полностью избавиться от временных состояний, как на клиентской, так и на серверной сторонах.

2. Инсталлируем монады

Примеры мы будем рассматривать на Python с помощью небольшой библиотеки PyMonad, которая реализует как монады, так и сопутствующие абстракции -- функторы и аппликативные функторы, с которыми мы познакомимся в ходе курса. Она устанавливается тривиально:

pip install PyMonad

Рассмотрим простой пример, который поясняет прикладную необходимость монад. Подобные моменты постоянно встречаются в практическом программировании.

Например, мы вызываем функцию sin(), которая всегда возвращает одно значение, синус аргумента. Но, допустим, мы хотим знать не только результат вычислений, но и количество вызовов этой функции.

Вот как можно реализовать эту схему:

from math import pi, sin as _sin

def sin(theta, state):
    return (_sin(theta), state + 1)

Переменная count работает тут как счётчик, однако огромный недостаток данного подхода в том, что мы храним временное значение -- заводим изменяемые, мутабельные объекты.

Условно говоря, мы получим что-то вроде

(x, count) = sin(pi, 0)
(x, count) = sin(pi/2, count)
(x, count) = sin(pi/4, count)

но это, очевидно, абсурдный способ.

Можно добавить в модуль глобальный счётчик:

sin_counter = 0

def sin(theta):
    global sin_counter
    sin_counter = sin_counter + 1
    return _sin(theta)

x1 = sin(pi) 
x2 = sin(pi/2)
x3 = sin(pi/4)

но такой подход (инъекция внешних зависимостей) считается абсолютно вредным.

Далее напрашивается классический вариант из объектно-ориентированного программирования: объявим класс sin и например метод compute(), который при каждом вызове вернёт значение синуса от аргумента, и при этом увеличит внутренний счётчик на единицу. Также понадобится метод get_count() для получения его значения.

Минус этого подхода, во-первых, в том, что даже для такой тривиальной задачи потребуется написать довольно много кода, объявить новый тип данных Sin, и хранить внутри него мутабельное значение, текущее состояние. А во-вторых, и это самое главное, если мы захотим таким же способом определить косинус, нам придётся либо копипастой создавать копию класса Sin, либо создавать иерархию и наследовать наши Sin и Cos.

А если нам далее потребуется строить из подобных классов цепочки вызовов, по которым нужна статистика, сколько раз в рамках такой цепочки было сделано вычислений? И в эти цепочки желательно также включать и совсем сторонние вычисления... Такая исходно совсем простая задача по мере развития требований резко усложняется практически на ровном месте. Как же тут можно подстелить побольше соломки?

Контрольные вопросы.

1. Возьмите для примера какой-нибудь свой проект и подумайте, где и как в нём можно было бы избавиться от хранения промежуточных результатов и использования промежуточных переменных.

В модуле, который возвращает рассчитанные значения из хранимых в базе полей можно было бы переводить эти значения в тип данных, возвращающий либо None, либо значение. В том же типе можно заменять пустые значения из БД на 0.

Например, такой метод

def get_total_gross_invoice_rate(self) -> Optional[int]:
    invoice_amount = self.invoice_amount
    if not invoice_amount:
        return None

    discount_fee = self.discount_amount or 0
    admin_fee = self.admin_fee_amount or 0

    invoice_rate_percentage = (discount_fee + admin_fee) / invoice_amount * 100
    ...

В нем можно было бы перевести все суммы в свой класс, и перегрузить арифметические операторы:

class Amount:
    def __init__(self, value, error = 0):
        self.error = error
        if error:
            self.value = None
        else:
            self.value = value or 0

    def __add__(self, other):
        try:
            return Amount(self.value + other.value, 0)
        except Exception:
            retutn Amount(None, 1)

    def __truediv__(self, other):
        try:
            return Amount(self.value / other.value, 0)
        except Exception:
            retutn Amount(None, 1)

тогда нам не надо было бы хранить промежуточные переменные и метод преобразовался бы просто в строчку типа:

def get_total_gross_invoice_rate(invoice_amount: Amount, discount_fee: Amount, admin_fee: Amount) -> Amount:
    invoice_rate_percentage = (discount_fee + admin_fee) / invoice_amount * 100
    ...
    

2. Подумайте, как в принципе может быть устроена архитектура сложной системы, где промежуточные состояния вычислений вообще никак не хранятся в явном виде (за исключением каких-то специфичных настроек). 

И, видимо, нам нужен дополнительный слой, где будут храниться такие типы данных (определения классов).


2. Синтаксическая соломка

Совсем скоро станет понятно, что класс проблем, упомянутых в первом задании, прекрасно решается с помощью монад. Но мы подойдём к этому понятию постепенно, рассматривая важные сопутствующие понятия. Прежде всего это карринг (в математике под ним понимается замыкание для моноидов, но к программированию оно не имеет отношения) и частичное применение.

2.1. Карринг

Карринг декомпозирует функцию многих переменных на функцию от одного аргумента. Другими словами, мы от одного вызова функции с N переменными переходим к N вызовам функций с одной переменной (аргументом). Мы берём первый аргумент, комбинируем его с функцией, и возвращаем функцию с этим аргументом. Пока другие аргументы ещё неизвестны, поэтому возвращено будет, конечно, не какое-то значение, а просто отложенный вызов функции (так как вычислять пока нечего, мы не знаем всех аргументов). Далее переходим к следующему аргументу, комбинируем его с предыдущей функцией, и повторяем эту операцию, получая на выходе N вложенных вызовов.

Еще раз отмечу, что карринг в конечном итоге возвращает функцию (ссылку на временную последовательность вычислений в памяти), а не на результат ее работы -- то есть её в заключение надо вызвать явно, чтобы она вычислилась. Хотя в чистых функциональных языках (например, Haskell) все функции по умолчанию каррированы.

Библиотека PyMonad предоставляет декоратор curry, который превращает обычную функцию в каррированную. Параметром curry указывается количество параметров у каррированной функции. Например, есть функция add, вычисляющая сумму двух своих аргументов:

from pymonad.tools import curry

@curry(2)
def add(x, y): 
    return x + y

add(2,3) # 5 

Но так как add() каррированная, мы можем также записать

add(3)

Что она вычислит? Ничего, возвращена будет некая промежуточная функция, так как числа аргументов недостаточно для полного расчёта. В частности,

f = add(3)
type(f).__name__

вернёт function -- это специальный каррированный тип функции из PyMonad.

И тут сразу начинается магия!

В терминологии функционального программирования мы "замораживаем" аргумент 3, и дальше можем использовать такую промежуточную функцию, например, для увеличения другого аргумента на три:

add3 = add(3) # add3 - функция

Зато add3 мы можем использовать для финального вычисления:

add3(2) # 5

2.2. Частичное применение

Следующее важное понятие -- это частичное применение. Оно представляет собой общий случай карринга -- возможность промежуточного/вложенного вызова функций не только с одним аргументом, но и с произвольным числом.

PyMonad не делает различия между их количеством, декоратор curry универсальный.

Пусть функция add_3() складывает все три свои аргумента:

@curry(3)
def add_3(x, y, z): 
    return x + y + z

Можно вызвать её со всеми аргументами:

add_3(2,3,5)

и сразу получить 10. Либо можно частично её применить -- вызвать

add_3(2,3)

Сохраним такую функцию:

add23 = add_3(2,3)

Теперь функция add23() ожидает единственный, последний аргумент:

add23(5)

В результате мы получим 10.

Форма комбинации аргументов допускается произвольная!

add_3(2)(3,5)
add_3(2,3)(5)
add_3(2)(3)(5)

2.3. Задания

2.3.1. Напишите каррированную функцию с двумя строковыми параметрами, которая вычисляет их сцепленное значение. Создайте на её основе функцию, которая получает один параметр и возвращает

Hello, значение-параметра

Это требуется, чтобы можно было выводить стандартное приветствие, задавая только имя.

2.3.2. Придумайте функцию, которая получает на вход четыре аргумента: слово привествия, знак препинания за ним, имя приветствуемого, и заключительный знак.

Как сделать так, чтобы вариант её частичного применения получал бы в качестве единственного параметра только имя, а все остальные параметры настраивались бы другим вызовом?

Например:

final = first_step("Hello")(",")("!")
final("Petya")

Результатом будет

Hello, Petya!



3. Композиция функций

Композиция функций естественно расширяет принцип карринга.

Каррированные функции можно не только запоминать для последующего использования с нужным числом аргументов, но и, как стало ясно из последнего примера с комбинированием списков аргументов, "составлять" (compose) друг с другом. Таким образом результат вычисления одной функции передаётся на вход другой.

В предыдущих версиях PyMonad была очень удобная операция композиции функций * , когда сперва вычисляется самый правый аргумент, затем этот результат передаётся на вход левой функции, и так далее. Однако начиная с версии 1.3 автор существенно изменил синтаксис, видимо, стараясь сделать его более наглядным, но...

Теперь используется специальная функция Compose:

from pymonad.reader import Compose

Она выполняет подобную комбинацию явными синтаксическими конструкциями. Например, мы хотим получить второй элемент списка, а у нас в распоряжении только две функции: выбирающая первый элемент - head() и выбирающая остаток списка без первого элемента - tail().

@curry(1)
def head(aList):
    return aList[0]

@curry(1)
def tail(aList):
    return aList[1:]

lst = [1,2,3,4]

head(lst) # 1

tail(lst) # [2,3,4]

Тогда каррированная функция, являющаяся композицией этих функций, запишется так:

second = (Compose(tail)
            .then(head))
second(lst) # 1

Сперва вызовется tail() и мы получим список без первого элемента, а затем к этому результату будет применена head() (изъятие первого элемента из этого промежуточного значения), которая по сути вернет второй элемент исходного списка.

Сперва функция tail выделит список [2, 3, 4], а потом из этого промежуточного значения функция head выделит первый элемент 2.

Схожим образом мы можем "составлять" и частично применяемые функции. Например, у нас есть функция сложения двух чисел add, и функция умножения двух чисел mul.

@curry(2)
def add(x, y):
    return x + y

@curry(2)
def mul(x, y):
    return x * y

Что будет, если мы скомпозируем их с частичным применением?

comp = (Compose(add(7))
            .then(mul(2)))
comp(4)

Сперва частично применённая функция add(7) получит второй аргумент 4, после чего она вычислится полностью и выдаст результат 4+7=11. Этот результат 11 поступит на вход частично применённой функции mul(2), которая умножит 11 на 2, и выдаст конечный результат 22.

Отмечу, что композиция частично применённых функций некоммутативна, то есть

f1 * f2 != f2 * f1

Возможно, это одна из причин, почему операция * из ранней версии PyMonad превратилась в более наглядную форму, где последовательность вычислений указывается явно с помощью then.

Однако нам более важна ассоциативность. Важно, что частично применённые функции условно можно считать ассоциативными:

f1 * f2 * f3 = (f1 * f2) * f3 = f1 * (f2 * f3)

На самом деле, так как функции пока реальных вычислений не выполняют, а порядок их комбинирования всегда справа налево, скобки в данном случае значения фактически не играют.

Задание

3.1. Напишите функцию частичного применения tag(), которая получает на вход два строковых параметра: название HTML-тега, и значение. Эта функция оборачивает значение тегом с учётом открывающего и закрывающего тега, например:

tag('b', 'string') # <b>string</b>

На основе tag подготовьте две функции bold и italic, которые оборачивают значение в теги b и i.

3.2. Расширьте функцию tag третьим параметром attr (тип словарь), который добавляет к тегу набор свойств (их может быть несколько).

Например:

tag('li', {'class': 'list-group'}, 'item 23')

Результатом будет

<li class="list-group">item 23</li>



4. Функторы

По мере продвижения к монадам познакомимся с функторами.

Прямое определение функтора излишне академично, поэтому подберёмся к нему с другой стороны. В Python есть стандартная функция map(), которая получает на вход функцию и список, и возвращает этот список, к каждому элементу которого применена входная функция.

Например

map((lambda x: x**2), [1,2,3]) 

вернёт [1,4,9]

В функциональных языках есть также функция fmap(), которая работает аналогично map() с той разницей, что fmap способна принимать на вход любую структуру, и возвращает точно такую же структуру, сохраняя все её внутренние связи. Например, на вход fmap() можно подать двоичное дерево, и вернёт она такое же по структуре двоичное дерево.

Функтор -- это такой тип данных, к которому применима функция fmap(). Она применит поступившую ей на вход функцию к каждому элементу функтора, а сама его структура при этом сохранится.

По сути, вышеупомянутые питоновские тип list и функция map() образуют функтор.

Пока это определение абстрактно и не очень понятно, зачем функторы нужны на практике.

В пакете PyMonad определено несколько стандартных функторов, которые существуют практически во всех функциональных языках.

Это:
Just -- просто обёртка для скалярного значения, превращающая это значение в функтор;
Nothing -- условное обозначение отсутствия значения (или ошибочного значения);
ListMonad -- реализация контейнера для списка (по аналогии с Just).
К сожалению, в новой версии PyMonad они разбрсаны по самым разным модулям.

Например:

Just(12) # функтор-обёртка для значения 12
ListMonad(1,2,3,4,5) # функтор-обёртка для списка [1,2,3,4,5]

Метод map() присущ функтору неотъемлемо. Композиция любой функции f(x) одного аргумента с функтором вернёт такой же функтор (точнее, экземпляр такого же функтор-типа), для каждого элемента которого применена эта функция f().

Определим простую функцию, меняющую знак аргумента:

def neg(x):
    return -x

Стоит теперь ей подать на вход один из наших функторов, как они отлично разберутся друг с другом и вернут корректный функтор!

...
from pymonad.maybe import Just, Nothing

Just(5).then(neg) # Just -5
Nothing.then(neg) # Nothing

Функторы работают с функциями с единственным аргументом, а когда их несколько, надо использовать аппликативные функторы. Они получили такое название из-за того, что стыкуются с помощью аппликации лямбда-исчисления.

В случае аппликативных функторов необходимы каррированные функции, в результате же мы получаем очень наглядный синтаксис. К сожалению, PyMonad в последней версии и тут отошла от выразительного синтаксиса, предложив формат Maybe.apply( функция ).to_arguments(...).

Простая каррированная функция, складывающая два аргумента:

from pymonad.tools import curry
from pymonad.maybe import Maybe, Just, Nothing

@curry(2)
def add(x, y):
    return x + y

Maybe.apply(add).to_arguments(Just(2), Just(3)) # Just 5

Результатом станет сумма Just(5).

Если один из аргументов не определён, будет возвращен Nothing:

Maybe.apply(add).to_arguments(Nothing, Just(3)) # Nothing

Это очень удобно, если например в процессе цепочки вычислений возникла ошибка, и какой-то промежуточный аргумент вычислить не удалось.

Но, казалось бы, зачем же нам функторы, если всё это можно сделать обычными списками или функциями?

Дело в том, что функтор -- это с одной стороны тип данных, но с другой стороны, это функция. В следующем занятии мы познакомимся с монадами и поймём, как эффективнее всего использовать функторы.

Но и сейчас мы можем красиво использовать такую возможность функтора, как упомянутая выше функция map -- она обязательно входит в состав класса функтора. Можно даже сказать, что способность класса применять эту функцию map() к своему содержимому без изменения его структуры и является признаком функтора.

Простой пример. Например, мы хотим изменить знак всех значений в списке с помощью neg(), затем вычислить квадраты значений, и затем преобразовать результаты в строковый тип.

С помощью функции map это делается так:

from pymonad.list import ListMonad

def neg(x):
    return -x
  
ListMonad(1,2,3,4).map(neg) # [-1, -2, -3, -4]

В общем случае, функторы полезны в ситуациях, когда мы работаем со сложными структурами данных (например, деревьями или графами), и хотим применять к ним всевозможные стандартные или прикладные функции. Например, чтобы изменить знак всех элементов в дереве, надо явно прописать код сканирования дерева и изменения значений; даже для схожих структур (например, красно-чёрных деревьев) снова придётся готовить похожий код. А если мы хотим использовать какую-то новую оригинальную функцию -- например, извлечение кубического корня? Снова придётся готовить нужный код.
Объектный подход и наследование тут не помогают, а скорее запутывают, так как в ООП у нас нету готового универсального механизма полиморфической композиции функций.

Правильно же сделать так: создать для каждого из этих структур данных обёртку в виде функтора и переопределить map, и в результате мы сразу сможем "автоматически" строить цепочки вычислений, как в примере выше.

Задание.
Ещё одна мощная фишка функторов -- это возможность использования их в отложенном применении. На основе функции add() сделайте функцию add10() с одним Just-аргументом, которая прибавляет 10 к Just- или List-аргументу. 



5. Монады

Монада в прагматичном смысле, в контексте программирования -- это тип, который позволяет строить цепочки вычислений. Между этими вычислениями передаются только монады, что и делает эти цепочки в некотором смысле универсальными.
Традиционная операция шага такой цепочки называется bind, так же она обозначается и в библиотеке PyMonad.

Первый (левый) аргумент этого оператора -- тип монады. Правый -- это функция, которая получает в качестве параметра обычное значение (не монаду), а возвращает снова монаду. То есть мы как бы прогоняем входную монаду через функцию: оператор bind вытаскивает из входной монады обычное значение и передаёт его функции, а потом оборачивает результат функции обратно в выходную монаду, которую можно передавать далее, следующей функции.

Например, функция получает на вход единственное число, а возвращает список из двух значений: положительного и отрицательного вариантов входного числа.

def positive_and_negative(x):
    return ListMonad(x, -x) 

Подадим на вход оператору bind функтор ListMonad (функтор всегда считается подмножеством монады, как и аппликативный функтор):

ListMonad(9).bind(positive_and_negative) # [9, -9]

Результатом станет монада ListMonad(9, -9).

Для случаев, когда аргументов требуется несколько, задействуем аппликативные функторы:

@curry(2)
def add_and_sub(x, y):
    return ListMonad(y + x, y - x)
  
ListMonad(2).bind(add_and_sub(3)) # [5, -1]

вернёт список ListMonad(5,-1)

add_and_sub() вторым аргументом подцепит монаду ListMonad(2) -- точнее, число 2, автоматически извлечённое из неё операцией bind.

Чуть более сложный пример:

ListMonad(2).bind(positive_and_negative).bind(add_and_sub(3))

Результатом станет ListMonad(5, -1, 1, -5)

Сперва ListMonad(2) после обработки positive_and_negative превратится в ListMonad(2, -2), а затем функция add_and_sub преобразует эту промежуточную монаду-список, удвоив её (в качестве аргумента y выступит ListMonad(2,-2)):

add_and_sub(3, ListMonad(2, -2)) 
# ListMonad(2+3, 2-3, -2+3, -2-3) = ListMonad(5, -1, 1, -5)

Из-за того, что функция, связываемая через bind, должна иметь единственный аргумент, в чистых функциональных языках из монад обычно выстраиваются не очень наглядные цепочки. Например, чтобы с помощью монад сложить два числа 3 и 5 -- без создания внешних функций наподобие add(x,y), надо записать примерно следующее:

Just(3).bind(lambda x: Just(5).bind(lambda y: Just(x + y)))

Пока, казалось бы, функциональный код только создаёт новые проблемы. Однако удивительная мощность заложенного в его основу математического аппарата проявляется не сразу. В частности, огромный потенциал нового синтаксиса открывается в так называемом декларативном программировании.

Декларативным называется такой стиль разработки, когда мы не указываем компьютеру явно, набором последовательных команд, что ему надо делать, а лишь записываем основные правила решаемой задачи, потом начинается функциональная магия, и в заключение мы автоматически получаем нужный результат.

Красивый пример приведён вот в этой статье "Монады в Python поподробнее"
https://habr.com/ru/articles/138676/

Задача: проверить, можно ли из одной указанной точки на шахматной доске достигнуть второй указанной точки ровно за 3 хода конём.

Как бы вы запрограммировали решение в императивном стиле, набором команд? Сперва сгенерировали бы все возможные ходы из текущей позиции с учётом размеров доски, затем в цикле начали бы их перебирать, для каждого хода заново генерировать ходы из новой позиции, снова их перебирать -- и так тремя вложенными циклами. А если нам потребуется узнать, можно ли достигнуть цели за 333 хода? Спасёт только рекурсия.

В статье автор приводит решение с помощью эмуляции монад, которая сделана "на коленке" и операцию bind явно не поддерживает. В результате пришлось придумывать искусственный ненаглядный синтаксис. Однако в PyMonad монады реализованы полноценно, поэтому перепишем оригинальный вариант так:

raw_jumps = lambda x: ListMonad(
    (x[0] + 1, x[1] + 2),
    (x[0] + 1, x[1] - 2),
    (x[0] - 1, x[1] + 2),
    (x[0] - 1, x[1] - 2),
    (x[0] + 2, x[1] + 1),
    (x[0] + 2, x[1] - 1),
    (x[0] - 2, x[1] + 1),
    (x[0] - 2, x[1] - 1),
)

if_valid = lambda x: ListMonad( (x[0], x[1]) ) if 1 <= x[0] <= 8 and 1 <= x[1] <= 8 
    else ListMonad()

jump = (lambda pos: ListMonad(pos).bind(raw_jumps).bind(if_valid))

in3jumps = lambda pos_from, pos_to: pos_to in (
    ListMonad(pos_from).bind(jump).bind(jump).bind(jump))

print( in3jumps((3,3), (5,1)) ) # False
print( in3jumps((3,3), (5,2)) ) # True

Это всё! Обратите внимание, что мы по сути вообще не программировали логику перебора ходов. Нам достаточно объединить в цепочку вычислений генерацию ходов -- функцию jump, затем корректные ходы фильтруются функцией if_valid, и всё. Все комбинации вариантов, стыковки и другие промежуточные вычисления произойдут автоматически.

Задание.
В статье есть вторая задача про канатоходца, тоже по сути в декларативном стиле. Перепишите её на работу с PyMonad.
Обратите внимание, что, во-первых, поле .result (извлечение данных из функтора) в оригинальном примере надо заменить на метод getValue() (в последней версии PyMonad он вроде был заменён на прямой доступ к полю value, как раньше был result), и во-вторых, в функции вывода результата show() случай, когда канатоходец упал, выявляется простой проверкой параметра maybe на равенство Nothing. Если канатоходец держится нормально, то результат будет представлен в виде функтора Just(), который обёртывает список из двух элементов (сколько птиц слева и сколько птиц справа). 


6. Монады состояний

Как мы выяснили, монады -- это на самом деле весьма простая вещь в программировании, но при этом крайне удобная! Ведь в её основу заложены мощные математические механизмы.

Последнее, что нам осталось изучить -- это монады состояний. Они "оборачивают", в отличие от обычных монад-контейнеров значений, не данные, а наоборот -- функции. Причём не все функции, а только такие, которые получают на вход некоторое состояние (экземпляр любого определённого типа), а выдают условный список из двух элементов: результат своей работы и результирующее состояние (вспомним проблему с функциями Sin и Cos из первых уроков).
Из этого описания практически сразу понятно, зачем нужны такие монады состояний: фактически, совершенно произвольная цепочка обработки завершится предсказуемо и однозначно, при этом мы получим как результат процесса вычислений, так и изменённое состояние.

Сконструировать функцию, оборачиваемую монадой состояний, можно так: объявить её при необходимости каррированной, и задействовать конструктор State внутри в качестве возвращаемого значения.

Как сформировать начальное значение для цепочки функций, использующей State? Другими словами, монада должна уметь оборачивать сырое значение в себя. В функциональном программировании такую операцию обозначают return, и за счёт развитого полиморфизма специально её переопределять для каждого монадического класса не надо (компилятор поймёт тип возвращаемого значения по контексту).
В PyMonad используется синтаксис

переменнная = State.insert(начальное значение)

(К большому сожалению, та элегантность и простота, которая сопутствовала ранней версии PyMonad, из нынешней версии ушла, и документация почти отстутствует).

Один из классических примеров удобства монад состояний как паттерна программирования -- это планирование финансовых действий, когда мы изменяем состояние некоторого банковского счёта. Мы не хотим из соображений безопасности явно в коде обрабатывать значение денег на этом счету -- например, нежелательно сохранять его в каких-то промежуточных переменных.

С помощью монады состояний мы можем определить такую операцию, как покупка некоторого товара, который является результатом функции КупитьТовар(идентификатор-товара). На её выходе мы получим сам товар (или "вычисляемый" список купленных товаров, расширяемый очередным товаром) -- и, главное, гарантированно корректное изменённое состояние счёта, которое ни внешне недоступно, ни внутренне нигде не хранится, так как каждая функция -- чистая (без побочных эффектов). Зафиксировать итоговое значение счёта, например, в базе данных, можно однократно в заключение всех вычислений.
Мы можем теперь подробно описать произвольно сложный план действий со счётом, вообще не используя никаких явных промежуточных хранилищ данных для состояния счёта.

При этом сама цепочка вычисляется только в момент её прямого вызова, а до этого благодаря концепции ленивых вычислений просто хранится как набор операций, за счёт чего можно создавать библиотеки красивых декларативных планов действий, где многие сложные моменты можно спрятать внутрь автоматической механики вычислений.

После того, как монада состояний была создана с начальным значением, мы можем выстраивать подобные цепочки вызовов с помощью метода then(), а итоговое значение получается вызовом метода run уже для самой цепочки.

from pymonad.tools import curry
from pymonad.state import State

user_init = {'items': [], 'money': 2000}

items = {'apples': 70,
         'wine': 300,
         'milk': 80,
         'chips': 100
         }
    
user_state = State.insert(user_init['items'])


@curry(2)
def buy(item_key, user_items):
    def count_computation(money_remained):
        return user_items + [item_key], money_remained - items[item_key]
    return State(count_computation)

finale = user_state.then(buy('wine')).then(buy('apples')).then(buy('chips'))
                   .then(buy('chips')).then(buy('milk'))

finale.run(user_init['money']) # (['wine', 'apples', 'chips', 'chips', 'milk'], 1350)

Придумайте сами какую-нибудь задачку с решением с помощью State Monad.



Чуть-чуть практики

Давайте возьмём задачку "Тренировка десантников" с одного из начальных курсов "28 задач". Напомню, вот она тут.

Алгоритм решения в первом приближении раскладывается на три шага:
1) начальная расстановка;
2) моделирование одного дня захвата;
3) проверка на окончание.

Тут возникает очень интересный вопрос: как нам в ФП "без цикла" проверить, что моделирование окончено? Главная проблема, что мы не можем (точнее, это будет достаточно сложно) построить точную математическую модель процесса захвата, и в общем случае для ряда задач это далеко не всегда возможно в принцие. Поэтому мы не можем просто взять и вычислить результат с помощью некоторой последовательности функций -- надо выполнить моделирование основного процесса.

Для подобного класса задач (и фактически только для него!) в функциональном программировании существует аналог условного цикла, семантически реализующий хвостовую рекурсию. Это просто бесконечный цикл без какого-либо условия завершения или количества выполнений. Что интересно, в Smalltalk -- оригинальном языке, с которого по сути началось развитие объектно-ориентированного программирования в нынешнем виде, не существовало циклов for/while, а только бесконечная конструкция-метод whileTrue. Ну и кроме того, обычно допускаются итераторы (перебор элементов списка), хотя это всегда лучше выполнять с помощью map/reduce/filter.

Попробуйте решить эту задачу, не используя циклы, только с помощью функциональных возможностей. 


Чуть-чуть практики - 2 (reduce)

В современной версии Python нету встроенной реализации reduce, однако существует стандартная библиотека functools для работы с функциями высших порядков. В её составе имеется reduce. Первый параметр reduce() -- лямбда-функция, применяемая к содержимому списка, следующему вторым параметром. Обратите внимание, что начальное значение для reduce, задаваемое третьим параметром, не обязательно.

Для примера, совсем элементарная задачка по вычислению факториала, которую вы наверняка решали и императивно, и рекурсивно.

Факториал числа N -- это перемножение всех последовательных целых чисел от 1 до N.

Тогда алгоритм, использующий reduce для нахождения факториала, будет такой:
1) генерируем список/массив целых чисел;
2) перемножаем все эти числа между собой;

Пп. 1 решается стандартно.

1) генерируем список/массив целых чисел.

Python

В питоне генерация списка (List comprehensions ) по некоторой закономерности реализуется совсем просто.

Общая структура такая:

[ выражение for переменная ... ]

где вместо многоточия может следовать произвольное количество for и if.

Переменная принимает последовательные значения в заданном диапазоне, при этом могут применяться условия, в каком случае она выбирается, и затем в список добавляется очередное значение, вычисленное по начальному выражению, включающему эту переменную.

Например

[ i+1 for i in range(100) ]

сгенерирует список из 100 чисел от 1 до 100.

Java

В Java 8 появилось понятие потока Stream, которое специально ориентировано на решение задач с помощью функций высших порядков. Поток (строго говоря, монада из функционального программирования) проще всего трактовать как последовательность элементов, над которым можно выполнять различные операции. Для нашего случая подойдёт тип IntStream -- поток целых чисел. Его метод rangeClose() принимает два параметра -- начальное и конечное включённые значения диапазона, и выдаёт последовательность целых чисел между ними.

IntStream.rangeClosed(2, 100) выдаст поток из 99 чисел от 2 до 100.

C#

В C# имеется интерфейс IEnumerable (из семейства технологий языка запросов LINQ) для работы с коллекциями, и множество методов для работы с ним.
(Эти методы применимы и к обычным массивам)

Статический метод Range() типа Enumerable (перечислимая коллекция) принимает два параметра -- начальное значение и количество элементов в диапазоне, и выдаёт соответствующую последовательность целых чисел.

Enumerable.Range(2, 4) выдаст последовательность 2,3,4,5.

А вот п. 2 без циклов реализуется обычно с помощью подходящей функции высшего порядка (HOF), которая в computer science традиционно называется reduce.

Функция высшего порядка -- это функция, принимающая в качестве аргумента другую функцию.

В частности, reduce получает на вход список, начальное значение и функцию двух аргументов, и последовательно применяет эту функцию к начальному значению и первому элементу списка, затем к этому результату и второму элементу списка, и т. д. Другими словами, эта функция "вставляется" между элементами списка. Например, если это функция умножения * , и у нас есть список [2,3,4], то вызов reduce(1, [2,3,4], *) эквивалентен выражению 1 * 2 * 3 * 4 -- точнее, (((1*2) * 3) * 4).

= Надо учитывать в каждой конкретной реализации, как работает reduce (слева направо или справа налево), потому что далеко не все допустимые тут операции коммутативны. Например, (((1-2) - 3) - 4) не то же самое, что (1- (2 - (3 - 4))).

Итоговое решение (факториал числа 5):

Python

functools.reduce(lambda a,b : a*b, [x+1 for x in range(5)])

Java 8

Метод IntStream.rangeClosed() также возвращает поток IntStream, что позволяет применять к результату другие функции, ориентированные на обработку потоков -- то есть выстраивать последовательные цепочки вычислений.

Метод IntStream.reduce() первым параметром получает обязательное начальное значение, а вторым -- лямбда-функцию, реализующую функциональный интерфейс бинарного оператора IntBinaryOperator.

Итоговое решение (факториал числа 5):

IntStream.rangeClosed(2, 5).reduce(1, (x1, x2) -> x1*x2);

C#

Метод Enumerable.Range() также возвращает перечислимую коллекцию Enumerable, что позволяет применять к результату другие функции, ориентированные на обработку потоков -- то есть выстраивать последовательные цепочки вычислений.

Метод Enumerable.Aggregate() реализован в нескольких версиях -- с начальным значением (аккумулятором) или без него. В самом простом случае он просто получает параметром функцию, вызываемую для каждого элемента коллекции.

Итоговое решение (факториал числа 5):

Enumerable.Range(2, 4).Aggregate((x,y) => x*y);

Напишите с помощью reduce функцию нахождения второго максимального числа.
Второе макс. -- это когда отсортировали список и берём второй элемент (отсчитывая с 1), если 5,4,3,2,5 например, то второе макс. должно получиться 5.
В самом решении, конечно, никаких сортировок быть не должно. 


Чуть-чуть практики - 3

Вернёмся назад к ещё более простой задачке.
---

Поездка на мотоцикле

Олег катает Оксану на мотоцикле. Счётчик километража на мотоцикле не работает, но Оксана следит за временем в поездке, и за текущей скоростью. Олег хочет установить рекорд дальности совместной поездки, и просит Оксану выяснить километраж.

Функция

int odometer(int [] oksana) 

получает параметром массив N целых чисел (N >= 2) с индексацией с нуля, в котором каждый элемент с чётным индексом содержит скорость в километрах в час, а каждый элемент с нечётным индексом содержит время, прошедшее с начала поездки, в часах.

Возвращает функция общее пройденное расстояние.

Например, на входе массив [10,1,20,2], на выходе расстояние 30.
----

Возможный алгоритм решения в стиле ФП такой:
1) отфильтровываем значения времён, прошедших с начала поездки, и считаем для каждого изменения скорости количество часов (дельту), когда Олег ехал на этой скорости.
2) отфильтровываем скорости, и умножаем их на время езды на этих скоростях (список на список).
3) суммируем список полученных расстояний с помощью reduce.

Например, есть входной список [15,1,25,2,30,3,10,5].
На первом шаге мы отфильтровываем значения в чётных позициях [1,2,3,5] и получаем дельты часов [1,1,1,2].
На втором шаге отфильтровываем значения в нечётных позициях [15,25,30,10] и умножаем на [1,1,1,2], получая [15,25,30,20].
На последнем шаге суммируем [15,25,30,20], и получаем 90 км.

Фильтрация значений списка по индексам -- это задача классического программирования, а не функционального, где вообще работа с индексами редка. Однако как же это можно реализовать? Функции, передающиеся в HOF-функции, получают на обработку некоторые абстрактные значения, о положении которых внутри списка ничего не известно.

Возможный вариант такой: сперва мы формируем, например, список только нечётных индексов, и затем отбираем из исходного списка только значения по этим индексам.

1-й шаг.

Вообще, данная фильтрация решается стандартно с помощью слайсов:

lst = [15,1,25,2,30,3,10,5]
tim = lst[1::2] # список из значений с нечётными индексами 
spd = lst[0::2] # список из значений с чётными индексами 

Более сложный вариант:

i1 = [ i*2+1 for i in range(len(lst) // 2) ]  
tim = [lst[i] for i in i1]
i2 = [ i*2 for i in range(len(lst) // 2) ]  
spd = [lst[i] for i in i2]

Как получить список, хранящий разницу между элементами (количество часов езды на текущей скорости)? Функция, передающаяся в HOF-функцию, может применяться лишь к некоторому абстрактному элементу массива, мы не знаем ни его индекс, ни его соседей. Своеобразный хак здесь -- выполнить вычитание оригинального списка из списка, сдвинутого на один вперёд. Например, в tim мы получили список [1,2,3,5], и чтобы получить список разниц [1,1,1,2], надо из этого списка вычесть список [0,1,2,3] (последний ненужный элемент мы отбрасываем).

Вопрос, как же вычислить разность или произведение двух списков?

В этом поможет HOF-функция Map. Она получает параметрами функцию и список (или несколько списков), и применяет эту функцию к каждому элементу списка (или к соответствующим элементам всех списков). На выходе получается список такой же длины, как и исходный.

Например, мы хотим увеличить все значения в списке в два раза.

n = [1, 2, 3, 4] 
res = map(lambda x: x * 2, n) 

В Python функция map() возвращает map-объект, который дополнительно надо явно привести к типу list().

print(list(res))

В нашем случае поиска разностей лямбда-функция потребует два аргумента:

map(lambda x,y: x - y, ..., ...))

Что из чего вычитать? Из tim[1:] (все элементы списка, начиная со второго) надо вычесть tim[:-1] (все элементы списка, кроме последнего), и, так как результат будет короче оригинального списка, к результату в начало добавить первый элемент tim, который уже сам по себе есть сдвиг времени, прошедший с нуля.

diff = [tim[0]] + list(map(lambda x,y: x - y, tim[1:], tim[:-1])) # [1,1,1,2]

Теперь перемножим этот список дельты времени и скоростей с помощью map:

res = list(map(lambda x,y: x * y, diff, spd)) # [15,25,30,20]

И наконец вычислим сумму пройденных расстояний с помощью reduce:

functools.reduce(lambda a,b : a + b, res)

Попробуйте написать более элегантную версию решения этой задачки с помощью любых функциональных инструментов. 



Курс успешно закончен!

Поизучайте также мой цикл статей про распределённые системы и про монаду, которая моноид в категории эндофункторов:
https://vk.com/wall-152484379_3672
https://vk.com/wall-152484379_3673
https://vk.com/wall-152484379_3676
https://vk.com/wall-152484379_3679
https://vk.com/wall-152484379_3682
https://vk.com/wall-152484379_3683

Далее вы познакомитесь с ФП более глубоко -- на примере "официального" функционального языка F#.

Подробно разбираем 22 темы (теория + примеры), решая задачи как на курсах по АСД. 