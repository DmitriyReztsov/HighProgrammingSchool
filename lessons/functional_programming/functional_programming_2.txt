
1. монада -- это моноид в категории эндофункторов

"Ещё один туториал по монадам" -- на эту тему есть классическая шутка Haskell-программистов. Дескать, это обязательный путь каждого хаскель-разработчика.

Как известно, "монада -- это моноид в категории эндофункторов". Этот легендарный мем можно найти на куче форумов. В оригинале он звучит так: "A Monad is just a monoid in the category of endofunctors", и получил массовость, будучи упомянут в 2009 г. в шутливой анти-истории программирования "Brief, Incomplete and Mostly Wrong History of Programming Languages" от JamesIry. Но эти темы на самом деле относятся к теории категорий и абстрактной алгебре.
Подробно для программистов я разбирал эту тему в сериале https://vk.com/wall-152484385_3687

В программировании же под монадой понимают не очень корректный в математическом плане шаблон: это некий контейнер (обёртка) для функций, который скрывает внутри себя любые побочные эффекты. За счёт этого из таких контейнеров можно выстраивать цепочки вычислений, не опасаясь, что она где-то прервётся с ошибкой. В худшем случае такая цепочка контейнеров (монад) вернёт признак отсутствия значения (например, None).
(На самом деле, обёртка/контейнер -- это тоже неверное определение монады, чрезмерно упрощённое ради понимания на уровне джуниоров; монада -- это скорее про вычисления)

В императивном программировании для реализации такого подхода всё содержимое каждой функции, претендующей на роль монады (точнее, аппликативного функтора (см. далее) -- более "слабой" в математическом смысле модели), надо охватить блоком try-catch. Также надо проверять, не вернула ли уже предыдущая функция некий условный код ошибки, чтобы сразу же передать его по цепочке дальше. В итоге код получается разбухшим и совсем не наглядным.

Подходящим монада-шаблоном, в принципе, достаточно считать функцию-контейнер, получающую на вход наш условный "монадический" тип данных, и возвращающую его же на выходе. Конкретные результаты вычислений извлекаются из такого типа особым образом. Тогда мы можем абсолютно безопасно выстраивать произвольные цепочки вычислений (ленивые, параллельные, асинхронные, …) из таких контейнеров, совершенно не опасаясь каких-либо побочных эффектов.

Например, при проектировании сложных систем такой подход (в частности, концепция монад состояний, state monads, рассматриваемая далее) позволяет полностью избавиться от временных состояний, как на клиентской, так и на серверной сторонах.

2. Инсталлируем монады

Примеры мы будем рассматривать на Python с помощью небольшой библиотеки PyMonad, которая реализует как монады, так и сопутствующие абстракции -- функторы и аппликативные функторы, с которыми мы познакомимся в ходе курса. Она устанавливается тривиально:

pip install PyMonad

Рассмотрим простой пример, который поясняет прикладную необходимость монад. Подобные моменты постоянно встречаются в практическом программировании.

Например, мы вызываем функцию sin(), которая всегда возвращает одно значение, синус аргумента. Но, допустим, мы хотим знать не только результат вычислений, но и количество вызовов этой функции.

Вот как можно реализовать эту схему:

from math import pi, sin as _sin

def sin(theta, state):
    return (_sin(theta), state + 1)

Переменная count работает тут как счётчик, однако огромный недостаток данного подхода в том, что мы храним временное значение -- заводим изменяемые, мутабельные объекты.

Условно говоря, мы получим что-то вроде

(x, count) = sin(pi, 0)
(x, count) = sin(pi/2, count)
(x, count) = sin(pi/4, count)

но это, очевидно, абсурдный способ.

Можно добавить в модуль глобальный счётчик:

sin_counter = 0

def sin(theta):
    global sin_counter
    sin_counter = sin_counter + 1
    return _sin(theta)

x1 = sin(pi) 
x2 = sin(pi/2)
x3 = sin(pi/4)

но такой подход (инъекция внешних зависимостей) считается абсолютно вредным.

Далее напрашивается классический вариант из объектно-ориентированного программирования: объявим класс sin и например метод compute(), который при каждом вызове вернёт значение синуса от аргумента, и при этом увеличит внутренний счётчик на единицу. Также понадобится метод get_count() для получения его значения.

Минус этого подхода, во-первых, в том, что даже для такой тривиальной задачи потребуется написать довольно много кода, объявить новый тип данных Sin, и хранить внутри него мутабельное значение, текущее состояние. А во-вторых, и это самое главное, если мы захотим таким же способом определить косинус, нам придётся либо копипастой создавать копию класса Sin, либо создавать иерархию и наследовать наши Sin и Cos.

А если нам далее потребуется строить из подобных классов цепочки вызовов, по которым нужна статистика, сколько раз в рамках такой цепочки было сделано вычислений? И в эти цепочки желательно также включать и совсем сторонние вычисления... Такая исходно совсем простая задача по мере развития требований резко усложняется практически на ровном месте. Как же тут можно подстелить побольше соломки?

Контрольные вопросы.

1. Возьмите для примера какой-нибудь свой проект и подумайте, где и как в нём можно было бы избавиться от хранения промежуточных результатов и использования промежуточных переменных.

В модуле, который возвращает рассчитанные значения из хранимых в базе полей можно было бы переводить эти значения в тип данных, возвращающий либо None, либо значение. В том же типе можно заменять пустые значения из БД на 0.

Например, такой метод

def get_total_gross_invoice_rate(self) -> Optional[int]:
    invoice_amount = self.invoice_amount
    if not invoice_amount:
        return None

    discount_fee = self.discount_amount or 0
    admin_fee = self.admin_fee_amount or 0

    invoice_rate_percentage = (discount_fee + admin_fee) / invoice_amount * 100
    ...

В нем можно было бы перевести все суммы в свой класс, и перегрузить арифметические операторы:

class Amount:
    def __init__(self, value, error = 0):
        self.error = error
        if error:
            self.value = None
        else:
            self.value = value or 0

    def __add__(self, other):
        try:
            return Amount(self.value + other.value, 0)
        except Exception:
            retutn Amount(None, 1)

    def __truediv__(self, other):
        try:
            return Amount(self.value / other.value, 0)
        except Exception:
            retutn Amount(None, 1)

тогда нам не надо было бы хранить промежуточные переменные и метод преобразовался бы просто в строчку типа:

def get_total_gross_invoice_rate(invoice_amount: Amount, discount_fee: Amount, admin_fee: Amount) -> Amount:
    invoice_rate_percentage = (discount_fee + admin_fee) / invoice_amount * 100
    ...
    

2. Подумайте, как в принципе может быть устроена архитектура сложной системы, где промежуточные состояния вычислений вообще никак не хранятся в явном виде (за исключением каких-то специфичных настроек). 

И, видимо, нам нужен дополнительный слой, где будут храниться такие типы данных (определения классов).


2. Синтаксическая соломка

Совсем скоро станет понятно, что класс проблем, упомянутых в первом задании, прекрасно решается с помощью монад. Но мы подойдём к этому понятию постепенно, рассматривая важные сопутствующие понятия. Прежде всего это карринг (в математике под ним понимается замыкание для моноидов, но к программированию оно не имеет отношения) и частичное применение.

2.1. Карринг

Карринг декомпозирует функцию многих переменных на функцию от одного аргумента. Другими словами, мы от одного вызова функции с N переменными переходим к N вызовам функций с одной переменной (аргументом). Мы берём первый аргумент, комбинируем его с функцией, и возвращаем функцию с этим аргументом. Пока другие аргументы ещё неизвестны, поэтому возвращено будет, конечно, не какое-то значение, а просто отложенный вызов функции (так как вычислять пока нечего, мы не знаем всех аргументов). Далее переходим к следующему аргументу, комбинируем его с предыдущей функцией, и повторяем эту операцию, получая на выходе N вложенных вызовов.

Еще раз отмечу, что карринг в конечном итоге возвращает функцию (ссылку на временную последовательность вычислений в памяти), а не на результат ее работы -- то есть её в заключение надо вызвать явно, чтобы она вычислилась. Хотя в чистых функциональных языках (например, Haskell) все функции по умолчанию каррированы.

Библиотека PyMonad предоставляет декоратор curry, который превращает обычную функцию в каррированную. Параметром curry указывается количество параметров у каррированной функции. Например, есть функция add, вычисляющая сумму двух своих аргументов:

from pymonad.tools import curry

@curry(2)
def add(x, y): 
    return x + y

add(2,3) # 5 

Но так как add() каррированная, мы можем также записать

add(3)

Что она вычислит? Ничего, возвращена будет некая промежуточная функция, так как числа аргументов недостаточно для полного расчёта. В частности,

f = add(3)
type(f).__name__

вернёт function -- это специальный каррированный тип функции из PyMonad.

И тут сразу начинается магия!

В терминологии функционального программирования мы "замораживаем" аргумент 3, и дальше можем использовать такую промежуточную функцию, например, для увеличения другого аргумента на три:

add3 = add(3) # add3 - функция

Зато add3 мы можем использовать для финального вычисления:

add3(2) # 5

2.2. Частичное применение

Следующее важное понятие -- это частичное применение. Оно представляет собой общий случай карринга -- возможность промежуточного/вложенного вызова функций не только с одним аргументом, но и с произвольным числом.

PyMonad не делает различия между их количеством, декоратор curry универсальный.

Пусть функция add_3() складывает все три свои аргумента:

@curry(3)
def add_3(x, y, z): 
    return x + y + z

Можно вызвать её со всеми аргументами:

add_3(2,3,5)

и сразу получить 10. Либо можно частично её применить -- вызвать

add_3(2,3)

Сохраним такую функцию:

add23 = add_3(2,3)

Теперь функция add23() ожидает единственный, последний аргумент:

add23(5)

В результате мы получим 10.

Форма комбинации аргументов допускается произвольная!

add_3(2)(3,5)
add_3(2,3)(5)
add_3(2)(3)(5)

2.3. Задания

2.3.1. Напишите каррированную функцию с двумя строковыми параметрами, которая вычисляет их сцепленное значение. Создайте на её основе функцию, которая получает один параметр и возвращает

Hello, значение-параметра

Это требуется, чтобы можно было выводить стандартное приветствие, задавая только имя.

2.3.2. Придумайте функцию, которая получает на вход четыре аргумента: слово привествия, знак препинания за ним, имя приветствуемого, и заключительный знак.

Как сделать так, чтобы вариант её частичного применения получал бы в качестве единственного параметра только имя, а все остальные параметры настраивались бы другим вызовом?

Например:

final = first_step("Hello")(",")("!")
final("Petya")

Результатом будет

Hello, Petya!



3. Композиция функций

Композиция функций естественно расширяет принцип карринга.

Каррированные функции можно не только запоминать для последующего использования с нужным числом аргументов, но и, как стало ясно из последнего примера с комбинированием списков аргументов, "составлять" (compose) друг с другом. Таким образом результат вычисления одной функции передаётся на вход другой.

В предыдущих версиях PyMonad была очень удобная операция композиции функций * , когда сперва вычисляется самый правый аргумент, затем этот результат передаётся на вход левой функции, и так далее. Однако начиная с версии 1.3 автор существенно изменил синтаксис, видимо, стараясь сделать его более наглядным, но...

Теперь используется специальная функция Compose:

from pymonad.reader import Compose

Она выполняет подобную комбинацию явными синтаксическими конструкциями. Например, мы хотим получить второй элемент списка, а у нас в распоряжении только две функции: выбирающая первый элемент - head() и выбирающая остаток списка без первого элемента - tail().

@curry(1)
def head(aList):
    return aList[0]

@curry(1)
def tail(aList):
    return aList[1:]

lst = [1,2,3,4]

head(lst) # 1

tail(lst) # [2,3,4]

Тогда каррированная функция, являющаяся композицией этих функций, запишется так:

second = (Compose(tail)
            .then(head))
second(lst) # 1

Сперва вызовется tail() и мы получим список без первого элемента, а затем к этому результату будет применена head() (изъятие первого элемента из этого промежуточного значения), которая по сути вернет второй элемент исходного списка.

Сперва функция tail выделит список [2, 3, 4], а потом из этого промежуточного значения функция head выделит первый элемент 2.

Схожим образом мы можем "составлять" и частично применяемые функции. Например, у нас есть функция сложения двух чисел add, и функция умножения двух чисел mul.

@curry(2)
def add(x, y):
    return x + y

@curry(2)
def mul(x, y):
    return x * y

Что будет, если мы скомпозируем их с частичным применением?

comp = (Compose(add(7))
            .then(mul(2)))
comp(4)

Сперва частично применённая функция add(7) получит второй аргумент 4, после чего она вычислится полностью и выдаст результат 4+7=11. Этот результат 11 поступит на вход частично применённой функции mul(2), которая умножит 11 на 2, и выдаст конечный результат 22.

Отмечу, что композиция частично применённых функций некоммутативна, то есть

f1 * f2 != f2 * f1

Возможно, это одна из причин, почему операция * из ранней версии PyMonad превратилась в более наглядную форму, где последовательность вычислений указывается явно с помощью then.

Однако нам более важна ассоциативность. Важно, что частично применённые функции условно можно считать ассоциативными:

f1 * f2 * f3 = (f1 * f2) * f3 = f1 * (f2 * f3)

На самом деле, так как функции пока реальных вычислений не выполняют, а порядок их комбинирования всегда справа налево, скобки в данном случае значения фактически не играют.

Задание

3.1. Напишите функцию частичного применения tag(), которая получает на вход два строковых параметра: название HTML-тега, и значение. Эта функция оборачивает значение тегом с учётом открывающего и закрывающего тега, например:

tag('b', 'string') # <b>string</b>

На основе tag подготовьте две функции bold и italic, которые оборачивают значение в теги b и i.

3.2. Расширьте функцию tag третьим параметром attr (тип словарь), который добавляет к тегу набор свойств (их может быть несколько).

Например:

tag('li', {'class': 'list-group'}, 'item 23')

Результатом будет

<li class="list-group">item 23</li>



4. Функторы

По мере продвижения к монадам познакомимся с функторами.

Прямое определение функтора излишне академично, поэтому подберёмся к нему с другой стороны. В Python есть стандартная функция map(), которая получает на вход функцию и список, и возвращает этот список, к каждому элементу которого применена входная функция.

Например

map((lambda x: x**2), [1,2,3]) 

вернёт [1,4,9]

В функциональных языках есть также функция fmap(), которая работает аналогично map() с той разницей, что fmap способна принимать на вход любую структуру, и возвращает точно такую же структуру, сохраняя все её внутренние связи. Например, на вход fmap() можно подать двоичное дерево, и вернёт она такое же по структуре двоичное дерево.

Функтор -- это такой тип данных, к которому применима функция fmap(). Она применит поступившую ей на вход функцию к каждому элементу функтора, а сама его структура при этом сохранится.

По сути, вышеупомянутые питоновские тип list и функция map() образуют функтор.

Пока это определение абстрактно и не очень понятно, зачем функторы нужны на практике.

В пакете PyMonad определено несколько стандартных функторов, которые существуют практически во всех функциональных языках.

Это:
Just -- просто обёртка для скалярного значения, превращающая это значение в функтор;
Nothing -- условное обозначение отсутствия значения (или ошибочного значения);
ListMonad -- реализация контейнера для списка (по аналогии с Just).
К сожалению, в новой версии PyMonad они разбрсаны по самым разным модулям.

Например:

Just(12) # функтор-обёртка для значения 12
ListMonad(1,2,3,4,5) # функтор-обёртка для списка [1,2,3,4,5]

Метод map() присущ функтору неотъемлемо. Композиция любой функции f(x) одного аргумента с функтором вернёт такой же функтор (точнее, экземпляр такого же функтор-типа), для каждого элемента которого применена эта функция f().

Определим простую функцию, меняющую знак аргумента:

def neg(x):
    return -x

Стоит теперь ей подать на вход один из наших функторов, как они отлично разберутся друг с другом и вернут корректный функтор!

...
from pymonad.maybe import Just, Nothing

Just(5).then(neg) # Just -5
Nothing.then(neg) # Nothing

Функторы работают с функциями с единственным аргументом, а когда их несколько, надо использовать аппликативные функторы. Они получили такое название из-за того, что стыкуются с помощью аппликации лямбда-исчисления.

В случае аппликативных функторов необходимы каррированные функции, в результате же мы получаем очень наглядный синтаксис. К сожалению, PyMonad в последней версии и тут отошла от выразительного синтаксиса, предложив формат Maybe.apply( функция ).to_arguments(...).

Простая каррированная функция, складывающая два аргумента:

from pymonad.tools import curry
from pymonad.maybe import Maybe, Just, Nothing

@curry(2)
def add(x, y):
    return x + y

Maybe.apply(add).to_arguments(Just(2), Just(3)) # Just 5

Результатом станет сумма Just(5).

Если один из аргументов не определён, будет возвращен Nothing:

Maybe.apply(add).to_arguments(Nothing, Just(3)) # Nothing

Это очень удобно, если например в процессе цепочки вычислений возникла ошибка, и какой-то промежуточный аргумент вычислить не удалось.

Но, казалось бы, зачем же нам функторы, если всё это можно сделать обычными списками или функциями?

Дело в том, что функтор -- это с одной стороны тип данных, но с другой стороны, это функция. В следующем занятии мы познакомимся с монадами и поймём, как эффективнее всего использовать функторы.

Но и сейчас мы можем красиво использовать такую возможность функтора, как упомянутая выше функция map -- она обязательно входит в состав класса функтора. Можно даже сказать, что способность класса применять эту функцию map() к своему содержимому без изменения его структуры и является признаком функтора.

Простой пример. Например, мы хотим изменить знак всех значений в списке с помощью neg(), затем вычислить квадраты значений, и затем преобразовать результаты в строковый тип.

С помощью функции map это делается так:

from pymonad.list import ListMonad

def neg(x):
    return -x
  
ListMonad(1,2,3,4).map(neg) # [-1, -2, -3, -4]

В общем случае, функторы полезны в ситуациях, когда мы работаем со сложными структурами данных (например, деревьями или графами), и хотим применять к ним всевозможные стандартные или прикладные функции. Например, чтобы изменить знак всех элементов в дереве, надо явно прописать код сканирования дерева и изменения значений; даже для схожих структур (например, красно-чёрных деревьев) снова придётся готовить похожий код. А если мы хотим использовать какую-то новую оригинальную функцию -- например, извлечение кубического корня? Снова придётся готовить нужный код.
Объектный подход и наследование тут не помогают, а скорее запутывают, так как в ООП у нас нету готового универсального механизма полиморфической композиции функций.

Правильно же сделать так: создать для каждого из этих структур данных обёртку в виде функтора и переопределить map, и в результате мы сразу сможем "автоматически" строить цепочки вычислений, как в примере выше.

Задание.
Ещё одна мощная фишка функторов -- это возможность использования их в отложенном применении. На основе функции add() сделайте функцию add10() с одним Just-аргументом, которая прибавляет 10 к Just- или List-аргументу. 



5. Монады

Монада в прагматичном смысле, в контексте программирования -- это тип, который позволяет строить цепочки вычислений. Между этими вычислениями передаются только монады, что и делает эти цепочки в некотором смысле универсальными.
Традиционная операция шага такой цепочки называется bind, так же она обозначается и в библиотеке PyMonad.

Первый (левый) аргумент этого оператора -- тип монады. Правый -- это функция, которая получает в качестве параметра обычное значение (не монаду), а возвращает снова монаду. То есть мы как бы прогоняем входную монаду через функцию: оператор bind вытаскивает из входной монады обычное значение и передаёт его функции, а потом оборачивает результат функции обратно в выходную монаду, которую можно передавать далее, следующей функции.

Например, функция получает на вход единственное число, а возвращает список из двух значений: положительного и отрицательного вариантов входного числа.

def positive_and_negative(x):
    return ListMonad(x, -x) 

Подадим на вход оператору bind функтор ListMonad (функтор всегда считается подмножеством монады, как и аппликативный функтор):

ListMonad(9).bind(positive_and_negative) # [9, -9]

Результатом станет монада ListMonad(9, -9).

Для случаев, когда аргументов требуется несколько, задействуем аппликативные функторы:

@curry(2)
def add_and_sub(x, y):
    return ListMonad(y + x, y - x)
  
ListMonad(2).bind(add_and_sub(3)) # [5, -1]

вернёт список ListMonad(5,-1)

add_and_sub() вторым аргументом подцепит монаду ListMonad(2) -- точнее, число 2, автоматически извлечённое из неё операцией bind.

Чуть более сложный пример:

ListMonad(2).bind(positive_and_negative).bind(add_and_sub(3))

Результатом станет ListMonad(5, -1, 1, -5)

Сперва ListMonad(2) после обработки positive_and_negative превратится в ListMonad(2, -2), а затем функция add_and_sub преобразует эту промежуточную монаду-список, удвоив её (в качестве аргумента y выступит ListMonad(2,-2)):

add_and_sub(3, ListMonad(2, -2)) 
# ListMonad(2+3, 2-3, -2+3, -2-3) = ListMonad(5, -1, 1, -5)

Из-за того, что функция, связываемая через bind, должна иметь единственный аргумент, в чистых функциональных языках из монад обычно выстраиваются не очень наглядные цепочки. Например, чтобы с помощью монад сложить два числа 3 и 5 -- без создания внешних функций наподобие add(x,y), надо записать примерно следующее:

Just(3).bind(lambda x: Just(5).bind(lambda y: Just(x + y)))

Пока, казалось бы, функциональный код только создаёт новые проблемы. Однако удивительная мощность заложенного в его основу математического аппарата проявляется не сразу. В частности, огромный потенциал нового синтаксиса открывается в так называемом декларативном программировании.

Декларативным называется такой стиль разработки, когда мы не указываем компьютеру явно, набором последовательных команд, что ему надо делать, а лишь записываем основные правила решаемой задачи, потом начинается функциональная магия, и в заключение мы автоматически получаем нужный результат.

Красивый пример приведён вот в этой статье "Монады в Python поподробнее"
https://habr.com/ru/articles/138676/

Задача: проверить, можно ли из одной указанной точки на шахматной доске достигнуть второй указанной точки ровно за 3 хода конём.

Как бы вы запрограммировали решение в императивном стиле, набором команд? Сперва сгенерировали бы все возможные ходы из текущей позиции с учётом размеров доски, затем в цикле начали бы их перебирать, для каждого хода заново генерировать ходы из новой позиции, снова их перебирать -- и так тремя вложенными циклами. А если нам потребуется узнать, можно ли достигнуть цели за 333 хода? Спасёт только рекурсия.

В статье автор приводит решение с помощью эмуляции монад, которая сделана "на коленке" и операцию bind явно не поддерживает. В результате пришлось придумывать искусственный ненаглядный синтаксис. Однако в PyMonad монады реализованы полноценно, поэтому перепишем оригинальный вариант так:

raw_jumps = lambda x: ListMonad(
    (x[0] + 1, x[1] + 2),
    (x[0] + 1, x[1] - 2),
    (x[0] - 1, x[1] + 2),
    (x[0] - 1, x[1] - 2),
    (x[0] + 2, x[1] + 1),
    (x[0] + 2, x[1] - 1),
    (x[0] - 2, x[1] + 1),
    (x[0] - 2, x[1] - 1),
)

if_valid = lambda x: ListMonad( (x[0], x[1]) ) if 1 <= x[0] <= 8 and 1 <= x[1] <= 8 
    else ListMonad()

jump = (lambda pos: ListMonad(pos).bind(raw_jumps).bind(if_valid))

in3jumps = lambda pos_from, pos_to: pos_to in (
    ListMonad(pos_from).bind(jump).bind(jump).bind(jump))

print( in3jumps((3,3), (5,1)) ) # False
print( in3jumps((3,3), (5,2)) ) # True

Это всё! Обратите внимание, что мы по сути вообще не программировали логику перебора ходов. Нам достаточно объединить в цепочку вычислений генерацию ходов -- функцию jump, затем корректные ходы фильтруются функцией if_valid, и всё. Все комбинации вариантов, стыковки и другие промежуточные вычисления произойдут автоматически.

Задание.
В статье есть вторая задача про канатоходца, тоже по сути в декларативном стиле. Перепишите её на работу с PyMonad.
Обратите внимание, что, во-первых, поле .result (извлечение данных из функтора) в оригинальном примере надо заменить на метод getValue() (в последней версии PyMonad он вроде был заменён на прямой доступ к полю value, как раньше был result), и во-вторых, в функции вывода результата show() случай, когда канатоходец упал, выявляется простой проверкой параметра maybe на равенство Nothing. Если канатоходец держится нормально, то результат будет представлен в виде функтора Just(), который обёртывает список из двух элементов (сколько птиц слева и сколько птиц справа). 

