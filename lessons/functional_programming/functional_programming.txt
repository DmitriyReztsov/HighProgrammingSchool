Основы функционального программирования



На этом курсе мы изучим несколько десятков понятий и техник функционального программирования (ФП), которые активно применяются в повседневной разработке.

Вы получите всестороннее понимание методов и приёмов функционального программирования.
Вы уже имеете хорошее теоретическое понимание ФП с прошлых курсов, теперь рассмотрим концепции и принципы ФП, которые дадут вам прочную основу для их использования непосредственно в программировании. 



1.1 Функции и объекты первого класса (First-Class Citizens)

В этом уроке мы погрузимся в концепцию функций как объектов/сущностей первого класса в языках программирования. Мы рассмотрим, что значит для функции быть First-Class Citizens, и как эта концепция может быть применена в нефункциональных языках программирования.

К концу этого урока у вас будет более глубокое понимание потенциальной мощи функций и их роли в программировании. 

 1.1.1. Функции как объекты первого класса

Функция считается объектом первого класса в программировании, если с ней можно обращаться как с любым другим значением, таким как целое число, строка или объект. Это означает, что функции можно:

a. присваивать переменным
b. передавать в качестве аргументов другим функциям
c. возвращать как значения из других функций
d. хранить в структурах данных, таких как массивы и объекты.

Когда язык программирования поддерживает отношение к функциям как к объектам первого класса, вы получаете возможность писать код более гибко и выразительно. Но эта концепция особенно важна для функциональных языков программирования, таких как Haskell и Lisp. 

 1.1.2. Понимание функций как объектов первого класса

Чтобы лучше понять концепцию функций как объектов первого класса, давайте рассмотрим несколько примеров на разных языках программирования.

a. JavaScript

В JavaScript функции считаются объектами первого класса. Вы можете присвоить функцию переменной, передать её в качестве аргумента другой функции и вернуть её в качестве значения из другой функции. Вот пример:

// Присвоить функцию переменной
const greet = function(name) {
  return 'Hello, ${name}!';
};

// Передать функцию как аргумент другой функции
const callFunction = function(fn, value) {
  return fn(value);
};

console.log(callFunction(greet, 'John')); // Output: "Hello, John!"

// Вернуть функцию из другой функции
const createAdder = function(x) {
  return function(y) {
    return x + y;
  };
};

const add5 = createAdder(5);
console.log(add5(3)); // Output: 8

b. Python

# Присвоить функцию переменной
def greet(name):
    return f"Hello, {name}!"

greeting = greet
print(greeting("John"))  # Output: "Hello, John!"

# Передать функцию как аргумент другой функции
def call_function(fn, value):
    return fn(value)

print(call_function(greet, "Jane"))  # Output: "Hello, Jane!"

# Вернуть функцию из другой функции
def create_adder(x):
    def add(y):
        return x + y
    return add

add5 = create_adder(5)
print(add5(3))  # Output: 8

 1.1.3. Преимущества функций как объектов первого класса

Отношение к функциям как к объектам первого класса в языке программирования имеет ряд преимуществ (рассматриваем далее):

a. Возможность повторного использования кода: функции можно легко использовать повторно и комбинировать различными способами, что приводит к созданию более модульного и удобного в обслуживании кода.
b. Функции высшего порядка: функции, которые принимают другие функции в качестве аргументов или возвращают их в качестве значений, называются функциями высшего порядка. Они позволяют использовать мощные методы программирования, такие как map, filter и reduce.
c. Замыкания: когда функция определена внутри другой функции и имеет доступ к переменным родительской функции, она образует замыкание. Замыкания -- это мощная схема, которая позволяет инкапсулировать и скрывать данные. 

 Заключение

На этом уроке мы изучили концепцию функций как объектов первого класса в программировании.

Мы узнали, как функции можно присваивать переменным, передавать в качестве аргументов, возвращать в качестве значений и хранить в структурах данных. Мы также рассмотрели несколько примеров на JavaScript и Python, чтобы лучше понять эту концепцию. Используя функции как объекты первого класса, мы можем писать более гибкий, выразительный и удобный в обслуживании код.



1.2 Функции высшего порядка и их применение

1.2. Функции высшего порядка

Функции высшего порядка -- это функции, которые могут принимать другие функции в качестве аргументов, возвращать функции в качестве своих значений, или делать и то, и другое. Они считаются мощным инструментом в функциональном программировании, поскольку позволяют создавать более абстрактный и многократно используемый код.

1.2.1. Функции как аргументы

Функция высшего порядка может принимать в качестве аргументов одну или несколько функций. Это позволяет создавать более универсальные функции, которые можно применять для решения широкого круга задач. Например, рассмотрим простую функцию высшего порядка applyTwice:

function applyTwice(func, value) {
  return func(func(value));
}

Эта функция принимает в качестве аргументов другую функцию func и значение value, и дважды применяет функцию func к значению. Вот пример того, как можно использовать applyTwice:

function square(x) {
  return x * x;
}

console.log(applyTwice(square, 5)); // Output: 625


 1.2.2. Функции как возвращаемые значения

Функции высшего порядка также могут возвращать функции в качестве своего результата. Это полезно, когда мы хотим создать функцию с определённым поведением, на основе указанных параметров. Например, давайте создадим функцию высшего порядка под названием makeMultiplier:

function makeMultiplier(factor) {
  return function (x) {
    return x * factor;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5)); // Output: 10
console.log(triple(5)); // Output: 15


 1.3. Композиция функций

Композиция функций - это процесс объединения двух или более функций для создания новой функции. Это мощная техника, которая позволяет нам создавать сложные функции из более простых. В функциональном программировании мы часто используем композицию функций вместо цепочки или вложенности функций.

Вот пример композиции функций:

function compose(f, g) {
  return function (x) {
    return f(g(x));
  };
}

function square(x) {
  return x * x;
}

function increment(x) {
  return x + 1;
}

const squareAfterIncrement = compose(square, increment);

console.log(squareAfterIncrement(4)); // Output: 25

В этом примере мы создали новую функцию squareAfterIncrement путём композиции функций square и increment. Функция compose берет две функции f и g и возвращает новую функцию, которая применяет f после g. 

 1.4. Каррирование

Каррирование -- это техника ФП, когда функция, принимающая несколько аргументов, преобразуется в серию функций, каждая из которых принимает один аргумент. Это может сделать функцию более модульной и более удобной для повторного использования.

Пример функции curried:

function add(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = add(5);

console.log(add5(3)); // Output: 8

В этом примере мы создали каррированную функцию add, которая принимает один аргумент x и возвращает новую функцию, принимающую другой аргумент y. Теперь мы можем создавать специализированные функции, такие как add5, частично применяя функцию add. 

 Заключение

На этом уроке мы рассмотрели композицию функций и керрирование. Эти понятия важны для функционального программирования и помогут вам писать более эффективный, модульный и многократно используемый код. Практикуйте использование этих методов в своих собственных проектах, чтобы улучшить свои навыки программирования и создавать более удобный в обслуживании код. 



2.1. Состояние и иммутабельность

2.1.1. Иммутабельность

Иммутабельность (неизменяемость) -- это свойство данных, которые после создания не могут быть изменены. В ФП неизменяемость считается предпочтительной, поскольку она помогает нам избежать неожиданных побочных эффектов и делает код более понятным. Когда данные неизменяемы, мы можем быть уверены, что они всегда имеют одно и то же значение, и нам не нужно беспокоиться о том, что они могут быть изменены другими частями нашего кода.

2.1.2. Состояние

Понятие "состояния" подразумевает возможность модификации данных в программе в любой момент времени. В ФП мы стараемся минимизировать использование состояния, и по возможности избегать изменения данных. Вместо того чтобы изменять состояние напрямую, мы используем чистые функции, которые принимают текущее состояние на вход и возвращают новое состояние на выходе. Такой подход помогает нам поддерживать предсказуемость и расширяемость нашего кода. 



2.2. Важность иммутабельности в ФП

2.2.1. Предсказуемость

Одно из главных преимуществ иммутабельности в функциональном программировании заключается в том, что она делает наш код более предсказуемым. Когда данные неизменяемы, мы можем быть уверены, что они всегда будут иметь одно и то же значение, и нам не нужно беспокоиться о том, что они могут быть изменены другими частями нашего кода. Это означает, что мы можем легче рассуждать о нашем коде и быть уверенными в том, что наши функции всегда будут выдавать один и тот же результат на одни и те же входные данных.

2.2.2. Сопровождаемость

Неизменяемые данные также делают наш код более удобным в обслуживании. Когда мы знаем, что данные не могут быть изменены, мы пишем простые и понятные функции. Нам не нужно беспокоиться о том, как управлять сложными изменениями состояния или бороться с неожиданными побочными эффектами.

2.2.3. Параллелизм

Иммутабельность особенно важна в параллельном программировании, когда несколько потоков или процессов могут одновременно обращаться к данным и изменять их. Когда данные неизменяемы, нам не нужно беспокоиться о ситуации гонки или других проблемах, связанных с параллелизмом, поскольку данные не могут быть изменены после их создания. Это значительно облегчает написание безопасного и эффективного параллельного кода. 


2.3. Применение иммутабельности на практике

2.3.1. Использование неизменяемых структур данных

Одним из способов обеспечения неизменяемости в коде считается использование неизменяемых структур данных. Многие языки программирования обеспечивают встроенную поддержку иммутабельных структур данных (кортежи или неизменяемые списки). Используя эти структуры данных, вы можете быть уверены, что данные не будут изменены случайно или непредсказуемо.

2.3.2. Исключение побочных эффектов

Еще один неочевидный способ повышения иммутабельности -- избегать побочных эффектов в своих функциях. Побочные эффекты -- это любые изменения в состоянии программы, которые происходят в результате выполнения функции за её пределами. Чистые функции, не имеющие побочных эффектов, гарантируют, что ваш код будет более предсказуемым и более понятным.

2.3.3. Использование техник ФП

Такие методы ФП, как функции высшего порядка и рекурсия, могут помочь вам написать код, в большей степени ориентированный на иммутабельность. Используя эти техники, вы можете создать код, который будет более модульным, повторно используемым и более понятным. 



Заключение

Иммутабельность -- это ключевая концепция ФП, которая помогает нам писать более предсказуемый, удобно сопровождаемый и параллельный код. Понимая важность иммутабельности и применяя этот подход в своём коде, вы можете создавать программы, о которых легче рассуждать, и которые менее подвержены ошибкам и неожиданным побочным эффектам. Далее мы рассмотрим более продвинутые концепции и методы ФП, которые помогут вам писать ещё более эффективный код.

Почитайте также вот этот мой пост https://vk.com/wall-152484379_3600 , в котором подробнее разбираю тему иммутабельнжости. 



2.4. Управление состоянием и побочные эффекты

2.4.1. Понятие состояния и побочных эффектов

Состояние характерно для данных, которые программа хранит и которыми манипулирует (изменяет) во время выполнения. В функциональном программировании состояние обычно представлено неизменяемыми структурами данных, что означает, что после присвоения значения переменной оно не может быть изменено.

Побочные эффекты, с другой стороны -- это изменения, которые функция вносит в состояние программы или окружения за пределами своей области действия. Примерами побочных эффектов будут изменение глобальных переменных, запись в базу данных или отправка данных по сети. В функциональном программировании мы стремимся минимизировать побочные эффекты, чтобы сделать наш код более предсказуемым и простым для понимания. 

 2.4.2. Важность управления состоянием и побочными эффектами

Управление состоянием и побочными эффектами важно по нескольким причинам:

- Предсказуемость: Минимизация побочных эффектов делает ваш код более предсказуемым, поскольку поведение функции зависит только от ее входа, а не от внешних факторов.

- Тестируемость: Функции с меньшим количеством побочных эффектов легче тестировать, поскольку вам не нужно управлять сложными внешними зависимостями.

- Удобство сопровождения: Код с меньшим количеством побочных эффектов легче поддерживать, поскольку изменения в одной части кода с меньшей вероятностью приведут к непредвиденным последствиям в других.

- Масштабируемость: Эффективное управление состоянием может повысить производительность вашего кода, делая его более подходящим для крупномасштабных приложений. 

 2.4.3. Стратегии управления состоянием и побочными эффектами

Вот некоторые стратегии управления состоянием и побочными эффектами в вашем коде:

- Используйте чистые функции: Чистые функции - это функции, которые не имеют побочных эффектов и всегда возвращают один и тот же результат на один и тот же вход. Использование чистых функций делает ваш код более предсказуемым и легким для тестирования.

- Инкапсулируйте состояние: Инкапсулируйте (скрывайте) состояние в объектах или модулях и предоставляйте чётко определённый интерфейс для взаимодействия с этим состоянием. Это помогает ограничить область изменения состояния и облегчает рассуждения о поведении вашего кода.

- Используйте иммутабельные структуры данных: Неизменяемые структуры данных не могут быть изменены после их создания. Их использование помогает снизить риск возникновения непреднамеренных побочных эффектов и делает ваш код более предсказуемым.

- Изолируйте побочные эффекты: Если побочные эффекты необходимы, изолируйте их от остального кода с помощью специальных функций или модулей. Это облегчает управление и тестирование побочных эффектов отдельно от остального кода.

 2.4.4. "Персистентные" структуры данных

Персистентные структуры данных -- это вид неизменяемой структуры данных, который позволяет эффективно создавать новые, модифицированные версии структуры, не изменяя её "исходник". Глобально речь идёт о том, что хранится вся история изменения конкретных данных, а не только их последнее значение. Это достигается за счёт совместного использования частей структуры данных от версии к версии, а не копированием всей структуры. Персистентность похожа на систему контроля версий, когда следующая версия кода может быть представлена не как весь код целиком, а лишь как набор изменений по отношению к предыдущей версии.

Некоторые преимущества использования персистентных структур данных:

- Снижение риска возникновения непреднамеренных побочных эффектов: Поскольку персистентные структуры данных неизменяемы, они не могут быть случайно модифицированы, что помогает предотвратить непреднамеренные побочные эффекты.

- Эффективное использование памяти: Персистентные структуры данных могут разделять части своей структуры между различными версиями, что может привести к более эффективному использованию памяти.

- Более простая функциональность undo/redo: Персистентные структуры данных упрощают реализацию функций undo/redo в вашем приложении, поскольку вы можете легко и просто переключаться между различными версиями структуры данных. 


Заключение

Управление состоянием и побочными эффектами имеет решающее значение для написания эффективного, сопровождаемого и масштабируемого кода. Используя такие стратегии, как чистые функции, инкапсуляция и неизменяемые структуры данных, вы можете свести к минимуму риск непреднамеренных побочных эффектов и сделать свой код более предсказуемым.
Персистентные структуры данных считаются мощным инструментом для управления состоянием, поскольку они позволяют создавать новые компактные версии модифицированной структуры данных, не изменяя исходную структуру. 



3.1. Чистые функции

Чистая функция -- это функция, обладающая следующими свойствами:

a. Детерминированность: при одинаковых входных данных чистая функция всегда будет возвращать один и тот же результат. Это означает, что результат функции зависит только от её входных параметров и не зависит от внешнего состояния или изменяемых данных.

b. Отсутствие побочных эффектов: чистая функция не изменяет никакого внешнего состояния и не модифицирует внешние данные. Она не изменяет свои входные аргументы, глобальные переменные или любые другие внешние данные. Она также не производит никаких наблюдаемых побочных эффектов, таких как запись в файл, вывод на консоль или изменение DOM. 


3.2. Ссылочная прозрачность

Функция считается ссылочно прозрачной, если её можно заменить соответствующим выходным значением (её результатом) без изменения поведения программы. Другими словами, если функция ссылочно прозрачна, мы можем заменить вызов функции ее результирующим значением, и программа будет вести себя так же.

Ссылочная прозрачность -- это прямое следствие того, что функция чистая. Поскольку чистые функции всегда выдают один и тот же результат на один и тот же вход и не имеют побочных эффектов, они могут быть заменены своими выходными значениями без изменения поведения программы. 


3.3. Преимущества чистых функций

Чистые функции обладают рядом преимуществ при разработке программного обеспечения:

a. Легче понимать: Поскольку чистые функции зависят только от своих входных аргументов и не полагаются на внешнее состояние, они более предсказуемы и их легче понять. Это упрощает рассуждения о поведении кода и поиск потенциальных ошибок.

b. Легче тестировать: Чистые функции легче тестировать, поскольку они не требуют дополнительных настроек в тестах. Вам нужно только задать входные аргументы и проверить результат. Это приводит к более простым и надёжным тестам.

c. Легче отлаживать: Когда ошибка возникает в чистой функции, легче определить её причину, поскольку нет скрытых зависимостей или побочных эффектов. Вы можете изолировать проблему, посмотрев на входные аргументы и реализацию функции.

d. Хорошо сопровождаемый код: Чистые функции способствуют созданию модульной и удобной в обслуживании кодовой базы. Поскольку они не зависят от внешнего состояния, вы можете легко рефакторить или заменять их, не беспокоясь о непредвиденных последствиях.

e. Повышенная производительность: Чистые функции могут быть "мемоизированы": их вывод может быть закэширован для заданного набора входных аргументов. Это может значительно повысить производительность в некоторых случаях, так как функцию не нужно повторно вычислять для тех же входных данных. 


Заключение

В этом занятии мы узнали о чистых функциях и ссылочной прозрачности -- двух важнейших принципах функционального программирования. Понимая и применяя эти концепции, вы можете писать более удобный в обслуживании, предсказуемый и эффективный код. Далее мы рассмотрим функции высшего порядка и то, как их можно использовать для создания модульного и повторно используемого кода. 



4.1. Ссылочная прозрачность

Ссылочная прозрачность -- это фундаментальная концепция функционального программирования. Функция считается ссылочно прозрачной, если она всегда выдаёт один и тот же результат на одни и те же входные значения, не вызывая никаких побочных эффектов. Это означает, что мы можем заменить любой вызов ссылочно прозрачной функции её результирующим значением без изменения поведения программы.

Ссылочная прозрачность имеет несколько следствий:

a. Легче рассуждать: Поскольку ссылочно прозрачные функции всегда выдают один и тот же результат на одни и те же входные данные, их поведение легче понять и предсказать. Это делает код более удобным для сопровождения и менее подверженным ошибкам.

b. Упрощённое тестирование: Ссылочно прозрачные функции легче тестировать, поскольку их поведение детерминировано. Вам нужно только протестировать функцию с различными входами и проверить, выдает ли она ожидаемые результаты.

c. Повышенная производительность: Ссылочно прозрачные функции могут быть мемоизированы, что означает, что их результаты могут быть закэшированы для заданного набора входных параметров. Это может повысить производительность программы за счёт исключения избыточных вычислений.

d. Параллелизм: Ссылочно прозрачные функции по своей сути потокобезопасны, поскольку они не зависят от изменяемого состояния и не вызывают побочных эффектов. Это облегчает написание параллельного кода. 


4.2. Техники создания чистых функций

Чтобы достичь ссылочной прозрачности, нужно писать чистые функции. Чистая функция - это функция, которая:

a. Не имеет побочных эффектов: она не изменяет внешнее состояние и не вызывает никаких наблюдаемых изменений за пределами своей области видимости.

b. Детерминирована: она всегда выдает один и тот же результат на одни и те же входные данным.

Вот несколько приёмов, которые помогут вам писать чистые функции:

a. Избегайте изменяемого состояния: вместо того чтобы изменять переменные или структуры данных "на месте", создайте новые структуры с нужными изменениями. Это гарантирует, что функция не будет иметь побочных эффектов.

b. Используйте функции высшего порядка -- это функции, которые принимают другие функции в качестве аргументов или возвращают их в качестве результатов. Они могут помочь создать модульный и многократно используемый код, абстрагируя общие шаблоны поведения.

c. Используйте рекурсию -- технику, при которой функция вызывает сама себя. Рекурсивные функции часто могут заменить итеративные схемы (например, циклы), которые зависят от изменяемого состояния.

d. Используйте функциональные структуры данных -- такие, как иммутабельные списки или деревья, которые помогут обеспечить неизменяемость и избежать побочных эффектов в коде.

e. Избегайте глобального состояния: оно может вызвать побочные эффекты и сделать ваши функции не чистыми. Вместо этого передавайте все необходимые состояния в качестве аргументов в функции.

f. Ограничьте использование не чистых функций: такие функции, как операции ввода-вывода или генераторы случайных чисел, являются "не чистыми" по своей природе. Постарайтесь изолировать эти функции и минимизировать их использование в коде. 


Заключение

В этом уроке мы узнали о ссылочной прозрачности и её эффектах. Мы также изучили различные методы написания чистых функций, которые помогают достичь ссылочной прозрачности. Применяя эти концепции и методы, вы можете создавать более удобный в обслуживании, предсказуемый и эффективный код. 



5.1. Рекурсия и итерация

Рекурсия и итерация -- два фундаментальных метода, используемых в программировании для решения проблем, требующих повторения вычислений. Оба метода подразумевают повторение набора инструкций до тех пор, пока не будет выполнено определённое условие. Однако они различаются по способу реализации и использования.

5.1.1. Итерация

Итерация -- это процесс многократного выполнения набора инструкций с использованием конструкции цикла. В ФП итерация обычно достигается с помощью функций высшего порядка, таких как map, filter и reduce. Эти функции принимают в качестве аргумента другую функцию и применяют ее к каждому элементу списка, возвращая новый список с результатами (такой же длины, отфильтрованный или агрегированное значении).

5.1.2. Рекурсия

Рекурсия -- это техника, при которой функция вызывает сама себя. В ФП рекурсия часто используется как альтернатива итерации, поскольку она позволяет получать более элегантные и лаконичные решения многих задач. Рекурсивные функции обычно реализуют базовый случай, который представляет собой простой случай проблемы, решаемый напрямую, и рекурсивный случай, который предполагает разбиение проблемы на более мелкие, и решение их с помощью этой же функции. 


5.2. Преимущества и недостатки рекурсии

Рекурсия имеет некоторые преимущества и недостатки по сравнению с итерацией:

5.2.1. Преимущества

- Рекурсия может привести к более элегантным и лаконичным решениям некоторых задач.
- Рекурсивные функции часто легче понять, поскольку они непосредственно моделируют постановку задачи.

5.2.2. Недостатки

- Рекурсивные функции могут быть менее эффективными, чем итеративные решения, поскольку они могут требовать много вызовов функций и больше памяти.
- Некоторые языки программирования имеют ограниченную поддержку рекурсии, что может привести к таким проблемам, как ошибки переполнения стека.


6.1. Хвостовая рекурсия

Хвостовая рекурсия -- это особая форма рекурсии, при которой рекурсивный вызов располагается самой последней операцией в функции. Это означает, что результат рекурсивного вызова сразу возвращается без каких-либо дальнейших вычислений. Это важно, поскольку позволяет компилятору или интерпретатору оптимизировать функцию, уменьшая объем используемой памяти и повышая производительность. Фактически, компилятору не требуется запоминать точку возврата в вызывающую функцию, т.к. она сразу завершается, что позволяет существенно экономить на стеке вызовов, когда рекурсивных вызовов много.

Рассмотрим следующий пример рекурсивной функции для вычисления факториала числа:

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

Здесь нельзя сказать, что рекурсивный вызов будет самым последним, т.к. его результат потребуется ещё умножить на n.

Перепишем эту функцию на хвостовую рекурсию:

def factorial(n, accumulator=1):
    if n == 0:
        return accumulator
    else:
        return factorial(n - 1, n * accumulator)



6.2. Оптимизация

Когда функция реализует хвостовую рекурсию, компилятор или интерпретатор могут её оптимизировать , повторно используя один и тот же фрейм стека для каждого рекурсивного вызова, вместо того, чтобы создавать новый фрейм стека для каждого вызова. Это уменьшает объем используемой памяти и может повысить производительность, особенно при глубокой рекурсии.

В некоторых языках, таких как Haskell и Scala, оптимизация хвостовой рекурсии гарантируется спецификацией языка. В других языках, таких как Python или Java, оптимизация хвостовой рекурсии не гарантируется и может зависеть от конкретной реализации или версии языка. 


6.3. Сравнение рекурсии и итерации

Рекурсия и итерация -- это два способа решения задач в программировании. И то, и другое имеет свои преимущества и недостатки, и выбор между ними зависит от конкретной задачи и используемого языка.

Преимущества рекурсии:

- Рекурсия может привести к более короткому и элегантному коду, поскольку для этого часто требуется меньше строк кода, и можно обходиться без использования состояния.

Недостатки рекурсии:

- Рекурсия может быть менее эффективной, чем итерация, поскольку она часто требует больше памяти из-за создания новых фреймов стека для каждого вызова функции.
- В языках без оптимизации хвостовой рекурсии глубокая рекурсия может привести к ошибкам переполнения стека.

Преимущества итерации:

- Итерация может быть более эффективной, чем рекурсия, поскольку обычно требует меньше памяти и меньше вызовов функций.
- Итерацию обычно легче понять и отладить, поскольку она включает в себя явное управление состоянием и чёткую структуру цикла.

Недостатки итерации:

- Итеративные решения могут быть более подробными и менее элегантными, чем рекурсивные решения, поскольку они часто требуют большего количества строк кода и явного управления состоянием.
- Некоторые задачи по своей природе не являются итеративными и могут потребовать более сложной логики для решения с использованием итерации. 


Заключение

В этом занятии мы обсудили хвостовую рекурсию, оптимизацию и различия между рекурсией и итерацией. Понимание этих концепций поможет вам писать более эффективный и чистый код при работе с рекурсивными функциями. При выборе между рекурсией и итерацией важно учитывать конкретную задачу и используемый язык, поскольку каждый из них имеет свои преимущества и недостатки. 



7. Списки, деревья и другие функциональные структуры данных

7.1. Список -- это фундаментальная структура данных в функциональных языках программирования. Это упорядоченная коллекция элементов, которые могут быть любого типа. В ФП списки обычно реализуются как связные списки, где каждый элемент указывает на следующий элемент. Ниже приведены некоторые распространенные операции над списками как АТД:

- head: Возвращает первый элемент списка.
- хвост: Возвращает список без первого элемента.
- isEmpty: Проверяет, является ли список пустым.
- length (длина): Возвращает количество элементов в списке.
- map(f): Применяет функцию f к каждому элементу списка и возвращает новый список с результатами.
- filter(f): Возвращает новый список, содержащий только те элементы, которые удовлетворяют заданной предикатной функции f.
- reduce(f): Уменьшает список до одного значения путем применения бинарной функции/операции f к элементам списка. 

 7.2. Дерево -- это иерархическая структура данных, состоящая из узлов, соединенных рёбрами. Каждый узел дерева может иметь ноль или более дочерних узлов. Самый верхний узел называется корнем, а узлы, не имеющие дочерних, называются листьями. Деревья полезны для представления иерархических отношений, а также для эффективного поиска и сортировки данных. Некоторые распространенные типы деревьев включают двоичные деревья, деревья AVL и красно-чёрные деревья (всё это вы проходили на втором курсе АСД). Ниже приведены некоторые распространенные операции над деревьями как АТД:

- insert: Добавляет новый узел в дерево.
- delete: Удаляет узел из дерева.
- search: Поиск узла с заданным значением в дереве.
- traverse: Посещает все узлы в дереве в определенном порядке (например, по порядку, до или после).
- height: Возвращает высоту дерева. 

 7.3. Другие функциональные структуры данных

Помимо списков и деревьев, существует множество других функциональных структур данных, которые могут быть полезны в различных ситуациях. Некоторые примеры включают:

- Множества: Неупорядоченная коллекция уникальных элементов. Общие операции включают добавление, удаление и проверку принадлежности.
- Карты/словари: Коллекция пар ключ-значение, где каждый ключ связан со значением. Общие операции включают добавление, удаление и поиск значений по ключу.
- Очереди: Коллекция элементов, которая поддерживает добавление элементов в конец и удаление элементов из передней части. Очереди можно использовать для реализации структур данных типа "первым пришел - первым ушел" (FIFO).
- Стеки: Коллекция элементов, которая поддерживает добавление элементов в верхнюю часть и удаление элементов из верхней части. Стеки могут использоваться для реализации структур данных типа "первым пришел - первым ушел" (LIFO). 

 7.4. Персистентные структуры данных

Одна из проблем работы с неизменяемыми структурами данных заключается в том, что для их обновления иногда может потребоваться копирование больших частей структуры данных. Персистентные структуры данных -- это класс структур данных, которые позволяют нескольким версиям данных эффективно сосуществовать, подразумевая лишь минимальное копирование. Идея в том, что новая версия структуры получается не копированием исходной структуры целиком и внесением в неё изменений, а добавлением небольшой мета-информации, что именно было изменено. При этом, конечно, придётся хранить и исходную структуру, и ссылку на неё.

Заключение

В этом занятии мы рассмотрели некоторые распространённые функциональные структуры данных, такие как списки, деревья и другие связанные структуры. Понимание этих структур данных и их операций необходимо для написания эффективных и корректных функциональных программ. В следующем уроке мы углубимся в концепции функционального программирования, такие как функции более высокого порядка, рекурсия и отложенные вычисления. 



8.1. Операции над функциональными структурами данных

8.1.1. Основные операции

Функциональные структуры данных предоставляют набор базовых операций, которые позволяют манипулировать данными, которые они содержат. Некоторые из наиболее распространенных операций:

- insert: Добавление элемента в структуру данных.
- delete: Удаление элемента из структуры данных.
- find: Поиск элемента в структуре данных.
- update: Изменение значения элемента в структуре данных.

Поскольку функциональные структуры данных иммутабельны, все эти операции возвращают новую структуру данных, которая представляет результат операции, не изменяющей исходную структуру данных.

8.1.2. Функции высшего порядка

Функциональные структуры данных часто предоставляют функции высшего порядка, которые принимают в качестве аргументов другие функции. Такие функции можно использовать для выполнения более сложных операций над структурой данных -- фильтрация, отображение/мэппинг или свёртка. Некоторые распространенные функции высшего порядка:

- map: Применяет функцию к каждому элементу структуры данных, создавая новую структуру данных с результатом аналогичного размера.
- filter: Создает новую структуру данных, содержащую только те элементы, которые удовлетворяют заданной функции-предикату.
- fold (также известная как reduce): Объединяет элементы структуры данных с помощью бинарной функции, формируя одно накопленное/агрегированное значение. 


8.2. Ленивые вычисления и бесконечные структуры данных

8.2.1. Ленивые вычисления

Ленивые вычисления -- это техника программирования, при которой вычисление выражения откладывается до тех пор, пока его значение действительно не понадобится, не будет непосредственно запрошено. Это может привести к повышению производительности, так как позволяет избежать ненужных вычислений. В функциональных языках программирования ленивые вычисления часто используются для работы с бесконечными структурами данных -- такими структурами, которые потенциально могут иметь бесконечное количество элементов.

8.2.2. Бесконечные структуры данных

Бесконечные структуры данных -- это мощная абстракция, которая позволяет представлять и манипулировать потенциально бесконечными наборами данных. Некоторые примеры бесконечных структур данных:

- Потоки: Последовательность значений, которые могут быть вычислены по требованию/по запросу. Потоки можно использовать для представления таких бесконечных последовательностей, как числа Фибоначчи или простые числа.

- Ленивые списки: Список, в котором элементы вычисляются по требованию, по мере обращения к ним. Это позволяет представлять бесконечные списки, например, список всех натуральных чисел. 

 8.2.1. Ленивые вычисления

Ленивые вычисления -- это техника программирования, при которой вычисление выражения откладывается до тех пор, пока его значение действительно не понадобится, не будет непосредственно запрошено. Это может привести к повышению производительности, так как позволяет избежать ненужных вычислений. В функциональных языках программирования ленивые вычисления часто используются для работы с бесконечными структурами данных -- такими структурами, которые потенциально могут иметь бесконечное количество элементов.

8.2.2. Бесконечные структуры данных

Бесконечные структуры данных -- это мощная абстракция, которая позволяет представлять и манипулировать потенциально бесконечными наборами данных. Некоторые примеры бесконечных структур данных:

- Потоки: Последовательность значений, которые могут быть вычислены по требованию/по запросу. Потоки можно использовать для представления таких бесконечных последовательностей, как числа Фибоначчи или простые числа.

- Ленивые списки: Список, в котором элементы вычисляются по требованию, по мере обращения к ним. Это позволяет представлять бесконечные списки, например, список всех натуральных чисел.

8.2.3. Работа с бесконечными структурами данных

Для работы с бесконечными структурами данных необходимо использовать функции, которые могут оперировать потенциально бесконечным числом элементов. Некоторые распространенные методы:

- Использование функций высшего порядка, таких как map, filter или fold, которые могут работать с бесконечными структурами данных.
- Использование рекурсии для определения функций, которые могут обрабатывать бесконечные структуры данных.
- Использование ленивых вычислений для обработки элементов структуры данных по требованию, по мере необходимости. 


Заключение

В этом занятии мы узнали об операциях с функциональными структурами данных и об использовании ленивых вычислений и бесконечных структур данных. Мы увидели, какой набор базовых операций предоставляют функциональные структуры данных, и как функций высшего порядка позволяют манипулировать содержащимися в этих структурах данными. Мы также изучили концепцию ленивых вычислений и то, как она позволяет нам работать с бесконечными структурами данных. Поняв эти концепции, вы можете использовать возможности ФП для написания более эффективного и выразительного кода. 



9.1. Алгебраические типы данных

Алгебраические типы данных -- это способ определения пользовательских типов (структур данных) в функциональных языках программирования. Они называются "алгебраическими", потому что могут быть составлены с помощью двух основных операций: суммы типов и произведения типов. В данном контексте операция суммы представляет собой выбор между несколькими альтернативами, а операция произведения - комбинацию нескольких значений.

Более подробно алгебраические типы данных разбирались в этом посте:
vk.com/wall-152484379_3577

9.1.1. Sum Types

Этот тип недоступен в нефункциональных языках программирования вроде Java или Python. Он допускает представление одной структуры данных в нескольких видах (состояниях), но находиться эта структура может только в одном из состояний. Например, одним состоянием может быть массив байтов, а другим -- строка в некоторой кодировке, которую задаёт массив этих "сырых" байтов, что удобно для обработки такой структуры в зависимости от контекста.

9.1.2. Product Types

Это знакомый тип данных, известный например как записи или списки, хранящие комбинацию нескольких значений. 


9.2. Сопоставление с образцом (Pattern Matching)

Сопоставление с образцом -- это мощная техника, которая позволяет извлекать данные из сложных структур данных в краткой и читабельной форме. Она особенно полезна при работе с алгебраическими типами данных, поскольку позволяет обрабатывать различные случаи комбинации значений ясным и элегантным образом.

9.2.1. Базовое сопоставление с образцом

Пример функции на Haskell, которая вычисляет факториал целого неотрицательного числа с использованием сопоставления с образцом (образцы расположены в левой части выражений, соответствующие им действия или значения -- в правой):

factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

В этом примере первое выражение соответствует базовому случаю, когда входное значение равно 0, а второе выражение соответствует рекурсивному случаю для любого другого целого числа n. 

 9.2.2. Сопоставление с образцом с алгебраическими типами данных

Сопоставление с образцом особенно полезно при работе с алгебраическими типами данных, поскольку оно позволяет обрабатывать сложные конструкции типов чистым и элегантным способом. Вот пример функции, которая оценивает выражение Expr, используя сопоставление с образцом:

eval :: Expr -> Integer
eval (Let n) = n
eval (Add e1 e2) = eval e1 + eval e2
eval (Mul e1 e2) = eval e1 * eval e2

Haskell взят потому, что в языках уровня Java или Python алгебраические типы не поддерживаются. 


Заключение

В этом занятии мы изучили концепции сопоставления с образцом и алгебраические типы данных в функциональном программировании. Алгебраические типы данных позволяют определять пользовательские структуры данных, которые могут быть составлены с использованием операций sum и product, а сопоставление с образцом позволяет извлекать данные из этих структур кратким и читабельным способом. Освоив эти концепции, вы сможете писать более выразительный и эффективный код на функциональных языках программирования. 



10.1. Алгебраические типы данных

Алгебраические типы данных -- это составные типы, которые позволяют определять сложные структуры данных путем объединения более простых. Они называются "алгебраическими", потому что их можно рассматривать как результат применения алгебраических операций (таких как сумма и произведение) к типам.

Существуют два основных вида алгебраических типов данных:

a. Product types: Они также известны как кортежи или записи. Данный тип -- это комбинация нескольких типов, где каждый тип представляет поле в продукте. Например, трехмерная точка может быть представлена как product type из трех целых или вещественных чисел (координаты x, y и z).

b. Sum types: представляют собой выбор между несколькими различными типами, где каждый тип выделяется уникальным конструктором. Например, фигура может быть представлена как sum type круга (с радиусом) или прямоугольника (с шириной и высотой), однако она может быть либо кругом, либо прямоугольником, но не тем и другим одновременно. 


10.2. Алгебраические типы данных и их приложения

Алгебраические типы данных полезны для моделирования сложных структур данных и выражения отношений между различными типами данных. Некоторые распространённые приложения включают:

a. Представление абстрактных синтаксических деревьев в компиляторах и интерпретаторах.

b. Моделирование переходов состояний в машинах состояний.

c. Определение структур данных для древовидных структур, таких как XML или JSON.

d. Представление необязательных или nullable значений (например, с помощью типов Maybe или Option). 


10.3. Сопоставление с образцом

Сопоставление с образцом -- это мощный механизм потока управления, который позволяет в частности продуктивно использовать алгебраические типы данных. Это лаконичный и выразительный способ обработки различных схем структур данных, особенно sum types.

В выражении сопоставления с образцом мы определяем серию шаблонов и соответствующие действия. Когда выражение оценивается, шаблоны сопоставляются с входным значением по порядку, и выполняется действие, соответствующее первому совпавшему шаблону.

Сопоставление с образцом может быть использовано для управления потоком вычислений различными способами:

a. Условия: мы можем использовать сопоставление с образцом для замены цепочек if-else или операторов switch. Например, мы можем сопоставить булево значение для выполнения различных действий в случаях true и false.

b. Де-структуризация: мы можем использовать сопоставление с образцом для извлечения значений из product types, таких как кортежи или записи.

c. Работа с sum types: сопоставление с образцом особенно полезно для работы с sum types, поскольку оно позволяет явно обрабатывать каждый случай конструктора и гарантирует, что мы охватим все возможные случаи.

d. Рекурсивные функции: сопоставление с образцом можно использовать для определения рекурсивных функций на алгебраических типах данных, таких как списки или деревья. Мы можем сопоставить структуру входного значения и определить базовые и рекурсивные случаи соответственно. 


Заключение

В этом занятии мы узнали об алгебраических типах данных, их приложениях и о том, как использовать сопоставление с образцом в потоке управления. Эти концепции необходимы для работы с функциональными языками программирования и могут помочь нам писать более выразительный и сопровождаемый код. 



11. Монады и функторы

11.1. Функторы

Функтор -- это тип, поддерживающий операцию map, которая применяет функцию к значению, "обёрнутому" в контейнер. Другими словами, функтор -- это контейнер, который хранит значения и имеет метод map для применения функции-аргумента к каждому значению, формирущий на выходе контейнер аналогичной структуры. Наиболее распространённым примером функтора будет список или массив.

const numbers = [1, 2, 3, 4, 5];

const doubledNumbers = numbers.map(x => x * 2);
console.log(doubledNumbers); // [2, 4, 6, 8, 10]

В этом примере на JavaScript функция map применяет функцию-аргумент (удвоение значения) к каждому элементу массива numbers. В результате образуется новый массив аналогичного размера с удвоенными значениями. 

 11.2. Монады

Монада -- это более продвинутое понятие в ФП. Это тип, который представляет вычисления, определенные как последовательность шагов. Монады используются для обработки побочных эффектов, управления состоянием и компоновки функций чистым и элегантным способом.

Монады можно рассматривать как расширение функторов. У моданы есть операция bind, которая похожа на операцию map функторов, но имеет некоторые дополнительные возможности: она позволяет соединять несколько функций в цепочку, где каждая функция может возвращать монаду.

Пример на JavaScript:

const getUser = id => Promise.resolve({ id, name: 'John Doe' });

const getPosts = user => Promise.resolve(
    [{ userId: user.id, title: 'Post 1' },
     { userId: user.id, title: 'Post 2' }]);

const userPromise = getUser(1);
const postsPromise = userPromise.then(getPosts);

postsPromise.then(posts => console.log(posts));

В этом примере getUser и getPosts -- функции, возвращающие Promise (которые в JavaScript будут монадами). Метод then -- это операция bind для Promise. Он позволяет связать функции getUser и getPosts вместе, так что выход одной функции становится входом следующей функции. 

 11.3. Понимание роли монад в ФП

Монады играют важнейшую роль в функциональном программировании, предоставляя способ обработки побочных эффектов, управления состоянием и компоновки функций чистым и элегантным способом. Они позволяют вам писать код, который является более модульным, многократно используемым и более понятным.

Некоторые распространенные примеры монад в функциональных языках программирования:

- Монада Maybe представляет вычисления, которые могут вернуть значение или закончиться неудачей. Она используется для работы с "нулевыми" или неопределёнными значениями.

- Монада Either представляет вычисления, которые могут вернуть значение или ошибку. Она используется для обработки исключений и ошибок.

- Монада State представляет вычисления, которые содержат в себе некоторое состояние. Она используется для функционального управления состоянием.

- Монада IO представляет вычисления, выполняющие операции ввода/вывода. Она используется для обработки внешних побочных эффектов, таких как запись в файл или чтение по сети.

Правильно используя монады, вы сможете писать функциональный код, который будет более модульным, многократно используемым и более понятным. 

 Заключение

В этом занятии мы изучили концепции монад и функторов и их роль в функциональном программировании. Функторы предоставляют способ применения функций к "обёрнутым" в контейнер значениям, а монады расширяют эту концепцию обработкой побочных эффектов, управлением состоянием и комбинированием функций. Поняв эти концепции, вы станете лучше подготовлены к написанию чистого, модульного и многократно используемого функционального кода.



12. Функторы, монады и их применение

12.1. Функторы

Функтор, говоря математическим языком -- это отображение между категориями, которое сохраняет структуру категории. В функциональном программировании функторы используются для применения функции к значению, которое обернуто в контекст (структура которого сохраняется и в результате).
Контекст может быть контейнером (например, списком), или необязательным значением, или представлять собой вычисление (например, promise или state).

12.1.1. Определение

Функтор -- это конструктор некоторого типа, реализующий функцию map, которая применяет функцию к значению (значениям) внутри контекста. Функция map имеет следующую сигнатуру:

map :: (a -> b) -> Functor a -> Functor b

Здесь a и b -- типы, а Functor a и Functor b -- функторы, содержащие значения типа a и b соответственно.

12.1.2. Примеры

Некоторые общие примеры функторов в функциональных языках программирования:

- List: List -- это функтор, который применяет функцию к каждому элементу списка.

- Maybe: Функтор Maybe представляет необязательное значение. Функция map применяет заданную функцию к значению, если оно существует, в противном случае она возвращает Nothing.

- Either: Функтор Either представляет значение, которое может быть одного из двух типов. Функция map применяет заданную функцию к значению, если оно относится к нужному типу, в противном случае она возвращает "левое"/"первое" значение без изменений. 


12.2. Монады

Монада -- это тип функтора, который дополнительно обеспечивает способ объединения вычислений в цепочку. Монады используются для моделирования побочных эффектов и управления состоянием в функциональном программировании. 

12.2.1. Определение

Монада -- это конструктор типа, который реализует две функции: return и bind. Функция return оборачивает значение в контекст монады, а функция bind связывает вычисления воедино.

Сигнатуры этих функций следующие:

return :: a -> Monad a
bind :: Monad a -> (a -> Monad b) -> Monad b

12.2.2. Примеры

- Maybe: Монада Maybe используется для организации цепочки вычислений, которые могут завершиться неудачей или вернуть Nothing. Функция bind применяет заданную функцию к значению, если она существует, в противном случае она возвращает Nothing.

- Either: Монада Either используется для цепочки вычислений, которые могут вернуть ошибку или значение. Функция bind применяет заданную функцию к значению, если оно имеет нужный тип, в противном случае возвращает левое значение без изменений.

- List: Монада List используется для цепочки вычислений, которые могут возвращать несколько значений в контейнере. Функция bind применяет заданную функцию к каждому элементу списка и объединяет результаты.

- State: Монада State используется для моделирования вычислений с состоянием. Функция bind применяет заданную функцию к текущему состоянию и возвращает новое состояние. 


12.3. Приложения

Функторы и монады используются в функциональном программировании для следующих целей:

- Абстрагироваться от различных типов контейнеров и контекстов, что позволяет создавать общий код, работающий с различными типами структур данных.

- Моделировать побочные эффекты и управлять состоянием чисто функциональным способом, делая код более предсказуемым и удобным для понимания.

- Упростить обработку ошибок и поток управления за счёт объединения вычислений в цепочки и последовательной обработки ошибок. 


Заключение

В этом занятии мы изучили концепции функторов и монад, их приложения и примеры распространённых функторов и монад в функциональном программировании. Понимание этих концепций необходимо для освоения функционального программирования и написания более надежного, модульного и пригодного для расширения кода. 


