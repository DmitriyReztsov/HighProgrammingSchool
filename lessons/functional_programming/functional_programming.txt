Основы функционального программирования



На этом курсе мы изучим несколько десятков понятий и техник функционального программирования (ФП), которые активно применяются в повседневной разработке.

Вы получите всестороннее понимание методов и приёмов функционального программирования.
Вы уже имеете хорошее теоретическое понимание ФП с прошлых курсов, теперь рассмотрим концепции и принципы ФП, которые дадут вам прочную основу для их использования непосредственно в программировании. 



1.1 Функции и объекты первого класса (First-Class Citizens)

В этом уроке мы погрузимся в концепцию функций как объектов/сущностей первого класса в языках программирования. Мы рассмотрим, что значит для функции быть First-Class Citizens, и как эта концепция может быть применена в нефункциональных языках программирования.

К концу этого урока у вас будет более глубокое понимание потенциальной мощи функций и их роли в программировании. 

 1.1.1. Функции как объекты первого класса

Функция считается объектом первого класса в программировании, если с ней можно обращаться как с любым другим значением, таким как целое число, строка или объект. Это означает, что функции можно:

a. присваивать переменным
b. передавать в качестве аргументов другим функциям
c. возвращать как значения из других функций
d. хранить в структурах данных, таких как массивы и объекты.

Когда язык программирования поддерживает отношение к функциям как к объектам первого класса, вы получаете возможность писать код более гибко и выразительно. Но эта концепция особенно важна для функциональных языков программирования, таких как Haskell и Lisp. 

 1.1.2. Понимание функций как объектов первого класса

Чтобы лучше понять концепцию функций как объектов первого класса, давайте рассмотрим несколько примеров на разных языках программирования.

a. JavaScript

В JavaScript функции считаются объектами первого класса. Вы можете присвоить функцию переменной, передать её в качестве аргумента другой функции и вернуть её в качестве значения из другой функции. Вот пример:

// Присвоить функцию переменной
const greet = function(name) {
  return 'Hello, ${name}!';
};

// Передать функцию как аргумент другой функции
const callFunction = function(fn, value) {
  return fn(value);
};

console.log(callFunction(greet, 'John')); // Output: "Hello, John!"

// Вернуть функцию из другой функции
const createAdder = function(x) {
  return function(y) {
    return x + y;
  };
};

const add5 = createAdder(5);
console.log(add5(3)); // Output: 8

b. Python

# Присвоить функцию переменной
def greet(name):
    return f"Hello, {name}!"

greeting = greet
print(greeting("John"))  # Output: "Hello, John!"

# Передать функцию как аргумент другой функции
def call_function(fn, value):
    return fn(value)

print(call_function(greet, "Jane"))  # Output: "Hello, Jane!"

# Вернуть функцию из другой функции
def create_adder(x):
    def add(y):
        return x + y
    return add

add5 = create_adder(5)
print(add5(3))  # Output: 8

 1.1.3. Преимущества функций как объектов первого класса

Отношение к функциям как к объектам первого класса в языке программирования имеет ряд преимуществ (рассматриваем далее):

a. Возможность повторного использования кода: функции можно легко использовать повторно и комбинировать различными способами, что приводит к созданию более модульного и удобного в обслуживании кода.
b. Функции высшего порядка: функции, которые принимают другие функции в качестве аргументов или возвращают их в качестве значений, называются функциями высшего порядка. Они позволяют использовать мощные методы программирования, такие как map, filter и reduce.
c. Замыкания: когда функция определена внутри другой функции и имеет доступ к переменным родительской функции, она образует замыкание. Замыкания -- это мощная схема, которая позволяет инкапсулировать и скрывать данные. 

 Заключение

На этом уроке мы изучили концепцию функций как объектов первого класса в программировании.

Мы узнали, как функции можно присваивать переменным, передавать в качестве аргументов, возвращать в качестве значений и хранить в структурах данных. Мы также рассмотрели несколько примеров на JavaScript и Python, чтобы лучше понять эту концепцию. Используя функции как объекты первого класса, мы можем писать более гибкий, выразительный и удобный в обслуживании код.



1.2 Функции высшего порядка и их применение

1.2. Функции высшего порядка

Функции высшего порядка -- это функции, которые могут принимать другие функции в качестве аргументов, возвращать функции в качестве своих значений, или делать и то, и другое. Они считаются мощным инструментом в функциональном программировании, поскольку позволяют создавать более абстрактный и многократно используемый код.

1.2.1. Функции как аргументы

Функция высшего порядка может принимать в качестве аргументов одну или несколько функций. Это позволяет создавать более универсальные функции, которые можно применять для решения широкого круга задач. Например, рассмотрим простую функцию высшего порядка applyTwice:

function applyTwice(func, value) {
  return func(func(value));
}

Эта функция принимает в качестве аргументов другую функцию func и значение value, и дважды применяет функцию func к значению. Вот пример того, как можно использовать applyTwice:

function square(x) {
  return x * x;
}

console.log(applyTwice(square, 5)); // Output: 625


 1.2.2. Функции как возвращаемые значения

Функции высшего порядка также могут возвращать функции в качестве своего результата. Это полезно, когда мы хотим создать функцию с определённым поведением, на основе указанных параметров. Например, давайте создадим функцию высшего порядка под названием makeMultiplier:

function makeMultiplier(factor) {
  return function (x) {
    return x * factor;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5)); // Output: 10
console.log(triple(5)); // Output: 15


 1.3. Композиция функций

Композиция функций - это процесс объединения двух или более функций для создания новой функции. Это мощная техника, которая позволяет нам создавать сложные функции из более простых. В функциональном программировании мы часто используем композицию функций вместо цепочки или вложенности функций.

Вот пример композиции функций:

function compose(f, g) {
  return function (x) {
    return f(g(x));
  };
}

function square(x) {
  return x * x;
}

function increment(x) {
  return x + 1;
}

const squareAfterIncrement = compose(square, increment);

console.log(squareAfterIncrement(4)); // Output: 25

В этом примере мы создали новую функцию squareAfterIncrement путём композиции функций square и increment. Функция compose берет две функции f и g и возвращает новую функцию, которая применяет f после g. 

 1.4. Каррирование

Каррирование -- это техника ФП, когда функция, принимающая несколько аргументов, преобразуется в серию функций, каждая из которых принимает один аргумент. Это может сделать функцию более модульной и более удобной для повторного использования.

Пример функции curried:

function add(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = add(5);

console.log(add5(3)); // Output: 8

В этом примере мы создали каррированную функцию add, которая принимает один аргумент x и возвращает новую функцию, принимающую другой аргумент y. Теперь мы можем создавать специализированные функции, такие как add5, частично применяя функцию add. 

 Заключение

На этом уроке мы рассмотрели композицию функций и керрирование. Эти понятия важны для функционального программирования и помогут вам писать более эффективный, модульный и многократно используемый код. Практикуйте использование этих методов в своих собственных проектах, чтобы улучшить свои навыки программирования и создавать более удобный в обслуживании код. 



2.1. Состояние и иммутабельность

2.1.1. Иммутабельность

Иммутабельность (неизменяемость) -- это свойство данных, которые после создания не могут быть изменены. В ФП неизменяемость считается предпочтительной, поскольку она помогает нам избежать неожиданных побочных эффектов и делает код более понятным. Когда данные неизменяемы, мы можем быть уверены, что они всегда имеют одно и то же значение, и нам не нужно беспокоиться о том, что они могут быть изменены другими частями нашего кода.

2.1.2. Состояние

Понятие "состояния" подразумевает возможность модификации данных в программе в любой момент времени. В ФП мы стараемся минимизировать использование состояния, и по возможности избегать изменения данных. Вместо того чтобы изменять состояние напрямую, мы используем чистые функции, которые принимают текущее состояние на вход и возвращают новое состояние на выходе. Такой подход помогает нам поддерживать предсказуемость и расширяемость нашего кода. 



2.2. Важность иммутабельности в ФП

2.2.1. Предсказуемость

Одно из главных преимуществ иммутабельности в функциональном программировании заключается в том, что она делает наш код более предсказуемым. Когда данные неизменяемы, мы можем быть уверены, что они всегда будут иметь одно и то же значение, и нам не нужно беспокоиться о том, что они могут быть изменены другими частями нашего кода. Это означает, что мы можем легче рассуждать о нашем коде и быть уверенными в том, что наши функции всегда будут выдавать один и тот же результат на одни и те же входные данных.

2.2.2. Сопровождаемость

Неизменяемые данные также делают наш код более удобным в обслуживании. Когда мы знаем, что данные не могут быть изменены, мы пишем простые и понятные функции. Нам не нужно беспокоиться о том, как управлять сложными изменениями состояния или бороться с неожиданными побочными эффектами.

2.2.3. Параллелизм

Иммутабельность особенно важна в параллельном программировании, когда несколько потоков или процессов могут одновременно обращаться к данным и изменять их. Когда данные неизменяемы, нам не нужно беспокоиться о ситуации гонки или других проблемах, связанных с параллелизмом, поскольку данные не могут быть изменены после их создания. Это значительно облегчает написание безопасного и эффективного параллельного кода. 


2.3. Применение иммутабельности на практике

2.3.1. Использование неизменяемых структур данных

Одним из способов обеспечения неизменяемости в коде считается использование неизменяемых структур данных. Многие языки программирования обеспечивают встроенную поддержку иммутабельных структур данных (кортежи или неизменяемые списки). Используя эти структуры данных, вы можете быть уверены, что данные не будут изменены случайно или непредсказуемо.

2.3.2. Исключение побочных эффектов

Еще один неочевидный способ повышения иммутабельности -- избегать побочных эффектов в своих функциях. Побочные эффекты -- это любые изменения в состоянии программы, которые происходят в результате выполнения функции за её пределами. Чистые функции, не имеющие побочных эффектов, гарантируют, что ваш код будет более предсказуемым и более понятным.

2.3.3. Использование техник ФП

Такие методы ФП, как функции высшего порядка и рекурсия, могут помочь вам написать код, в большей степени ориентированный на иммутабельность. Используя эти техники, вы можете создать код, который будет более модульным, повторно используемым и более понятным. 



Заключение

Иммутабельность -- это ключевая концепция ФП, которая помогает нам писать более предсказуемый, удобно сопровождаемый и параллельный код. Понимая важность иммутабельности и применяя этот подход в своём коде, вы можете создавать программы, о которых легче рассуждать, и которые менее подвержены ошибкам и неожиданным побочным эффектам. Далее мы рассмотрим более продвинутые концепции и методы ФП, которые помогут вам писать ещё более эффективный код.

Почитайте также вот этот мой пост https://vk.com/wall-152484379_3600 , в котором подробнее разбираю тему иммутабельнжости. 



2.4. Управление состоянием и побочные эффекты

2.4.1. Понятие состояния и побочных эффектов

Состояние характерно для данных, которые программа хранит и которыми манипулирует (изменяет) во время выполнения. В функциональном программировании состояние обычно представлено неизменяемыми структурами данных, что означает, что после присвоения значения переменной оно не может быть изменено.

Побочные эффекты, с другой стороны -- это изменения, которые функция вносит в состояние программы или окружения за пределами своей области действия. Примерами побочных эффектов будут изменение глобальных переменных, запись в базу данных или отправка данных по сети. В функциональном программировании мы стремимся минимизировать побочные эффекты, чтобы сделать наш код более предсказуемым и простым для понимания. 

 2.4.2. Важность управления состоянием и побочными эффектами

Управление состоянием и побочными эффектами важно по нескольким причинам:

- Предсказуемость: Минимизация побочных эффектов делает ваш код более предсказуемым, поскольку поведение функции зависит только от ее входа, а не от внешних факторов.

- Тестируемость: Функции с меньшим количеством побочных эффектов легче тестировать, поскольку вам не нужно управлять сложными внешними зависимостями.

- Удобство сопровождения: Код с меньшим количеством побочных эффектов легче поддерживать, поскольку изменения в одной части кода с меньшей вероятностью приведут к непредвиденным последствиям в других.

- Масштабируемость: Эффективное управление состоянием может повысить производительность вашего кода, делая его более подходящим для крупномасштабных приложений. 

 2.4.3. Стратегии управления состоянием и побочными эффектами

Вот некоторые стратегии управления состоянием и побочными эффектами в вашем коде:

- Используйте чистые функции: Чистые функции - это функции, которые не имеют побочных эффектов и всегда возвращают один и тот же результат на один и тот же вход. Использование чистых функций делает ваш код более предсказуемым и легким для тестирования.

- Инкапсулируйте состояние: Инкапсулируйте (скрывайте) состояние в объектах или модулях и предоставляйте чётко определённый интерфейс для взаимодействия с этим состоянием. Это помогает ограничить область изменения состояния и облегчает рассуждения о поведении вашего кода.

- Используйте иммутабельные структуры данных: Неизменяемые структуры данных не могут быть изменены после их создания. Их использование помогает снизить риск возникновения непреднамеренных побочных эффектов и делает ваш код более предсказуемым.

- Изолируйте побочные эффекты: Если побочные эффекты необходимы, изолируйте их от остального кода с помощью специальных функций или модулей. Это облегчает управление и тестирование побочных эффектов отдельно от остального кода.

 2.4.4. "Персистентные" структуры данных

Персистентные структуры данных -- это вид неизменяемой структуры данных, который позволяет эффективно создавать новые, модифицированные версии структуры, не изменяя её "исходник". Глобально речь идёт о том, что хранится вся история изменения конкретных данных, а не только их последнее значение. Это достигается за счёт совместного использования частей структуры данных от версии к версии, а не копированием всей структуры. Персистентность похожа на систему контроля версий, когда следующая версия кода может быть представлена не как весь код целиком, а лишь как набор изменений по отношению к предыдущей версии.

Некоторые преимущества использования персистентных структур данных:

- Снижение риска возникновения непреднамеренных побочных эффектов: Поскольку персистентные структуры данных неизменяемы, они не могут быть случайно модифицированы, что помогает предотвратить непреднамеренные побочные эффекты.

- Эффективное использование памяти: Персистентные структуры данных могут разделять части своей структуры между различными версиями, что может привести к более эффективному использованию памяти.

- Более простая функциональность undo/redo: Персистентные структуры данных упрощают реализацию функций undo/redo в вашем приложении, поскольку вы можете легко и просто переключаться между различными версиями структуры данных. 


Заключение

Управление состоянием и побочными эффектами имеет решающее значение для написания эффективного, сопровождаемого и масштабируемого кода. Используя такие стратегии, как чистые функции, инкапсуляция и неизменяемые структуры данных, вы можете свести к минимуму риск непреднамеренных побочных эффектов и сделать свой код более предсказуемым.
Персистентные структуры данных считаются мощным инструментом для управления состоянием, поскольку они позволяют создавать новые компактные версии модифицированной структуры данных, не изменяя исходную структуру. 



3.1. Чистые функции

Чистая функция -- это функция, обладающая следующими свойствами:

a. Детерминированность: при одинаковых входных данных чистая функция всегда будет возвращать один и тот же результат. Это означает, что результат функции зависит только от её входных параметров и не зависит от внешнего состояния или изменяемых данных.

b. Отсутствие побочных эффектов: чистая функция не изменяет никакого внешнего состояния и не модифицирует внешние данные. Она не изменяет свои входные аргументы, глобальные переменные или любые другие внешние данные. Она также не производит никаких наблюдаемых побочных эффектов, таких как запись в файл, вывод на консоль или изменение DOM. 


3.2. Ссылочная прозрачность

Функция считается ссылочно прозрачной, если её можно заменить соответствующим выходным значением (её результатом) без изменения поведения программы. Другими словами, если функция ссылочно прозрачна, мы можем заменить вызов функции ее результирующим значением, и программа будет вести себя так же.

Ссылочная прозрачность -- это прямое следствие того, что функция чистая. Поскольку чистые функции всегда выдают один и тот же результат на один и тот же вход и не имеют побочных эффектов, они могут быть заменены своими выходными значениями без изменения поведения программы. 


3.3. Преимущества чистых функций

Чистые функции обладают рядом преимуществ при разработке программного обеспечения:

a. Легче понимать: Поскольку чистые функции зависят только от своих входных аргументов и не полагаются на внешнее состояние, они более предсказуемы и их легче понять. Это упрощает рассуждения о поведении кода и поиск потенциальных ошибок.

b. Легче тестировать: Чистые функции легче тестировать, поскольку они не требуют дополнительных настроек в тестах. Вам нужно только задать входные аргументы и проверить результат. Это приводит к более простым и надёжным тестам.

c. Легче отлаживать: Когда ошибка возникает в чистой функции, легче определить её причину, поскольку нет скрытых зависимостей или побочных эффектов. Вы можете изолировать проблему, посмотрев на входные аргументы и реализацию функции.

d. Хорошо сопровождаемый код: Чистые функции способствуют созданию модульной и удобной в обслуживании кодовой базы. Поскольку они не зависят от внешнего состояния, вы можете легко рефакторить или заменять их, не беспокоясь о непредвиденных последствиях.

e. Повышенная производительность: Чистые функции могут быть "мемоизированы": их вывод может быть закэширован для заданного набора входных аргументов. Это может значительно повысить производительность в некоторых случаях, так как функцию не нужно повторно вычислять для тех же входных данных. 


Заключение

В этом занятии мы узнали о чистых функциях и ссылочной прозрачности -- двух важнейших принципах функционального программирования. Понимая и применяя эти концепции, вы можете писать более удобный в обслуживании, предсказуемый и эффективный код. Далее мы рассмотрим функции высшего порядка и то, как их можно использовать для создания модульного и повторно используемого кода. 



4.1. Ссылочная прозрачность

Ссылочная прозрачность -- это фундаментальная концепция функционального программирования. Функция считается ссылочно прозрачной, если она всегда выдаёт один и тот же результат на одни и те же входные значения, не вызывая никаких побочных эффектов. Это означает, что мы можем заменить любой вызов ссылочно прозрачной функции её результирующим значением без изменения поведения программы.

Ссылочная прозрачность имеет несколько следствий:

a. Легче рассуждать: Поскольку ссылочно прозрачные функции всегда выдают один и тот же результат на одни и те же входные данные, их поведение легче понять и предсказать. Это делает код более удобным для сопровождения и менее подверженным ошибкам.

b. Упрощённое тестирование: Ссылочно прозрачные функции легче тестировать, поскольку их поведение детерминировано. Вам нужно только протестировать функцию с различными входами и проверить, выдает ли она ожидаемые результаты.

c. Повышенная производительность: Ссылочно прозрачные функции могут быть мемоизированы, что означает, что их результаты могут быть закэшированы для заданного набора входных параметров. Это может повысить производительность программы за счёт исключения избыточных вычислений.

d. Параллелизм: Ссылочно прозрачные функции по своей сути потокобезопасны, поскольку они не зависят от изменяемого состояния и не вызывают побочных эффектов. Это облегчает написание параллельного кода. 


