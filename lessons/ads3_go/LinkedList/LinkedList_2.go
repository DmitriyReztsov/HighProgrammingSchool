package main

import (
	"os"
	"reflect"
)

// Рефлексию пишу на общий подход, видимо? Или я не понял, где брать эталонный алгоритм. 
// Подход, при котором мы не меняем заданные структуры, в принцпипе мне нравится своей определенностью. 
// Всегда понятно, какое значение будет лежать в результате, даже при, например, параллельных вычислениях. 
// Единственное, что немного смущает - это увеличение объектов в памяти и необходимость следить за тем, 
// чтоб памяти хватало. Подход, когда в функцию передаются копии объектов - безопасен с т.з. рантайма. 
// В то же время работа со списками (т.е. структурами) - это уже работа с указателями, поскольку даже при передаче
// списка по значению, его структура передастся по указателям. Что небезопасно.

// 1.8 функция получает на вход два связных списка и возвращает список, каждый элемент которого равен сумме соответствующих элементов входных списков.
// time complexity O(n); space complexity O(n)
func MergeLists (l1, l2 *LinkedList) LinkedList {
	count1 := l1.Count()
	count2 := l2.Count()
	if count1 != count2 || count1 == 0 {
		return LinkedList{}
	}

	mergedList := LinkedList{}
	n1 := l1.head
	n2 := l2.head
	mergedList.head = &Node{value: n1.value + n2.value}
	mNode := mergedList.head
	for true {
		if n1.next == nil {
			break
		}

		n1 = n1.next
		n2 = n2.next
		mNode.next = &Node{value: n1.value + n2.value}
		mNode = mNode.next
	}
	mergedList.tail = mNode
	return mergedList
}

