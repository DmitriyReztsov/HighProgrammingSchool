Базовое определение TDD

Test Driven Development -- это техника разработки, созданная Кентом Беком в 2002-м году.

Сначала пишется тест, затем минимальный код для его успешного прохождения, и потом проводится рефакторинг, если это требуется.

Цикл "красный-зеленый-рефакторинг" -- основа метода. Тесты пишутся до создания кода, реализующего логику тестов, что обычно новичками воспринимается контринтуитивно. Однако подтверждено многократной практикой самых крупных проектов, что TDD подход помогает существенно лучше продумывать дизайн кода и получать мгновенную обратную связь.

Есть такой мем:)

TDD появился после того, как рынок Smalltalk умер, и все Smalltalkers перешли на Java. 

Красная фаза: пишем тест, определяющий желаемое поведение, который обязательно завершается неудачей, так как соответствующей логики ещё нету.

Зеленая фаза: пишем минимальный код, с которым тест завершается успешно.

Мы должны написать минимальный код для прохождения текущего теста.

Однако разработчикам, не имеющим практики TDD, трудно это сделать, потому что они как бы должны знать, каким в конечном итоге должен быть код. Даже для опытных разработчиков это иногда может быть сложным.

Лучший способ получить качественные тесты - это мыслить в терминах спецификации поведения.

До того , как вы пишете код, вы пишете спецификации, которые задают (в форме тестов), что вам нужно, чтобы код делал. Затем вы реализуете указанное вами поведение. Таким образом, вам не нужно никого спрашивать, что тестировать: вам нужна некоторая функциональность.

"Почему я должен писать только минимальную функциональность для прохождения теста?"

Потому что вы не должны сразу фигачить потенциально неопределённое поведение.

Или может быть вы сразу точно указали всё требуемое поведение?

Мы специально используем термин "спецификация" перед термином "тест". Конечно, абсолютно допустимо тестировать только один случай или одну инструкцию. Но это немного противоречит требованию "Я написал спецификацию для одного сценария".

Спецификация подразумевает тщательность. И это именно то, чего мы хотим от наших тестов и в наших тестах.

Рефакторинг: улучшаем и оптимизируем структуру кода уже без изменения поведения, заданного тестом.

Как утверждает Дядюшка Боб в “Архитектура: Потерянные годы”, если вы хотите часто проводить небольшие рефакторинги, вам нужно быть абсолютно уверенным в том, что вы ничего не сломали. Но трудно быть достаточно дисциплинированным, чтобы написать полное тестовое покрытие после того, как ваш производственный код уже написан и запущен, и инструментами покрытия кода трудно правильно измерить, что охвачен каждый случай.

Если вместо этого вы "заранее" протестируете свой код, вы будете знать, что он полностью покрыт тестами, потому что вы не писали никакого рабочего кода, если у вас не было теста, побуждающего вас к этому. Таким образом вы можете уверенно вносить множество небольших изменений.

Каждая фаза цикла TDD должна быть короткой, обычно несколько минут.

Весь цикл повторяется для каждой новой требуемой функциональности.

TDD превращает написание тщательных тестов в увлекательное занятие: вы регулярно получаете небольшие и вполне заслуженные порции эндорфинов, поскольку каждые несколько минут добиваетесь небольших успехов в прохождении теста.

Впрочем, если вы решили, что точно знаете, что вам нужно создать, и не открыты для каких-либо обсуждений по этому поводу, то применение TDD - пустая трата времени :)

Написание тестов самоочевидно занимает больше времени: вы пишете тестовый код, на создание которого в противном случае вам не пришлось бы тратить время. В долгосрочной перспективе написание тестов всегда будет занимать заметно больше времени, чем их отсутствие.

Противоположная точка зрения заключается в том, что вы всегда тестируете свой код, и что если вы не тратите время на написание автоматических тестов, вы потратите столько же (а скорее всего существенно больше) времени на ручное тестирование, и ощутимо больше времени в долгосрочной перспективе.

По мнению некоторых гуру computer science, TDD занимает больше времени, чем создание кода без тестов, но не из–за написания самих тестов. Вместо этого, больше времени занимает рефакторинг. Просмотр кода, поиск дубликатов, подходящее ли сейчас время для создания абстракции -- всё это требует времени.

Поэтому самый полезный вопрос заключается не в том, стоят ли тесты дополнительного времени, а в том, стоит ли рефакторинг дополнительного времени.


Принципы написания тестов.

Важно давать тестам осмысленные названия.

Тесты должны быть ясными и легко  читаемыми, и чётко выражать ту фичу, которой тестируют.

Каждый тест проверяет одну конкретную вещь.

Тесты должны быть независимыми друг от друга.

В TDD используется структурный паттерн "Arrange-Act-Assert" (AAA) для организации модульных тестов, который разделяет тест на три чётких последовательных этапа:

1. Arrange (Подготовка): подготовка всех необходимых предварительных условий и входных данных для теста.

2. Act (Действие): выполнение непосредственно тестируемого действия/операции.

3. Assert (Проверка): проверка полученного результата на соответствие ожидаемому.

(Кто давно занимается на моих курсах, наверняка узнали в этом формальный подход триплов Хоара)


Стратегии реализации

Не пишите код, пока под соответствующую логику не будет написан тест, завершающийся неудачей.


Начинайте с простейшей реализации логики, которую задаёт тест, даже если она кажется "неправильной". Постепенно усложняйте код через рефакторинг.


Используйте триангуляцию -- написание нескольких тестов для выявления более общего поведения (покрытие разных сценариев или краевых случаев).  


Рефакторинг.

Рефакторинг делается только на зелёных тестах.

Важно вносить в код маленькие безопасные изменения.

Устраняйте дублирование кода.

Улучшайте названия переменных и структуру кода.

Применяйте паттерны проектирования при необходимости.


Шаблоны TDD

Изолированный тест: тестируемый код не зависит от внешних систем.


Конструктор тестовых данных (Test Data Builder): создание тестовых данных.

Тестовый дублёр (Test Double): замена реальных зависимостей (dummy, stub, mock, fake).... 

При написании изолированных тестов оказалось, что тестируемый класс косвенно зависит от десятков других классов через цепочку вызовов. Какой подход будет наиболее правильным?

Правильно: делаем рефакторинг архитектуры, чтобы уменьшить связность.
Большое количество зависимостей - признак проблем с архитектурой, а создание множества Test Doubles сделает тесты хрупкими и сложными в поддержке.

Есть успешно работающий Test Data Builder для создания сложных тестовых данных. Потребовалось добавить валидацию данных в продуктовом коде. Как следует модифицировать Builder?

Правильно оставить Builder без изменений, чтобы иметь возможность тестировать поведение системы с невалидными данными. Builder должен позволять создавать любые данные для тестирования всех сценариев, включая обработку ошибок, а встроенная валидация помешает тестировать негативные случаи.

Некоторые тесты периодически падают из-за сложного взаимодействия между моками. Какое решение будет наиболее корректным?

Фейк (Fake) - это один из видов Test Doubles, который предоставляет работающую реализацию компонента, но обычно в упрощённой форме.

Чрезмерное использование моков и проверок взаимодействия делает тесты хрупкими.
Стабы проще и надёжнее, когда нужно только вернуть определённое значение без проверки взаимодействия.


Тестовые "фикстуры"

Тестовые "фикстуры" (Test Fixtures) подразумевают повторное использование настройки тестового окружения, подразумевающее некоторое фиксированное состояние набора тестовых  объектов, которое становится базой для запуска тестов. Фикстуры подразумевают некоторую стандартизованную среду, в которой тесты могут выполняться надёжно и повторяемо.

Test Fixtures -- это механизм для установки предварительных условий, необходимых для выполнения теста (setup), и очистки после выполнения теста (teardown). Он позволяет избежать дублирования кода настройки тестового окружения для самых разных тестов.

Test Fixtures обычно подразумевает создание временных/тестовых баз данных, создание объектов-заглушек (mocks), загрузку некоторого стандартного набора данных, и при необходимости копирование различных рабочих файлов в заданные места.

В проекте создана большая тестовая "фикстура", которая настраивает сложное состояние базы данных для тестов, однако время выполнения тестов при этом значительно выросло. Какое решение наиболее оптимально?

Разделить фикстуру на несколько меньших, специализированных для разных групп тестов


При использовании общей фикстуры некоторые тесты периодически падают из-за проблем с параллельным выполнением. Что будет наименее рискованным решением?

Создать отдельный копии для каждого потока выполнения


Тестовая фикстура создаёт сложный граф объектов для тестирования. После рефакторинга продуктового кода тесты стали часто падать. Какой подход к организации фикстур мог бы минимизировать эту проблему?

Применяйте Builder: он инкапсулирует детали создания объектов и их взаимосвязей, что делает тесты более устойчивыми к изменениям внутренней структуры классов.

Object Mother - это порождающий паттерн проектирования, применяемый для создания готовых к использованию тестовых объектов. Это по сути фабрика, которая предоставляет методы для создания предварительно сконфигурированных объектов в часто используемых состояниях.


Практические советы.

Практикуйтесь сперва на маленьких примерах.

Тесты должны быть быстрыми и исполняться за секунды.

Регулярно запускайте абсолютно все тесты.

Немедленно исправляйте любые неудачные тесты.

Учитесь использовать TDD не только как технический подход, но и как высокоуровневый инструмент software design.

Соблюдайте адекватный баланс между увеличением тестового покрытия и практической ценностью тестов.

 Один разработчик настаивает на написании тестов для всех геттеров/сеттеров, аргументируя это необходимостью 100% покрытия, а другой считает это пустой тратой времени. Какой подход наиболее соответствует философии TDD?

Правильно писать тесты только для методов с проектной логикой.
TDD - это прежде всего инструмент дизайна и обеспечения качества, а не слепая погоня за метриками. Тестирование тривиального кода не добавляет никакой пользы.


Джуниор пишет много маленьких тестов, каждый проверяет буквально одно простое условие. Сеньор пишет меньше тестов, но они более комплексные. Чей подход правильнее с точки зрения TDD?

Хотя маленькие тесты имеют свои преимущества, комплексные тесты более полезны, т.к. отражают реальные требования и сценарии использования, а не просто проверяют технические детали реализации.


Ключевые идеи TDD.

1. Главный принцип: "Сначала тест, потом код"

- Это переворачивает традиционный подход к программированию.

- Заставляет думать о дизайне кода до его написания.

2. Базовый цикл разработки:

- Красный: написать тест (который не проходит, завершается неудачей).

- Зелёный: написать простейший код, реализующий этот тест (чтобы тест прошел успешно).

- Рефакторинг: улучшить код (без изменения его поведения, которое контролируется тестом как спецификацией).

3. Фундаментальные правила:

- Не пишите никакого нового кода без теста, который формально определяет его логику.

- На зелёной фазе пишите самый минимум кода для прохождения теста.

- Рефакторинг выполняем только после успешного прохождения всех имеющихся тестов.

4. Основные преимущества TDD:

- Уверенность в работоспособности существующего кода.

- Более лучший дизайн системы за счёт того, что первоначально мы думаем над логикой на более высоком уровне абстракций/ спецификаций в формате тестов.

- Готовая документация в виде тестов.

- Быстрая обратная связь от разрабатываемой системы, контролируемой наборами тестов.

По сути, TDD -- это радикально иной подход к созданию программного обеспечения, который меняет сам процесс мышления разработчика в лучшую сторону.


