# 1 связывание в момент компиляции
class DynArray:
    DOWN_RESIZE_CAPACITY_CONDITION = 0.5
    DOWN_RESIZE_CAPACITY_RATE = 1.5
    MINIMUM_CAPACITY = 16

    def __init__(self) -> None:
        ...

тут происходит связывание переменных, объявленных в рамках всего класса. Переменные являются настройками для работы класса.
Их можно было бы также объявить и инициализировать в файле настроек.
Такой выбор был сделан, поскольку менять значения этих переменных в рантайме нет необходимости, при этом в случае необходимости
исправить значения в рамках всего проекта можно легко в одном месте.

# 2 связывание в рантайме
class DynArray:
    ...
    def __init__(self) -> None:
        ...
        self.array = self._make_array(self.capacity)

    def _make_array(self, new_capacity: int) -> List:
        ar = (new_capacity * ctypes.py_object)()
        return ar

тут происходит связывание в процессе выполнения программы, при инициализировании нового объекта класса. Значение переменной
вычисляется, при необходимости изменить логику получения значения нужно вносить изменения в одном месте. При этом к специфичному
для этого класса методу из других частей програмы доступа нет (ну как нет... как во всем Питоне...)

# 3 связывание во время написания когда
class DynArray:
    ...
    def __init__(self) -> None:
        self.count = 0
        ...

тут просто инициализируется переменная-счетчик начальным значением. Вряд ли мы захотим инициализировать счетчик каким-то иным значением.
Плюс, для каждого объекта / класса писать глобальную переменную с 99%-й вероятностью, что она будет 0 - несколько излишне, мне кажется.
